[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Exploratory Data Analysis in R with the tidyverse Seminar",
    "section": "",
    "text": "Welcome to this page for the Exploratory Data Analysis in R with the tidyverse (for Instats)! Here you will find information about the seminar, including links to the materials (slides and walkthroughs + answers). Many additional examples are available for free in our ModernDive v2 textbook, which is also available in print by CRC Press."
  },
  {
    "objectID": "slides.html",
    "href": "slides.html",
    "title": "Slides",
    "section": "",
    "text": "Here are the slides for each session (in PDF format):\n\nDay 1 (Session 1)\nDay 1 (Session 2)\nDay 1 (Session 3)\nDay 2 (Session 4)\nDay 2 (Session 5)\nDay 2 (Session 6)"
  },
  {
    "objectID": "walkthroughs.html",
    "href": "walkthroughs.html",
    "title": "Walkthroughs",
    "section": "",
    "text": "The palmtrees_funky.csv file used in Session 6 for the Case Study is available here.\nThe blank notebooks for each day (in Quarto format):\n\nDay 1 (Sessions 1-3) Walkthroughs\nDay 2 (Sessions 4-6) Walkthroughs\n\nThe answer keys for each day (in Quarto format):\n\nDay 1 (Sessions 1-3) Walkthrough Answers \nDay 2 (Sessions 4-6) Walkthrough Answers"
  },
  {
    "objectID": "answers/day2_walkthrough_answers.html",
    "href": "answers/day2_walkthrough_answers.html",
    "title": "Exploratory Data Analysis in R with the tidyverse",
    "section": "",
    "text": "# Load the required packages and data\nlibrary(purrr)\nlibrary(moderndive)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(plotly)\nlibrary(azflights24)\nlibrary(lubridate)\n\nspotify &lt;- spotify_by_genre |&gt;\n  dplyr::distinct(track_name, .keep_all = TRUE) \n\nThis gets us back to where we were before when we finished up the Day 1 material.\n\n\n\n\n# Summarize multiple numeric audio features by calculating their mean and standard deviation\n# Use across() to apply functions over selected columns\n# Reshape the output so each row represents a feature-statistic combination\n\nspotify |&gt;\n  summarize(across(\n    c(popularity, danceability, energy, tempo),\n    list(mean = ~mean(.x, na.rm = TRUE),\n         sd = ~sd(.x, na.rm = TRUE))\n  )) |&gt;\n  pivot_longer(everything(), names_to = c(\"feature\", \"stat\"), names_sep = \"_\")\n\n# A tibble: 8 × 3\n  feature      stat    value\n  &lt;chr&gt;        &lt;chr&gt;   &lt;dbl&gt;\n1 popularity   mean   41.7  \n2 popularity   sd     26.3  \n3 danceability mean    0.593\n4 danceability sd      0.153\n5 energy       mean    0.731\n6 energy       sd      0.176\n7 tempo        mean  125.   \n8 tempo        sd     27.6  \n\n\n\nWe use across() to apply mean() and sd() to multiple numeric columns at once, avoiding repetitive code.\n\nThe selected features—popularity, danceability, energy, and tempo—are each summarized with both statistics.\n\nThe list() inside across() allows us to define multiple summary functions at once.\n\npivot_longer() reshapes the wide summary output into long format, with separate feature and stat columns.\n\nThis tidy format is ideal for further analysis or plotting, especially when comparing metrics across features.\n\n\n\n\n\n# Define a custom function to extract featured artist names from track titles\n# Looks for phrases like \"(feat. XYZ)\" or \"(with XYZ)\" using regex\nextract_feature &lt;- function(name) {\n  str_extract(name, \"(?i)(?&lt;=\\\\()(with|feat\\\\.)[^)]*(?=\\\\))\")\n}\n\n\n# Apply the extraction function to each track name using map_chr\n# Create a new column for the extracted featured artist string\n# Filter to show only tracks that actually contain a featured artist\n# Then display a random sample of 30 such tracks\nspotify |&gt;\n  mutate(feature_raw = map_chr(track_name, extract_feature)) |&gt;\n  select(track_name, feature_raw, track_genre) |&gt;\n  filter(!is.na(feature_raw)) |&gt; \n  slice_sample(n = 30)\n\n# A tibble: 30 × 3\n   track_name                                                          feature_raw              track_genre\n   &lt;chr&gt;                                                               &lt;chr&gt;                    &lt;chr&gt;      \n 1 Slow It Down (feat. L8NCY)                                          feat. L8NCY              dubstep    \n 2 Returning To You (feat. Alison May)                                 feat. Alison May         dubstep    \n 3 Space Cadet (feat. Gunna)                                           feat. Gunna              hip-hop    \n 4 From The Ashes (with Skylar Grey) - Paul van Dyk Remix              with Skylar Grey         dubstep    \n 5 Hurts Sometimes (with Jonathan Mendelsohn)                          with Jonathan Mendelsohn dubstep    \n 6 Can't Love Myself (feat. Mishaal & LPW)                             feat. Mishaal & LPW      deep-house \n 7 Sad Songs (feat. L Devine)                                          feat. L Devine           deep-house \n 8 California Dreamin' (feat. High Jinx) (LP Giobbi Remix)             feat. High Jinx          deep-house \n 9 Stay Hollow (with mossy.)                                           with mossy.              dubstep    \n10 Good Things Fall Apart (with Jon Bellion) [Tiësto's Big Room Remix] with Jon Bellion         dubstep    \n# ℹ 20 more rows\n\n\n\nWe define a custom function using str_extract() to pull featured artist names from track titles that include phrases like (feat. ...) or (with ...).\n\nThe regex uses lookarounds to extract the text inside parentheses without keeping the parentheses themselves.\n\nWe apply this function to every track using map_chr() from the purrr package, creating a new column feature_raw.\n\nFiltering for non-NA values isolates only those tracks that contain featured artists.\n\nSampling 30 rows gives us a quick view of how featured artists appear in the data.\n\n\n\n\n\n# Split the spotify dataset into a list of data frames, one per genre\ngenre_groups &lt;- spotify |&gt;\n  group_split(track_genre)\n\n# Assign names to each list element based on the genre\nnames(genre_groups) &lt;- spotify |&gt;\n  distinct(track_genre) |&gt;\n  pull()\n\n\n# Apply a trimmed mean function to the popularity column of each genre\n# map_dbl() returns a named numeric vector of trimmed means\nmap_dbl(genre_groups, ~ mean(.x$popularity, trim = 0.1, na.rm = TRUE))\n\n   country deep-house    dubstep    hip-hop      metal       rock \n  21.12998   49.38589   44.36298   52.18357   50.24155   26.52342 \n\n\n\nWe use group_split() to divide the dataset into a list of smaller data frames—one for each genre.\n\nnames() assigns the genre names to each list element, making the output easier to read and interpret.\n\nmap_dbl() applies a trimmed mean function to the popularity column of each genre-specific data frame.\n\nUsing trim = 0.1 excludes the top and bottom 10% of values, reducing the influence of outliers.\n\nThis workflow is useful for applying custom or complex operations across groups that aren’t easily handled with summarize().\n\n\n\n\n\n# Identify the top 3 most common genres by number of tracks\n# Extract the genre names into a character vector\ntop_genres &lt;- spotify |&gt;\n  count(track_genre, sort = TRUE) |&gt;\n  slice_head(n = 3) |&gt;\n  pull(track_genre)\n\ntop_genres\n\n[1] \"deep-house\" \"dubstep\"    \"metal\"     \n\n\n\n# For each of the top 3 genres, create a histogram of popularity\n# Save each plot as a PNG file using ggsave()\nwalk(top_genres, function(genre_name) {\n  p &lt;- spotify |&gt;\n    filter(track_genre == genre_name) |&gt;\n    ggplot(aes(x = popularity)) +\n    geom_histogram(binwidth = 5, fill = \"forestgreen\", color = \"black\") +\n    labs(title = paste(\"Popularity for\", genre_name), \n         x = \"Popularity\", y = \"Count\")\n  \n  ggsave(filename = paste0(\"popularity_\", genre_name, \".png\"), plot = p, \n         width = 6, height = 4)\n})\n\n\nWe identify the top 3 genres in the dataset by counting the number of tracks per genre and extracting their names.\n\nwalk() is used to iterate over each top genre and execute a plotting-and-saving routine without returning values.\n\nFor each genre, we filter the data and generate a histogram of track popularity.\n\nggsave() saves each plot as a PNG file with a genre-specific filename.\n\nThis approach is ideal for automating repetitive visualizations or exports for different subgroups in a dataset.\n\n\n\n\n\n# Define a function that returns TRUE if a title is all uppercase\n# It allows spaces, digits, and punctuation but must contain at least one A–Z letter\nis_all_caps &lt;- function(x) {\n  str_detect(x, \"^[A-Z\\\\s0-9[:punct:]]+$\") & str_detect(x, \"[A-Z]\")\n}\n\n\n# Apply the function to each track title to flag shouting titles\n# Add a new logical column and sort the data so TRUE values appear first\n(\n  shout_labeled &lt;- spotify |&gt;\n    mutate(is_shouting = map_lgl(track_name, is_all_caps), .after = track_name) |&gt;\n    arrange(desc(is_shouting))\n)\n\n# A tibble: 4,311 × 22\n   track_id artists album_name track_name is_shouting popularity duration_ms explicit danceability energy   key loudness\n   &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;      &lt;lgl&gt;            &lt;dbl&gt;       &lt;dbl&gt; &lt;lgl&gt;           &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n 1 1gH8Qig… Tim Mc… Sad Count… 7500 OBO   TRUE                 3      221400 FALSE           0.528  0.718     7    -6.95\n 2 1x41485… Koe We… Harold Sa… L.T.W.Y.H… TRUE                48      209849 FALSE           0.439  0.528     9    -7.12\n 3 7yBcGJF… Tyler … Suffer in… C.O.U.N.T… TRUE                45      201026 FALSE           0.459  0.89      9    -4.45\n 4 0BCy325… Florid… Dig Your … H.O.L.Y.   TRUE                71      194186 FALSE           0.523  0.666     7    -4.08\n 5 2S8UMuL… Niko M… GOOD TIME  GOOD TIME  TRUE                70      214720 FALSE           0.802  0.59      5    -7.19\n 6 3rLEBpW… Kelsea… SUBJECT T… MUSCLE ME… TRUE                66      211843 FALSE           0.596  0.786     8    -4.78\n 7 3bWAqKD… Robin … OK         OK         TRUE                63      189306 FALSE           0.653  0.81      7    -6.03\n 8 6JjSoJ2… Chris … MAMI       MAMI       TRUE                66      247896 TRUE            0.758  0.944     3    -4.90\n 9 0FMLbet… James … B2B        B2B        TRUE                54      160000 FALSE           0.799  0.956     0    -6.41\n10 3VQWkf0… ESSEL   BUBBLEGUM  BUBBLEGUM  TRUE                57      148538 FALSE           0.838  0.803     6    -5.58\n# ℹ 4,301 more rows\n# ℹ 10 more variables: mode &lt;dbl&gt;, speechiness &lt;dbl&gt;, acousticness &lt;dbl&gt;, instrumentalness &lt;dbl&gt;, liveness &lt;dbl&gt;,\n#   valence &lt;dbl&gt;, tempo &lt;dbl&gt;, time_signature &lt;dbl&gt;, track_genre &lt;chr&gt;, popular_or_not &lt;chr&gt;\n\n\n\n# Count how many tracks are considered \"shouting\" titles vs not\nshout_labeled |&gt;\n  count(is_shouting)\n\n# A tibble: 2 × 2\n  is_shouting     n\n  &lt;lgl&gt;       &lt;int&gt;\n1 FALSE        4211\n2 TRUE          100\n\n\n\nWe define a custom function is_all_caps() that detects if a string is written entirely in uppercase letters, allowing spaces, numbers, and punctuation.\n\nThe function also ensures that at least one A–Z letter is present, avoiding false positives like strings made only of symbols.\n\nmap_lgl() applies the function to each track name, producing a new logical column is_shouting.\n\nWe insert the new column right after track_name using .after, keeping the data tidy and readable.\n\nSorting the dataset by is_shouting brings all uppercase titles to the top for easy inspection.\n\nFinally, we use count() to summarize how many shouting vs. non-shouting titles are in the dataset.\n\n\n\n\n\n# Identify the top 3 most common genres by track count\n# For each genre, create a filtered data frame with one artist per row\ntop_genre_dfs &lt;- spotify |&gt;\n  count(track_genre, sort = TRUE) |&gt;\n  slice_head(n = 3) |&gt;\n  pull(track_genre) |&gt;\n  map(~ spotify |&gt;\n        filter(track_genre == .x) |&gt;\n        separate_rows(artists, sep = \";\") |&gt;\n        select(track_name, artists))\n\n\n# Combine all genre-specific data frames into one using reduce() and bind_rows()\ntop_genre_combined &lt;- reduce(top_genre_dfs, bind_rows)\n\n# Count how often each artist appears in the top 3 genres\ntop_genre_combined |&gt; count(artists, sort = TRUE)\n\n# A tibble: 1,785 × 2\n   artists                   n\n   &lt;chr&gt;                 &lt;int&gt;\n 1 ILLENIUM                 91\n 2 Linkin Park              59\n 3 SLANDER                  35\n 4 Seven Lions              34\n 5 Tritonal                 29\n 6 Porter Robinson          27\n 7 Red Hot Chili Peppers    27\n 8 Krewella                 25\n 9 Lucas Estrada            24\n10 Said The Sky             24\n# ℹ 1,775 more rows\n\n\n\nWe use map() to apply the same filtering and transformation steps to the top 3 genres, producing a list of genre-specific data frames.\n\nseparate_rows() splits artist collaborations so each artist gets their own row, allowing for accurate counts.\n\nEach mini data frame keeps only the track_name and artists columns for focused analysis.\n\nreduce() with bind_rows() merges all the genre-specific data frames into one unified dataset.\n\nThe final count() tallies how often each artist appears across the top genres, highlighting the most active contributors.\n\nThis pattern is great for when you need to analyze subgroups separately before combining results for broader insight.\n\n\n\n\n\n# Select only character columns for text-based search\n# Use imap_lgl() to check each column for any value that includes the word \"may\" (case-insensitive)\n# Return only the columns where the condition is TRUE\nspotify |&gt;\n  select(where(is.character)) |&gt;\n  imap_lgl(~ any(str_detect(str_to_lower(.x), \"may\"))) |&gt;\n  keep(identity)\n\n  track_id    artists album_name track_name \n      TRUE       TRUE       TRUE       TRUE \n\n\n\nWe limit our search to character columns using select(where(is.character)), focusing only on text-based fields.\n\nimap_lgl() checks each column to see if any of its values include the word “may” (case-insensitive).\n\nThe use of str_to_lower() ensures matches regardless of capitalization (e.g., “May”, “MAY”, “may”).\n\nThe result is a logical vector indicating which columns contain at least one match.\n\nkeep(identity) filters this vector to return only the columns where the condition is TRUE.\n\nThis is a flexible technique for pattern searching across a dataset when you don’t know exactly where a value might be found.\n\n\n\n\n\n# Define which numeric audio features to visualize\nfeatures &lt;- c(\"energy\", \"danceability\", \"valence\")\n\n# Create a function that builds a violin plot of the given feature\n# Plots distribution by popularity group and facets by genre\nmake_boxplot &lt;- function(var_name) {\n  spotify |&gt;\n    ggplot(aes(x = popular_or_not, y = .data[[var_name]], fill = popular_or_not)) +\n    geom_violin(show.legend = FALSE, draw_quantiles = c(0.25, 0.5, 0.75)) +\n    facet_wrap(facets = vars(track_genre), nrow = 2) +\n    labs(\n      title = paste(\"Violin plot of\", var_name, \"by popularity and genre\"),\n      y = var_name,\n      x = NULL\n    )\n}\n\n\n# Use map() to generate a list of plots—one per feature\nboxplots &lt;- map(features, make_boxplot)\n\n# Use walk2() to print a message before showing each plot\nwalk2(\n  .x = boxplots,\n  .y = features,\n  .f = ~ {\n    cat(\"Now plotting:\", .y, \"by popularity\\n\")\n    print(.x)\n  }\n)\n\nNow plotting: energy by popularity\n\n\n\n\n\nNow plotting: danceability by popularity\n\n\n\n\n\nNow plotting: valence by popularity\n\n\n\n\n\n\nWe define a reusable function make_boxplot() that creates a violin plot of any selected audio feature by popularity and genre.\n\n.data[[var_name]] allows dynamic column selection within aes() when working inside a function.\n\nfacet_wrap() creates separate panels for each genre, making genre-wise comparisons easy.\n\nmap() generates a list of plots—one for each feature in the features vector.\n\nwalk2() prints a custom message and displays each plot sequentially, helping to narrate the output.\n\nThis workflow automates repetitive plotting tasks and supports scalable, tidy visual exploration.\n\n\n\n\n\n# Define which numeric features we want to analyze\nfeatures &lt;- c(\"energy\", \"danceability\", \"tempo\", \"valence\")\n\n# Create a function that:\n# (1) finds the most extreme (highest) track for a feature\n# (2) counts how many values are missing\n# (3) creates a histogram of the feature\nfeature_info_plot &lt;- function(var, ...) {\n  \n  # Convert character column name to symbol\n  var_sym &lt;- sym(var)\n  \n  # Find the track with the highest value for the feature\n  top_track &lt;- spotify |&gt;\n    filter(!is.na(!!var_sym)) |&gt;\n    arrange(desc(!!var_sym)) |&gt;\n    slice(1) |&gt;\n    select(track_name, artists, !!var_sym)\n  \n  # Count missing values for the feature\n  n_missing &lt;- spotify |&gt;\n    summarize(missing = sum(is.na(!!var_sym))) |&gt;\n    pull(missing)\n  \n  # Create a histogram for the feature\n  plot &lt;- ggplot(spotify, aes(x = !!var_sym)) +\n    geom_histogram(fill = \"coral\", color = \"black\", ...) +\n    labs(title = paste(\"Distribution of\", var), x = var)\n  \n  # Return a list with all outputs\n  list(top_track = top_track, missing = n_missing, plot = plot)\n}\n\n\n# Apply the summary+plot function to each feature\nresults &lt;- map(features, feature_info_plot, bins = 30)\n\n# Example: View the top track, missing count, and histogram for danceability\nresults[[2]]$top_track\n\n# A tibble: 1 × 3\n  track_name artists                        danceability\n  &lt;chr&gt;      &lt;chr&gt;                                 &lt;dbl&gt;\n1 Pineapple  Ty Dolla $ign;Gucci Mane;Quavo        0.964\n\nresults[[2]]$missing\n\n[1] 0\n\nresults[[2]]$plot\n\n\n\n\n\nWe define a single function that bundles three tasks: finding the top-valued track, counting missing values, and creating a histogram for a given feature.\n\nsym(var) combined with the tidy evaluation operator !! allows us to dynamically reference column names in both dplyr and ggplot2, making the function reusable across variables.\n\nThe top_track output shows which song has the highest value for the selected feature.\n\nThe missing count gives quick insight into data quality for each feature.\n\nEach plot is a histogram of the feature’s distribution, styled with customizable arguments like bins.\n\nMapping the function over multiple features automates a detailed, consistent summary for each variable.\n\n\n\n\n\n(4.1) What is the primary benefit of using map_*() functions from the purrr package?\nA. They allow you to mutate multiple columns in a single step without grouping.\nB. They eliminate the need for using loops by applying a function across lists or vectors, returning a consistent output type.\nC. They automatically create interactive plots for each element of a list.\nD. They convert data frames into nested tibbles grouped by variable type.\n\n(4.2) In the context of functional programming in R, what is a key reason for using walk() instead of map()?\nA. walk() is used when you want to display plots as inline HTML.\nB. walk() is preferred when applying a function with a return value that will be used later.\nC. walk() is for performing operations with side effects (e.g., saving plots), where you don’t need a return value.\nD. walk() is the only purrr function that supports parallel processing out of the box.\n\n(4.3) What is a major advantage of defining reusable functions (e.g., is_all_caps() or feature_info_plot()), especially when paired with map()?\nA. It allows you to convert tidyverse functions into base R equivalents.\nB. It minimizes the need for conditional logic and nesting entirely.\nC. It supports clearer, modular code that can be reused and debugged more easily.\nD. It ensures all results are automatically returned as JSON-compatible outputs.\n\n(4.4) How does the reduce() function complement map() when working with lists?\nA. It generates side-effect functions like ggsave() or print(), replacing the need for walk().\nB. It sequentially combines list elements using a binary function, such as merging multiple data frames.\nC. It transforms character vectors into numeric ones using consistent logic.\nD. It is used to convert factor variables to character to prepare for visualization.\n\n(4.5) Which scenario best illustrates the use of imap_lgl() in exploratory analysis?\nA. Searching a list of numeric vectors to compute trimmed means.\nB. Iterating over grouped plots and saving them to PNGs with labeled filenames.\nC. Searching all character columns to identify which contain a specific keyword like “may”.\nD. Converting grouped data frames into JSON summaries for API output.\n\n\n\n\n(4.1) What is the primary benefit of using map_*() functions from the purrr package?\nCorrect Answer:\nB. They eliminate the need for using loops by applying a function across lists or vectors, returning a consistent output type.\nExplanation:\nmap_*() functions (like map_dbl(), map_chr()) replace loops with concise, type-safe iteration, ensuring uniform output structures.\n\n(4.2) In the context of functional programming in R, what is a key reason for using walk() instead of map()?\nCorrect Answer:\nC. walk() is for performing operations with side effects (e.g., saving plots), where you don’t need a return value.\nExplanation:\nUnlike map(), which returns a value, walk() is used when the function’s purpose is the action itself, like writing files or printing.\n\n(4.3) What is a major advantage of defining reusable functions (e.g., is_all_caps() or feature_info_plot()), especially when paired with map()?\nCorrect Answer:\nC. It supports clearer, modular code that can be reused and debugged more easily.\nExplanation:\nEncapsulating logic into small, named functions improves code clarity and allows consistent reuse across multiple inputs with map().\n\n(4.4) How does the reduce() function complement map() when working with lists?\nCorrect Answer:\nB. It sequentially combines list elements using a binary function, such as merging multiple data frames.\nExplanation:\nWhile map() transforms each list element, reduce() is used to combine them—e.g., stacking multiple data frames into one using bind_rows.\n\n(4.5) Which scenario best illustrates the use of imap_lgl() in exploratory analysis?\nCorrect Answer:\nC. Searching all character columns to identify which contain a specific keyword like “may”.\nExplanation:\nimap_lgl() applies a function to each column (and can use column names), returning a logical vector—perfect for targeted searches.\n\n\n\n\n\n\n\n\n# Create a static scatterplot with ggplot2 comparing danceability and energy\n( p &lt;- ggplot(spotify, aes(x = danceability, y = energy)) +\n  geom_point(alpha = 0.1, color = \"red\") +\n  labs(title = \"Energy vs Danceability\") )\n\n\n\n\n\n# Convert the static ggplot to an interactive plot using plotly\nggplotly(p)\n\n\n\n\n\n\nWe create a scatterplot using ggplot2 to explore the relationship between danceability and energy.\n\ngeom_point(alpha = 0.4) adds transparency, helping reveal patterns even in dense areas of the plot.\n\nClear axis labels and a title make the visualization easy to interpret.\n\nWrapping the plot in ggplotly() converts it into an interactive chart with zoom, pan, and tooltip support.\n\nThis quick upgrade improves usability and is ideal for data exploration, teaching, or interactive reporting.\n\n\n\n\n\nset.seed(2025)\n\n# Create a scatterplot with custom hover text showing track name, artists, and genre\np &lt;- ggplot(spotify |&gt; slice_sample(n = 100),\n            aes(x = danceability, y = energy,\n                text = paste(\"Track:\", track_name,\n                             \"&lt;br&gt;Artist(s):\", artists,\n                             \"&lt;br&gt;Genre:\", track_genre))) +\n  geom_point(aes(color = track_genre)) +\n  labs(title = \"Energy vs Danceability (Hover to Explore)\")\n\n\n# Convert the plot to an interactive version with custom tooltip enabled\nggplotly(p, tooltip = \"text\")\n\n\n\n\n\n\nWe use slice_sample(n = 100) to reduce the dataset to a manageable size for visual clarity.\n\nThe text aesthetic customizes hover content to display track name, artist(s), and genre in HTML format.\n\ngeom_point() creates the scatterplot, with transparency set to 0.7 for better visibility.\n\nggplotly(..., tooltip = \"text\") ensures that the interactive tooltips use our custom hover text.\n\nThis approach enhances user experience by adding context to each point in the plot, making it ideal for exploration or dashboards.\n\n\n\n\n\n# Count the number of tracks in each genre and sort from most to least\ngenre_counts &lt;- spotify |&gt; count(track_genre, sort = TRUE)\n\n\n# Create an interactive bar chart using plotly::plot_ly\n# Display track counts with custom hover text\nplot_ly(\n  data = genre_counts,\n  x = ~reorder(track_genre, n),\n  y = ~n,\n  type = \"bar\",\n  hovertext = ~paste(n, \"tracks\"),\n  hoverinfo = \"text\"\n) |&gt; \n  layout(\n    title = \"Number of Tracks by Genre\",\n    xaxis = list(title = \"Genre\"),\n    yaxis = list(title = \"Track Count\")\n  )\n\n\n\n\n\n\nWe use count(track_genre, sort = TRUE) to tally how many tracks belong to each genre, ordered from most to least.\n\nplot_ly() builds an interactive bar chart with type = \"bar\" and uses reorder() to sort genres along the x-axis.\n\nCustom hover text (paste(n, \"tracks\")) enhances readability when exploring the plot.\n\nhoverinfo = \"text\" ensures only the custom tooltip is shown, not raw values.\n\nlayout() adds a clear title and axis labels, making the plot suitable for reports or dashboards.\n\nThis example demonstrates how to create sleek, interactive summaries of categorical variables with minimal code.\n\n\n\n\n\n# Create an interactive boxplot of energy levels across genres\nspotify |&gt; \n  plot_ly(\n    x = ~track_genre,\n    y = ~energy,\n    type = \"box\"\n  )\n\n\n\n\n\n\nWe use plot_ly() with type = \"box\" to visualize the distribution of energy across music genres.\n\nEach boxplot shows the median, interquartile range, and potential outliers for that genre’s energy scores.\n\nThe interactive format allows users to hover and explore exact values, enhancing interpretability.\n\nlayout() adds informative axis labels and a descriptive title for clarity.\n\nThis plot is great for comparing variability and central tendencies across categories in an engaging way.\n\n\n\n\n\n# Convert dataset to long format for multiple features\nspotify_long &lt;- spotify |&gt;\n  select(energy, danceability, valence, popular_or_not) |&gt;\n  pivot_longer(cols = -popular_or_not, names_to = \"feature\", values_to = \"value\")\n\n\n# Create a faceted boxplot comparing distributions across popularity groups\n# One facet per audio feature\np &lt;- ggplot(spotify_long, aes(x = popular_or_not, y = value, fill = popular_or_not)) +\n  geom_boxplot() +\n  facet_wrap(~ feature, scales = \"free\") +\n  labs(title = \"Feature Distributions by Popularity Group\")\n\n\n# Convert the static faceted plot to an interactive plot\nggplotly(p)\n\n\n\n\n\n\nWe use pivot_longer() to reshape multiple audio features into a long format, enabling easy comparison across variables.\n\nThe resulting dataset has one column for feature names (feature) and one for their values (value).\n\nfacet_wrap() creates a separate boxplot for each feature, grouped by popular_or_not, with independent y-axis scales.\n\ngeom_boxplot() summarizes each feature’s distribution, highlighting medians, quartiles, and outliers.\n\nConverting the plot with ggplotly() adds interactivity, letting users hover over each box to see exact values.\n\nThis method is ideal for visualizing how multiple features differ between groups in a clean, side-by-side layout.\n\n\n\n\n\n# Create an interactive line chart of daily max wind gusts at FLG airport\nazflights24::weather |&gt;\n  filter(origin == \"FLG\") |&gt;\n  mutate(date = as_date(time_hour)) |&gt;\n  group_by(date) |&gt;\n  summarize(max_gust = max(wind_gust, na.rm = TRUE)) |&gt;\n  plot_ly(x = ~date, y = ~max_gust, type = \"scatter\", mode = \"lines\") |&gt;\n  layout(\n    title = \"\\nDaily Max Wind Gust in Flagstaff\",\n    xaxis = list(title = \"Date\"),\n    yaxis = list(title = \"Max Wind Gust (mph)\")\n  )\n\n\n\n\n\n\nWe filter the weather dataset for Flagstaff (FLG) and convert hourly timestamps to calendar dates using as_date().\n\ngroup_by(date) and summarize() compute the maximum wind gust for each day.\n\nplot_ly() creates an interactive line chart with type = \"scatter\" and mode = \"lines\" to show the trend over time.\n\nThe interactive plot supports zooming and tooltips, making it easy to explore peaks and seasonal variation.\n\nAxis labels and a clear title are added using layout() to improve readability and presentation.\n\nThis visualization is ideal for analyzing time-based trends in weather or other sensor-style datasets.\n\n\n\n\n\n# Load the scales package for formatting percentages\nlibrary(scales)\n\n# Summarize flight on-time performance and flight counts by origin and carrier\nflights_ontime &lt;- flights |&gt;\n  filter(!is.na(dep_delay), !is.na(arr_delay)) |&gt;\n  group_by(origin, carrier) |&gt;\n  summarize(\n    ontime_dep = mean(dep_delay &lt;= 0, na.rm = TRUE),  # % of flights that left on time\n    ontime_arr = mean(arr_delay &lt;= 0, na.rm = TRUE),  # % of flights that arrived on time\n    n_flights = n(),\n    .groups = \"drop\"\n  ) |&gt;\n  inner_join(airlines, by = \"carrier\") |&gt;  # Add airline names\n  mutate(\n    tooltip = paste0(\n      \"Origin: \", origin,\n      \"&lt;br&gt;Carrier: \", name,\n      \"&lt;br&gt;On-Time Departures: \", percent(ontime_dep, accuracy = 1),\n      \"&lt;br&gt;On-Time Arrivals: \", percent(ontime_arr, accuracy = 1),\n      \"&lt;br&gt;Total Flights: \", n_flights\n    )\n  )\n\n\n# Create scatterplot comparing on-time departure and arrival performance\np &lt;- ggplot(flights_ontime, aes(\n  x = ontime_dep,\n  y = ontime_arr,\n  color = origin,\n  size = n_flights,\n  text = tooltip\n)) +\n  geom_point(alpha = 0.8) +\n  geom_abline(slope = 1, intercept = 0, linetype = \"dashed\", color = \"gray60\") +\n  scale_x_continuous(labels = percent_format(accuracy = 1)) +\n  scale_y_continuous(labels = percent_format(accuracy = 1)) +\n  labs(\n    title = \"On-Time Performance by Origin and Carrier\",\n    subtitle = \"Each point represents one (origin, carrier) combination\",\n    x = \"On-Time Departure Rate\",\n    y = \"On-Time Arrival Rate\",\n    size = \"Flight Volume\",\n    color = \"Origin Airport\"\n  ) +\n  theme_minimal()\n\n\n# Convert to interactive with tooltip\nggplotly(p, tooltip = \"text\")\n\n\n\n\n\n\nWe filter and summarize flight data to calculate the on-time departure and arrival rates by origin and carrier.\n\npercent() from the scales package formats these rates for display in tooltips.\n\nEach point in the scatterplot represents a unique origin–carrier pair, sized by number of flights and colored by airport.\n\nA 45° dashed line indicates equal performance for departures and arrivals, making deviations easy to spot.\n\nCustom tooltips include origin, carrier name, performance metrics, and total flights, enhancing user interaction.\n\nggplotly() makes the plot interactive, letting viewers hover to explore detailed airline punctuality.\n\n\n\n\n\n# Load weather source survey data and calculate percentages\ndata(\"weather_check\", package = \"fivethirtyeight\")\n\nweather_check |&gt;\n  filter(!is.na(weather_source)) |&gt;\n  count(weather_source, sort = TRUE) |&gt;\n  mutate(\n    pct = scales::percent(n / sum(n), accuracy = 0.1),  # Add percentage column\n    text = paste0(n, \" responses (\", pct, \")\")  # Custom hover text\n  ) |&gt;\n  plot_ly(\n    y = ~reorder(weather_source, n),  # Reorder by count\n    x = ~n,\n    type = \"bar\",\n    hovertext = ~text,\n    hoverinfo = \"text\"  # Use custom hover text\n  ) |&gt;\n  layout(\n    title = \"Most Common Weather Sources\",\n    xaxis = list(title = \"Responses\"),\n    yaxis = list(title = \"Weather Source\")\n  )\n\n\n\n\n\n\nWe filter out missing values and count how many respondents preferred each weather source.\n\nA new column pct calculates the percentage of responses per source, formatted with scales::percent().\n\nCustom hover text is created with paste0() to include source name, count, and percentage.\n\nplot_ly() generates an interactive horizontal bar chart, with bars ordered by response count.\n\nhoverinfo = \"text\" ensures only the custom tooltips are shown when hovering.\n\nThis visualization clearly highlights the most common weather sources while enabling detailed exploration.\n\n\n\n\n\n# Create a histogram of the 'energy' feature with custom styling and a range slider\nplot_ly(\n  data = spotify,\n  x = ~energy,\n  type = \"histogram\",\n  marker = list(\n    color = 'lightblue',             # Fill color of the bars\n    line = list(\n      color = 'black',               # Border color\n      width = 1.5                    # Border thickness\n    )\n  )\n) |&gt;\n  layout(\n    title = \"Histogram of Energy\",\n    xaxis = list(\n      title = \"Energy\",\n      rangeslider = list(visible = TRUE)  # Enable interactive range slider\n    ),\n    yaxis = list(title = \"Count\")\n  )\n\n\n\n\n\n\nWe use plot_ly() with type = \"histogram\" to visualize the distribution of the energy feature.\n\nCustom styling improves readability with light blue bars and bold black outlines.\n\nA range slider is added to the x-axis, allowing users to zoom into specific energy ranges interactively.\n\nlayout() defines axis labels and the chart title, making the plot informative and presentation-ready.\n\nThis interactive design is great for exploring distributions with variability or subtle structure.\n\n\n\n\n\n# Step 1: Summarize the monthly high temperatures by airport and year\nmonthly_highs &lt;- weather |&gt;\n  filter(!is.na(temp)) |&gt;\n  mutate(\n    month = month(time_hour, label = TRUE),  # Extract month as a labeled factor\n    year = year(time_hour)                   # Extract year\n  ) |&gt;\n  group_by(origin, year, month) |&gt;\n  summarize(\n    avg_high_temp = max(temp, na.rm = TRUE), # Use max temp as the monthly high\n    .groups = \"drop\"\n  ) |&gt;\n  mutate(\n    tooltip = paste0(\n      \"&lt;b&gt;Origin:&lt;/b&gt; \", origin,\n      \"&lt;br&gt;&lt;b&gt;Month:&lt;/b&gt; \", month,\n      \"&lt;br&gt;&lt;b&gt;Year:&lt;/b&gt; \", year,\n      \"&lt;br&gt;&lt;b&gt;High Temp:&lt;/b&gt; \", round(avg_high_temp, 1), \" °F\"\n    )\n  )\n\n\n# Step 2: Create the ggplot line chart with tooltip text\np &lt;- ggplot(monthly_highs, aes(\n  x = month, \n  y = avg_high_temp, \n  group = interaction(year, origin), \n  color = origin,\n  text = tooltip\n)) +\n  geom_line() +\n  geom_point() +\n  labs(\n    title = \"Monthly High Temperature by Airport\",\n    x = \"Month\",\n    y = \"High Temperature (°F)\",\n    color = \"Airport\"\n  ) +\n  theme_minimal()\n\n\n# Step 3: Convert to an interactive plot with custom tooltip\nggplotly(p, tooltip = \"text\")\n\n\n\n\n\n\nWe compute monthly high temperatures using max(temp) grouped by airport, year, and month for a clear seasonal summary.\n\nMonth labels are extracted with month(..., label = TRUE) for improved plot readability.\n\nA detailed tooltip is created with paste0(), combining airport, month, year, and temperature info.\n\ninteraction(year, origin) ensures each line represents a unique airport–year combination in the plot.\n\nggplotly(p, tooltip = \"text\") adds interactivity, enabling users to hover for insights and compare trends across time and location.\n\nThis is a great example of combining temporal, spatial, and statistical elements into one clear and engaging chart.\n\n\n\n\n\n(5.1) What is the primary advantage of using ggplotly() with an existing ggplot2 plot?\nA. It converts the plot into an interactive version with hover, zoom, and pan capabilities.\nB. It exports the plot directly to PowerPoint or PDF with built-in animations.\nC. It adds static labels to each point for easier print output.\nD. It improves rendering performance by simplifying the plot structure.\n\n(5.2) Why is specifying the tooltip = \"text\" argument useful in ggplotly()?\nA. It automatically maps data aesthetics like size or color into tooltips.\nB. It links tooltips to custom text content, allowing for more informative hover details.\nC. It ensures that labels are automatically translated into multiple languages.\nD. It prevents tooltips from showing variable names when using plot_ly().\n\n(5.3) In plot_ly(), which of the following enhances the readability of categorical plots like bar charts?\nA. Setting hoverinfo = \"none\" to reduce distractions\nB. Using facet_wrap() to group categories into subplots\nC. Adding annotations using geom_text()\nD. Sorting categories manually by reordering the y aesthetic\n\n(5.4) When creating an interactive histogram with a range slider in plotly, which element must be specified?\nA. range_slider = \"x\" in the histogram trace definition\nB. rangeSelector = TRUE in the histogram layout\nC. add_slider() inside geom_histogram()\nD. rangeslider = list(visible = TRUE) inside the xaxis layout\n\n(5.5) What is the benefit of transforming a dataset to long format before plotting multiple features interactively?\nA. It enables easier comparison of multiple variables across a common grouping, such as popular_or_not.\nB. It prevents the need to use the pivot_wider() function for grouped bar plots.\nC. It simplifies layout by removing the need for facetting or coloring.\nD. It allows faster computation since each column becomes a numeric vector.\n\n\n\n\n(5.1)\nCorrect Answer: A. It converts the plot into an interactive version with hover, zoom, and pan capabilities.\nExplanation: ggplotly() transforms static ggplot2 plots into interactive ones, making it easier to explore the data dynamically.\n\n(5.2)\nCorrect Answer: B. It links tooltips to custom text content, allowing for more informative hover details.\nExplanation: The text aesthetic allows you to fully customize hover text when passed into ggplotly() with tooltip = \"text\".\n\n(5.3)\nCorrect Answer: D. Sorting categories manually by reordering the y aesthetic\nExplanation: Reordering categorical axes improves the interpretability of bar charts by presenting data in a logical order.\n\n(5.4)\nCorrect Answer: D. rangeslider = list(visible = TRUE) inside the xaxis layout\nExplanation: This adds a zoomable slider on the x-axis of a histogram, enhancing interactivity.\n\n(5.5)\nCorrect Answer: A. It enables easier comparison of multiple variables across a common grouping, such as popular_or_not.\nExplanation: Long-format data is ideal for faceting and grouped comparisons in ggplot2 and plotly visualizations.\n\n\n\n\n\nPart 1: Load and Prepare the Data\n\n\n\n# Load the readr package for reading CSV files\nlibrary(readr)\n\n# Read in the raw data from a CSV file\npalmtrees_raw &lt;- read_csv(\"../palmtrees_funky.csv\")\n\n# Display the dataset to get a quick sense of the structure and contents\npalmtrees_raw\n\n# A tibble: 2,557 × 29\n   spec_name         acc_genus acc_species palm_tribe palm_subfamily climbing acaulescent erect stem_solitary stem_armed\n   &lt;chr&gt;             &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;          &lt;chr&gt;    &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;     \n 1 Acanthophoenix c… Acanthop… crinita     Areceae    Arecoideae     climbing acaulescent non-… non-solitary  non-armed \n 2 Acanthophoenix r… Acanthop… rousselii   Areceae    Arecoideae     climbing acaulescent non-… non-solitary  non-armed \n 3 Acanthophoenix r… Acanthop… rubra       Areceae    Arecoideae     climbing acaulescent non-… non-solitary  non-armed \n 4 Acoelorrhaphe wr… Acoelorr… wrightii    Trachycar… Coryphoideae   climbing acaulescent non-… solitary      armed     \n 5 Acrocomia aculea… Acrocomia aculeata    Cocoseae   Arecoideae     climbing acaulescent non-… non-solitary  non-armed \n 6 Acrocomia crispa  Acrocomia crispa      Cocoseae   Arecoideae     climbing acaulescent non-… non-solitary  non-armed \n 7 Acrocomia emensis Acrocomia emensis     Cocoseae   Arecoideae     climbing non-acaule… erect non-solitary  non-armed \n 8 Acrocomia glauce… Acrocomia glaucescens Cocoseae   Arecoideae     climbing acaulescent non-… non-solitary  non-armed \n 9 Acrocomia hassle… Acrocomia hassleri    Cocoseae   Arecoideae     climbing non-acaule… erect non-solitary  non-armed \n10 Acrocomia intume… Acrocomia intumescens Cocoseae   Arecoideae     climbing acaulescent non-… non-solitary  non-armed \n# ℹ 2,547 more rows\n# ℹ 19 more variables: leaves_armed &lt;chr&gt;, `Max Stem Height (m)` &lt;dbl&gt;, max_stem_dia_cm &lt;dbl&gt;,\n#   understorey_canopy &lt;chr&gt;, `# of Leaves` &lt;dbl&gt;, `max__blade__length_m!!!` &lt;dbl&gt;, max__rachis__length_m &lt;dbl&gt;,\n#   max__petiole_length_m &lt;dbl&gt;, average_fruit_length_cm &lt;dbl&gt;, min_fruit_length_cm &lt;dbl&gt;, max_fruit_length_cm &lt;dbl&gt;,\n#   `Average-Fruit Width (cm)` &lt;dbl&gt;, min_fruit_width_cm &lt;dbl&gt;, max_fruit_width_cm &lt;dbl&gt;, fruit_size_categorical &lt;chr&gt;,\n#   `¿Fruit Shape?` &lt;chr&gt;, `Fruit Color Description (raw)` &lt;chr&gt;, `main fruit COLORS!` &lt;chr&gt;, conspicuousness &lt;chr&gt;\n\n\n\nWe use read_csv() from the readr package to load the palmtrees_funky.csv dataset into R.\n\nPrinting the dataset gives an immediate overview of its structure, column names, and sample data, helping to identify any potential issues.\n\n\n\n\n\n# Load janitor for cleaning messy or inconsistent column names\nlibrary(janitor)\n\n# Clean column names: convert to lowercase, replace spaces and special characters with underscores\npalms &lt;- palmtrees_raw |&gt; clean_names()\n\n# View structure and types of cleaned data\nglimpse(palms)\n\nRows: 2,557\nColumns: 29\n$ spec_name                   &lt;chr&gt; \"Acanthophoenix crinita\", \"Acanthophoenix rousselii\", \"Acanthophoenix rubra\", \"Aco…\n$ acc_genus                   &lt;chr&gt; \"Acanthophoenix\", \"Acanthophoenix\", \"Acanthophoenix\", \"Acoelorrhaphe\", \"Acrocomia\"…\n$ acc_species                 &lt;chr&gt; \"crinita\", \"rousselii\", \"rubra\", \"wrightii\", \"aculeata\", \"crispa\", \"emensis\", \"gla…\n$ palm_tribe                  &lt;chr&gt; \"Areceae\", \"Areceae\", \"Areceae\", \"Trachycarpeae\", \"Cocoseae\", \"Cocoseae\", \"Cocosea…\n$ palm_subfamily              &lt;chr&gt; \"Arecoideae\", \"Arecoideae\", \"Arecoideae\", \"Coryphoideae\", \"Arecoideae\", \"Arecoidea…\n$ climbing                    &lt;chr&gt; \"climbing\", \"climbing\", \"climbing\", \"climbing\", \"climbing\", \"climbing\", \"climbing\"…\n$ acaulescent                 &lt;chr&gt; \"acaulescent\", \"acaulescent\", \"acaulescent\", \"acaulescent\", \"acaulescent\", \"acaule…\n$ erect                       &lt;chr&gt; \"non-erect\", \"non-erect\", \"non-erect\", \"non-erect\", \"non-erect\", \"non-erect\", \"ere…\n$ stem_solitary               &lt;chr&gt; \"non-solitary\", \"non-solitary\", \"non-solitary\", \"solitary\", \"non-solitary\", \"non-s…\n$ stem_armed                  &lt;chr&gt; \"non-armed\", \"non-armed\", \"non-armed\", \"armed\", \"non-armed\", \"non-armed\", \"non-arm…\n$ leaves_armed                &lt;chr&gt; \"non-armed\", \"non-armed\", \"non-armed\", \"non-armed\", \"non-armed\", \"non-armed\", \"non…\n$ max_stem_height_m           &lt;dbl&gt; 10.0, 25.0, 15.0, 9.1, 12.0, 18.0, 0.0, NA, 0.0, NA, 15.0, NA, 9.0, 9.0, 40.0, NA,…\n$ max_stem_dia_cm             &lt;dbl&gt; 20.0, 30.0, 18.0, 15.0, 50.0, 35.0, NA, NA, NA, NA, 30.0, NA, 9.0, 36.0, 30.0, NA,…\n$ understorey_canopy          &lt;chr&gt; \"canopy\", \"canopy\", \"canopy\", \"canopy\", \"canopy\", \"canopy\", \"understorey\", NA, \"un…\n$ number_of_leaves            &lt;dbl&gt; 15, NA, 20, 25, 30, 15, NA, NA, 6, NA, NA, NA, 7, 10, 13, NA, 17, NA, 10, 13, 8, 9…\n$ max_blade_length_m          &lt;dbl&gt; 2.30, 3.00, 3.10, 1.30, 3.50, 3.00, NA, NA, 0.90, NA, NA, NA, 2.35, 1.20, 4.76, NA…\n$ max_rachis_length_m         &lt;dbl&gt; NA, NA, 3.00, 0.70, 2.50, NA, NA, NA, 0.54, NA, NA, NA, 2.10, NA, 4.30, NA, 2.00, …\n$ max_petiole_length_m        &lt;dbl&gt; NA, NA, NA, 0.65, NA, 0.65, NA, NA, 0.51, NA, NA, NA, 1.30, 0.22, 0.51, NA, 0.22, …\n$ average_fruit_length_cm     &lt;dbl&gt; 0.65, 2.00, 1.00, 0.70, 4.25, 2.50, 2.00, NA, 2.25, 4.60, NA, 3.00, 2.60, 3.00, 10…\n$ min_fruit_length_cm         &lt;dbl&gt; 0.6, NA, NA, NA, 3.5, NA, NA, NA, 1.5, 3.8, NA, 2.5, 1.8, NA, NA, NA, NA, NA, NA, …\n$ max_fruit_length_cm         &lt;dbl&gt; 0.7, NA, NA, NA, 5.0, NA, NA, NA, 3.0, 5.4, NA, 3.5, 3.4, NA, NA, NA, NA, NA, NA, …\n$ average_fruit_width_cm      &lt;dbl&gt; 0.50, 0.80, 0.70, 0.70, 4.60, 1.80, 2.00, NA, 2.25, 4.60, NA, 3.00, 1.10, 1.30, 5.…\n$ min_fruit_width_cm          &lt;dbl&gt; NA, NA, NA, 0.5, 3.8, NA, NA, NA, 1.5, 3.8, NA, 2.5, 0.8, NA, 5.0, NA, NA, NA, NA,…\n$ max_fruit_width_cm          &lt;dbl&gt; NA, NA, NA, 0.9, 5.4, NA, NA, NA, 3.0, 5.4, NA, 3.5, 1.4, NA, 6.0, NA, NA, NA, NA,…\n$ fruit_size_categorical      &lt;chr&gt; \"small\", \"small\", \"small\", \"small\", \"large\", \"small\", \"small\", NA, \"small\", \"large…\n$ fruit_shape                 &lt;chr&gt; NA, \"ovoid\", \"ovoid\", \"ovoid\", \"ovoid\", \"globose\", NA, NA, NA, NA, \"ovoid\", NA, \"g…\n$ fruit_color_description_raw &lt;chr&gt; \"black\", \"black\", \"black\", \"orange-brown; becomming black\", \"yellowish green\", \"ye…\n$ main_fruit_colors           &lt;chr&gt; \"black\", \"black\", \"black\", \"brown; black\", \"green\", \"yellow; orange\", NA, NA, \"bro…\n$ conspicuousness             &lt;chr&gt; \"cryptic\", \"cryptic\", \"cryptic\", \"cryptic\", \"cryptic\", \"conspicuous\", NA, NA, \"cry…\n\n\n\njanitor::clean_names() standardizes column names by converting them to lowercase and replacing spaces/special characters with underscores.\n\nglimpse() helps confirm the cleaning worked and shows the structure of the cleaned dataset, including column types.\n\nThis cleanup step improves consistency and reduces potential errors when referencing columns in code.\n\n\n\n\n\n# Summarize how many missing values are in each column\npalms |&gt; \n  summarize(across(everything(), ~ sum(is.na(.)))) |&gt;\n  pivot_longer(cols = everything(), names_to = \"column\", values_to = \"n_missing\") |&gt;\n  arrange(desc(n_missing))\n\n# A tibble: 29 × 2\n   column               n_missing\n   &lt;chr&gt;                    &lt;int&gt;\n 1 min_fruit_length_cm       1651\n 2 max_fruit_length_cm       1641\n 3 min_fruit_width_cm        1563\n 4 max_fruit_width_cm        1555\n 5 max_petiole_length_m      1347\n 6 number_of_leaves          1251\n 7 max_rachis_length_m       1026\n 8 fruit_shape                765\n 9 main_fruit_colors          758\n10 conspicuousness            758\n# ℹ 19 more rows\n\n\n\nWe use across() to count missing values (NAs) in each column, providing an overview of data completeness.\n\npivot_longer() reshapes the result into a tidy format for easier interpretation and analysis.\n\nSorting by the number of missing values helps prioritize columns that may require cleaning or imputation.\n\n\nPart 2: Understand Variable Types and Distributions\n\n\n\n\n# Count the number of unique values in each selected categorical column\npalms |&gt; \n  select(climbing, erect, stem_armed, fruit_size_categorical, \n         fruit_shape, conspicuousness) |&gt;\n  map_df(~ tibble(n_unique = n_distinct(.x, na.rm = TRUE)), .id = \"variable\")\n\n# A tibble: 6 × 2\n  variable               n_unique\n  &lt;chr&gt;                     &lt;int&gt;\n1 climbing                      3\n2 erect                         3\n3 stem_armed                    2\n4 fruit_size_categorical        2\n5 fruit_shape                   7\n6 conspicuousness               2\n\n\n\n# Use moderndive's tidy_summary() for a more descriptive summary of the same traits\npalms |&gt; \n  select(climbing, erect, stem_armed, fruit_size_categorical, \n         fruit_shape, conspicuousness) |&gt;\n  tidy_summary()\n\n# A tibble: 23 × 11\n   group            n column                 type        min    Q1  mean median    Q3   max    sd\n   &lt;chr&gt;        &lt;int&gt; &lt;chr&gt;                  &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 both            16 climbing               character    NA    NA    NA     NA    NA    NA    NA\n 2 climbing      2011 climbing               character    NA    NA    NA     NA    NA    NA    NA\n 3 non-climbing   530 climbing               character    NA    NA    NA     NA    NA    NA    NA\n 4 both            48 erect                  character    NA    NA    NA     NA    NA    NA    NA\n 5 erect          738 erect                  character    NA    NA    NA     NA    NA    NA    NA\n 6 non-erect     1771 erect                  character    NA    NA    NA     NA    NA    NA    NA\n 7 armed         2297 stem_armed             character    NA    NA    NA     NA    NA    NA    NA\n 8 non-armed      205 stem_armed             character    NA    NA    NA     NA    NA    NA    NA\n 9 &lt;NA&gt;            55 stem_armed             character    NA    NA    NA     NA    NA    NA    NA\n10 large          251 fruit_size_categorical character    NA    NA    NA     NA    NA    NA    NA\n# ℹ 13 more rows\n\n\n\nWe use map_df() and n_distinct() to count unique values in selected categorical columns, giving an overview of their diversity.\n\ntidy_summary() from moderndive provides a more detailed summary, including counts, proportions, and missing values.\n\nThese steps help identify well-defined traits and highlight categorical variables that may need cleaning or recoding.\n\n\n\n\n\n# Visualize how species are distributed across fruit size categories\npalms |&gt; ggplot(aes(x = fruit_size_categorical)) +\n  geom_bar(fill = \"forestgreen\") +\n  labs(title = \"Distribution of Palm Fruit Sizes\")\n\n\n\n\n\nWe use geom_bar() to create a bar chart that shows the distribution of palm species across different fruit size categories.\nThis chart helps identify whether some fruit size categories are more common than others, offering a quick assessment of the data’s distribution.\n\n\n\n\n\n# Create a new column that summarizes whether the plant has any armament (on stem or leaves)\npalms &lt;- palms |&gt;\n  mutate(is_armed = case_when(\n    stem_armed == \"armed\" | leaves_armed == \"armed\" ~ \"Armed\",\n    stem_armed == \"non-armed\" & leaves_armed == \"non-armed\" ~ \"Not Armed\",\n    TRUE ~ \"Unknown\"\n  ))\n\n# Count the number of species in each armament category\npalms |&gt; count(is_armed)\n\n# A tibble: 3 × 2\n  is_armed      n\n  &lt;chr&gt;     &lt;int&gt;\n1 Armed      2313\n2 Not Armed   189\n3 Unknown      55\n\n\n\nWe create a new column, is_armed, that combines stem_armed and leaves_armed into a unified classification of “Armed” or “Not Armed”.\n\nThe count of species in each armament category is displayed using count(is_armed), giving us insight into the distribution of plant armament.\n\n\n\n\n\n# Visualize how stem height varies across different fruit size categories\npalms |&gt; \n  filter(!is.na(max_stem_height_m)) |&gt;\n  ggplot(aes(x = fruit_size_categorical, y = max_stem_height_m)) +\n  geom_boxplot(fill = \"tan\") +\n  labs(title = \"Stem Height by Fruit Size\")\n\n\n\n\n\nWe use a boxplot to visualize how stem height varies across different fruit size categories.\n\nfilter() removes missing height values, and geom_boxplot() displays the distribution of stem heights for each fruit size group.\n\n\n\n\n\n# Count how many species belong to each palm subfamily and visualize with a horizontal bar chart\npalms |&gt; \n  count(palm_subfamily, sort = TRUE) |&gt;\n  ggplot(aes(x = reorder(palm_subfamily, n), y = n)) +\n  geom_col(fill = \"lightblue\") +\n  coord_flip() +\n  labs(\n    title = \"Distribution of Palm Subfamilies\",\n    x = \"Palm Subfamily\",\n    y = \"Number of Species\"\n  )\n\n\n\n\n\nWe use a horizontal bar chart to visualize the distribution of palm species across subfamilies, with bars ordered by frequency.\n\ncoord_flip() rotates the chart for better readability, making it easier to compare the number of species in each subfamily.\n\n\n\n\n\n# Count the number of species in each palm subfamily by fruit conspicuousness category\npalms |&gt; \n  filter(!is.na(conspicuousness)) |&gt; \n  count(palm_subfamily, conspicuousness) |&gt; \n  ggplot(aes(x = palm_subfamily, y = n, fill = conspicuousness)) +\n  geom_col(position = \"dodge\") +\n  coord_flip() +\n  labs(\n    title = \"Distribution of Conspicuous vs Cryptic Fruits by Subfamily\",\n    x = \"Palm Subfamily\",\n    y = \"Number of Species\"\n  )\n\n\n\n\n\nWe use a side-by-side bar chart to compare fruit conspicuousness (conspicuous vs. cryptic) across palm subfamilies.\n\nposition = \"dodge\" places the bars next to each other, making it easy to compare the number of species in each category.\n\n\n\n\n\n# Plot a histogram to explore the distribution of stem heights\npalms |&gt; \n  ggplot(aes(x = max_stem_height_m)) +\n  geom_histogram(bins = 30, fill = \"turquoise\", color = \"black\") +\n  labs(title = \"Distribution of Stem Heights\")\n\nWarning: Removed 446 rows containing non-finite outside the scale range (`stat_bin()`).\n\n\n\n\n\n\nThe histogram visualizes the distribution of stem heights across palm species, helping to identify common height ranges and outliers.\n\nThe color choice (turquoise for fill and black for borders) enhances the chart’s clarity and visual appeal.\n\n\n\n\n\n# Select numeric columns and compute mean and standard deviation for each\nnum_cols &lt;- palms |&gt; select(where(is.numeric))\nmap_df(num_cols, \n       ~ tibble(\n         mean = mean(.x, na.rm = TRUE), \n         sd = sd(.x, na.rm = TRUE)\n       ), .id = \"variable\")\n\n# A tibble: 12 × 3\n   variable                  mean     sd\n   &lt;chr&gt;                    &lt;dbl&gt;  &lt;dbl&gt;\n 1 max_stem_height_m       10.9   13.0  \n 2 max_stem_dia_cm         12.4   17.1  \n 3 number_of_leaves        14.4    9.85 \n 4 max_blade_length_m       2.37   2.25 \n 5 max_rachis_length_m      1.97   1.80 \n 6 max_petiole_length_m     0.852  0.842\n 7 average_fruit_length_cm  2.20   2.24 \n 8 min_fruit_length_cm      2.18   2.30 \n 9 max_fruit_length_cm      3.10   3.32 \n10 average_fruit_width_cm   1.59   1.55 \n11 min_fruit_width_cm       1.48   1.36 \n12 max_fruit_width_cm       2.13   2.09 \n\n\n\n# Compare with tidy_summary() for a full tidy-style summary\npalms |&gt; \n  select(where(is.numeric)) |&gt;\n  tidy_summary(na.rm = TRUE) |&gt; \n  select(column, mean, sd)\n\n# A tibble: 12 × 3\n   column                    mean     sd\n   &lt;chr&gt;                    &lt;dbl&gt;  &lt;dbl&gt;\n 1 max_stem_height_m       10.9   13.0  \n 2 max_stem_dia_cm         12.4   17.1  \n 3 number_of_leaves        14.4    9.85 \n 4 max_blade_length_m       2.37   2.25 \n 5 max_rachis_length_m      1.97   1.80 \n 6 max_petiole_length_m     0.852  0.842\n 7 average_fruit_length_cm  2.20   2.24 \n 8 min_fruit_length_cm      2.18   2.30 \n 9 max_fruit_length_cm      3.10   3.32 \n10 average_fruit_width_cm   1.59   1.55 \n11 min_fruit_width_cm       1.48   1.36 \n12 max_fruit_width_cm       2.13   2.09 \n\n\n\nWe use map_df() to compute the mean and standard deviation for each numeric column, creating a tidy summary of the data.\n\ntidy_summary() from the moderndive package provides a more comprehensive summary, including missing values, and is useful for quick reporting.\n\nBoth methods help identify variables with high variability or missing data, preparing the dataset for further analysis or modeling.\n\n\n\n\n\n# Count how many species use each raw fruit color description\npalms |&gt; \n  filter(!is.na(fruit_color_description_raw)) |&gt; \n  count(fruit_color_description_raw, sort = TRUE)\n\n# A tibble: 769 × 2\n   fruit_color_description_raw     n\n   &lt;chr&gt;                       &lt;int&gt;\n 1 black                         160\n 2 red                           147\n 3 brown                          72\n 4 purple-black                   67\n 5 orange                         51\n 6 yellowish                      40\n 7 orange-red                     36\n 8 yellow                         33\n 9 green                          31\n10 brown to black                 29\n# ℹ 759 more rows\n\n\n\nWe filter out missing values and count how many times each raw fruit color description appears in the dataset.\n\nSorting the results helps highlight the most common color descriptions and identifies patterns or inconsistencies.\n\n\n\n\n\n# Count the number of species associated with each unique fruit shape\npalms |&gt; \n  count(fruit_shape, sort = TRUE) |&gt;\n  filter(!is.na(fruit_shape))\n\n# A tibble: 7 × 2\n  fruit_shape     n\n  &lt;chr&gt;       &lt;int&gt;\n1 ovoid         813\n2 globose       800\n3 elongate      110\n4 ellipsoid      53\n5 pyramidal      12\n6 fusiform        3\n7 rounded         1\n\n\n\nWe count the number of species associated with each unique fruit shape, sorting the results to see the most common shapes.\n\nFiltering out NA values ensures we focus on valid entries, providing a clearer view of the fruit shape distribution.\n\n\nPart 3: Explore Relationships Between Traits\n\n\n\n\n# Check how values are distributed across two traits: stem_armed and conspicuousness\npalms |&gt; count(stem_armed)\n\n# A tibble: 3 × 2\n  stem_armed     n\n  &lt;chr&gt;      &lt;int&gt;\n1 armed       2297\n2 non-armed    205\n3 &lt;NA&gt;          55\n\npalms |&gt; count(conspicuousness)\n\n# A tibble: 3 × 2\n  conspicuousness     n\n  &lt;chr&gt;           &lt;int&gt;\n1 conspicuous       739\n2 cryptic          1060\n3 &lt;NA&gt;              758\n\n\n\n# Identify species that are non-armed and have missing conspicuousness data\nrare_traits &lt;- palms |&gt; \n  filter(stem_armed == \"non-armed\", \n         is.na(conspicuousness)) |&gt;\n  select(spec_name, palm_subfamily, palm_tribe, climbing, stem_armed, \n         conspicuousness)\nrare_traits\n\n# A tibble: 32 × 6\n   spec_name                 palm_subfamily palm_tribe climbing stem_armed conspicuousness\n   &lt;chr&gt;                     &lt;chr&gt;          &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;      &lt;chr&gt;          \n 1 Acrocomia emensis         Arecoideae     Cocoseae   climbing non-armed  &lt;NA&gt;           \n 2 Acrocomia glaucescens     Arecoideae     Cocoseae   climbing non-armed  &lt;NA&gt;           \n 3 Aiphanes graminifolia     Arecoideae     Cocoseae   climbing non-armed  &lt;NA&gt;           \n 4 Aiphanes leiostachys      Arecoideae     Cocoseae   climbing non-armed  &lt;NA&gt;           \n 5 Aiphanes linearis         Arecoideae     Cocoseae   climbing non-armed  &lt;NA&gt;           \n 6 Astrocaryum carnosum      Arecoideae     Cocoseae   climbing non-armed  &lt;NA&gt;           \n 7 Astrocaryum mexicanum     Arecoideae     Cocoseae   climbing non-armed  &lt;NA&gt;           \n 8 Astrocaryum minus         Arecoideae     Cocoseae   climbing non-armed  &lt;NA&gt;           \n 9 Astrocaryum perangustatum Arecoideae     Cocoseae   climbing non-armed  &lt;NA&gt;           \n10 Astrocaryum triandrum     Arecoideae     Cocoseae   climbing non-armed  &lt;NA&gt;           \n# ℹ 22 more rows\n\n\n\n# Count how many species have this rare trait combination\nnrow(rare_traits)\n\n[1] 32\n\n\n\n# Summarize how these rare combinations are distributed by palm subfamily\nrare_traits |&gt; count(palm_subfamily, sort = TRUE)\n\n# A tibble: 2 × 2\n  palm_subfamily     n\n  &lt;chr&gt;          &lt;int&gt;\n1 Calamoideae       20\n2 Arecoideae        12\n\n\n\nWe first check the distribution of values in stem_armed and conspicuousness to understand their patterns.\n\nWe then filter for species that are “non-armed” but have missing conspicuousness data, highlighting rare trait combinations.\n\nFinally, we count how many species match this rare combination and summarize its distribution across palm subfamilies, revealing potential data gaps or unusual evolutionary traits.\n\n\n\n\n\n# Compare stem diameter distributions between different growth forms (erect vs. not)\npalms |&gt; filter(!is.na(max_stem_dia_cm)) |&gt;\n  ggplot(aes(x = erect, y = max_stem_dia_cm)) +\n  geom_boxplot() +\n  labs(title = \"Stem Diameter by Erect Growth Form\")\n\n\n\n\n\nWe use a boxplot to compare stem diameter distributions between “erect” and “non-erect” growth forms.\n\nThe plot shows medians and variability, helping identify whether growth form correlates with stem thickness.\n\nThis visualization is useful for understanding structural adaptations related to plant morphology.\n\n\n\n\n\n# Create an interactive dodged bar chart of fruit shapes by growth form\npalms |&gt;\n  filter(!is.na(fruit_shape), !is.na(erect)) |&gt;\n  count(fruit_shape, erect, sort = TRUE) |&gt;\n  mutate(\n    tooltip = paste0(\n      \"&lt;b&gt;Fruit Shape:&lt;/b&gt; \", fruit_shape,\n      \"&lt;br&gt;&lt;b&gt;Growth Form:&lt;/b&gt; \", erect,\n      \"&lt;br&gt;&lt;b&gt;Species Count:&lt;/b&gt; \", n\n    )\n  ) |&gt;\n  plot_ly(\n    x = ~n,\n    y = ~reorder(fruit_shape, n),\n    color = ~erect,\n    type = \"bar\",\n    orientation = \"h\",\n    text = ~tooltip,\n    hoverinfo = \"text\"\n  ) |&gt;\n  layout(\n    title = \"Distribution of Fruit Shapes by Growth Form\",\n    xaxis = list(title = \"Number of Species\"),\n    yaxis = list(title = \"Fruit Shape\"),\n    barmode = \"group\"  # Dodged bars for comparison\n  )\n\n\n\n\n\n\nWe create an interactive dodged bar chart to compare fruit shapes by growth form, using plot_ly() for interactivity.\n\nBars are grouped side-by-side (barmode = \"group\") to compare the number of species for each fruit shape and growth form.\n\nCustom tooltips display additional information, making the chart more informative when hovering over the bars.\n\n\n\n\n\n# Filter to include only complete cases for the relevant variables\npalms_filtered &lt;- palms |&gt;\n  filter(\n    !is.na(average_fruit_length_cm),\n    !is.na(average_fruit_width_cm),\n    !is.na(palm_subfamily)\n  )\n\n# Create a faceted scatterplot with interactive tooltips\np &lt;- ggplot(palms_filtered, aes(\n  x = average_fruit_length_cm,\n  y = average_fruit_width_cm,\n  text = paste(\n    \"&lt;b&gt;Species:&lt;/b&gt;\", spec_name,\n    \"&lt;br&gt;&lt;b&gt;Length:&lt;/b&gt;\", round(average_fruit_length_cm, 2), \"cm\",\n    \"&lt;br&gt;&lt;b&gt;Width:&lt;/b&gt;\", round(average_fruit_width_cm, 2), \"cm\",\n    \"&lt;br&gt;&lt;b&gt;Subfamily:&lt;/b&gt;\", palm_subfamily\n  )\n)) +\n  geom_point(alpha = 0.4, color = \"darkgreen\", size = 2) +\n  facet_wrap(~ palm_subfamily) +\n  labs(\n    title = \"Fruit Length vs. Width by Palm Subfamily\",\n    x = \"Average Fruit Length (cm)\",\n    y = \"Average Fruit Width (cm)\"\n  ) +\n  theme_minimal()\n\n# Convert to interactive\nggplotly(p, tooltip = \"text\")\n\n\n\n\n\n\nWe create a faceted scatterplot to compare fruit length vs. width, with separate plots for each palm subfamily.\n\nTooltips display detailed species-level information, including fruit dimensions and subfamily.\n\nFaceting allows for easy comparison of how fruit dimensions vary across subfamilies, while interactivity enhances data exploration.\n\n\n\n\n\n# Filter for complete data in height, fruit size, and armament\npalms_box &lt;- palms |&gt;\n  filter(\n    !is.na(max_stem_height_m),\n    !is.na(fruit_size_categorical),\n    !is.na(is_armed)\n  )\n\n# Create boxplots grouped by fruit size and dodged by armament status\np &lt;- ggplot(palms_box, aes(\n  x = fruit_size_categorical,\n  y = max_stem_height_m,\n  fill = is_armed\n)) +\n  geom_boxplot(\n    outlier.alpha = 0.3,\n    width = 0.6\n  ) +\n  labs(\n    title = \"Stem Height by Fruit Size and Armament\",\n    x = \"Fruit Size Category\",\n    y = \"Max Stem Height (m)\",\n    fill = \"Is Armed?\"\n  ) +\n  theme_minimal()\n\n# View static version — interactive version misaligns dodges\np\n\n\n\n\n\nThe boxplot compares stem height across different fruit size categories, grouped by whether the plant is armed or not.\n\ngeom_boxplot() visualizes distributions with outliers, while fill = is_armed colors the boxes by armament status.\n\nThe static version provides a clear view, but interactive versions may misalign the dodged bars.\n\n\n\n\n\n# Interactive boxplot showing blade length across fruit conspicuousness groups\npalms |&gt;\n  filter(!is.na(max_blade_length_m), !is.na(conspicuousness)) |&gt;\n  plot_ly(\n    x = ~conspicuousness,\n    y = ~max_blade_length_m,\n    type = \"box\",\n    color = ~conspicuousness,\n    boxpoints = \"outliers\",\n    text = ~paste(\"&lt;b&gt;Species:&lt;/b&gt;\", spec_name),\n    hoverinfo = \"text\"\n  ) |&gt;\n  layout(\n    title = \"Blade Length by Fruit Conspicuousness\",\n    xaxis = list(title = \"Fruit Conspicuousness\"),\n    yaxis = list(title = \"Max Blade Length (m)\")\n  )\n\nWarning in RColorBrewer::brewer.pal(N, \"Set2\"): minimal value for n is 3, returning requested palette with 3 different levels\nWarning in RColorBrewer::brewer.pal(N, \"Set2\"): minimal value for n is 3, returning requested palette with 3 different levels\n\n\n\n\n\n\n\nThe interactive boxplot compares blade length across different levels of fruit conspicuousness, with outliers highlighted.\n\nSpecies names are displayed in tooltips, allowing users to explore individual data points.\n\nThis visualization helps identify variations and outliers in leaf length related to fruit visibility traits.\n\n\n\n\n\n# Horizontal bar chart of the 10 most frequent fruit color labels\npalms |&gt;\n  filter(!is.na(main_fruit_colors)) |&gt;\n  count(main_fruit_colors, sort = TRUE) |&gt;\n  slice_max(n, n = 10) |&gt;\n  mutate(label = paste0(n, \" species\")) |&gt;\n  plot_ly(\n    y = ~reorder(main_fruit_colors, n),\n    x = ~n,\n    type = \"bar\",\n    hoverinfo = ~label,\n    orientation = \"h\",\n    marker = list(color = \"purple\")\n  ) |&gt;\n  layout(\n    title = \"Top 10 Most Common Fruit Colors\",\n    xaxis = list(title = \"Number of Species\"),\n    yaxis = list(title = \"Fruit Color\")\n  )\n\n\n\n\n\n\nThe interactive bar chart displays the top 10 most common fruit colors, with bars ordered by frequency.\n\nHovering over the bars shows a custom tooltip with the number of species for each fruit color.\n\nThis visualization helps identify the most prevalent fruit colors, which may offer insights into visual patterns or ecological traits.\n\n\nWell done! Best wishes on your continued learning journey with R and data science. Remember, the key to honing these skills is practice and exploration. Don’t hesitate to revisit these concepts and apply them to your own projects. Happy coding!"
  },
  {
    "objectID": "answers/day2_walkthrough_answers.html#session-4-functional-programming",
    "href": "answers/day2_walkthrough_answers.html#session-4-functional-programming",
    "title": "Exploratory Data Analysis in R with the tidyverse",
    "section": "",
    "text": "# Load the required packages and data\nlibrary(purrr)\nlibrary(moderndive)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(plotly)\nlibrary(azflights24)\nlibrary(lubridate)\n\nspotify &lt;- spotify_by_genre |&gt;\n  dplyr::distinct(track_name, .keep_all = TRUE) \n\nThis gets us back to where we were before when we finished up the Day 1 material.\n\n\n\n\n# Summarize multiple numeric audio features by calculating their mean and standard deviation\n# Use across() to apply functions over selected columns\n# Reshape the output so each row represents a feature-statistic combination\n\nspotify |&gt;\n  summarize(across(\n    c(popularity, danceability, energy, tempo),\n    list(mean = ~mean(.x, na.rm = TRUE),\n         sd = ~sd(.x, na.rm = TRUE))\n  )) |&gt;\n  pivot_longer(everything(), names_to = c(\"feature\", \"stat\"), names_sep = \"_\")\n\n# A tibble: 8 × 3\n  feature      stat    value\n  &lt;chr&gt;        &lt;chr&gt;   &lt;dbl&gt;\n1 popularity   mean   41.7  \n2 popularity   sd     26.3  \n3 danceability mean    0.593\n4 danceability sd      0.153\n5 energy       mean    0.731\n6 energy       sd      0.176\n7 tempo        mean  125.   \n8 tempo        sd     27.6  \n\n\n\nWe use across() to apply mean() and sd() to multiple numeric columns at once, avoiding repetitive code.\n\nThe selected features—popularity, danceability, energy, and tempo—are each summarized with both statistics.\n\nThe list() inside across() allows us to define multiple summary functions at once.\n\npivot_longer() reshapes the wide summary output into long format, with separate feature and stat columns.\n\nThis tidy format is ideal for further analysis or plotting, especially when comparing metrics across features.\n\n\n\n\n\n# Define a custom function to extract featured artist names from track titles\n# Looks for phrases like \"(feat. XYZ)\" or \"(with XYZ)\" using regex\nextract_feature &lt;- function(name) {\n  str_extract(name, \"(?i)(?&lt;=\\\\()(with|feat\\\\.)[^)]*(?=\\\\))\")\n}\n\n\n# Apply the extraction function to each track name using map_chr\n# Create a new column for the extracted featured artist string\n# Filter to show only tracks that actually contain a featured artist\n# Then display a random sample of 30 such tracks\nspotify |&gt;\n  mutate(feature_raw = map_chr(track_name, extract_feature)) |&gt;\n  select(track_name, feature_raw, track_genre) |&gt;\n  filter(!is.na(feature_raw)) |&gt; \n  slice_sample(n = 30)\n\n# A tibble: 30 × 3\n   track_name                                                          feature_raw              track_genre\n   &lt;chr&gt;                                                               &lt;chr&gt;                    &lt;chr&gt;      \n 1 Slow It Down (feat. L8NCY)                                          feat. L8NCY              dubstep    \n 2 Returning To You (feat. Alison May)                                 feat. Alison May         dubstep    \n 3 Space Cadet (feat. Gunna)                                           feat. Gunna              hip-hop    \n 4 From The Ashes (with Skylar Grey) - Paul van Dyk Remix              with Skylar Grey         dubstep    \n 5 Hurts Sometimes (with Jonathan Mendelsohn)                          with Jonathan Mendelsohn dubstep    \n 6 Can't Love Myself (feat. Mishaal & LPW)                             feat. Mishaal & LPW      deep-house \n 7 Sad Songs (feat. L Devine)                                          feat. L Devine           deep-house \n 8 California Dreamin' (feat. High Jinx) (LP Giobbi Remix)             feat. High Jinx          deep-house \n 9 Stay Hollow (with mossy.)                                           with mossy.              dubstep    \n10 Good Things Fall Apart (with Jon Bellion) [Tiësto's Big Room Remix] with Jon Bellion         dubstep    \n# ℹ 20 more rows\n\n\n\nWe define a custom function using str_extract() to pull featured artist names from track titles that include phrases like (feat. ...) or (with ...).\n\nThe regex uses lookarounds to extract the text inside parentheses without keeping the parentheses themselves.\n\nWe apply this function to every track using map_chr() from the purrr package, creating a new column feature_raw.\n\nFiltering for non-NA values isolates only those tracks that contain featured artists.\n\nSampling 30 rows gives us a quick view of how featured artists appear in the data.\n\n\n\n\n\n# Split the spotify dataset into a list of data frames, one per genre\ngenre_groups &lt;- spotify |&gt;\n  group_split(track_genre)\n\n# Assign names to each list element based on the genre\nnames(genre_groups) &lt;- spotify |&gt;\n  distinct(track_genre) |&gt;\n  pull()\n\n\n# Apply a trimmed mean function to the popularity column of each genre\n# map_dbl() returns a named numeric vector of trimmed means\nmap_dbl(genre_groups, ~ mean(.x$popularity, trim = 0.1, na.rm = TRUE))\n\n   country deep-house    dubstep    hip-hop      metal       rock \n  21.12998   49.38589   44.36298   52.18357   50.24155   26.52342 \n\n\n\nWe use group_split() to divide the dataset into a list of smaller data frames—one for each genre.\n\nnames() assigns the genre names to each list element, making the output easier to read and interpret.\n\nmap_dbl() applies a trimmed mean function to the popularity column of each genre-specific data frame.\n\nUsing trim = 0.1 excludes the top and bottom 10% of values, reducing the influence of outliers.\n\nThis workflow is useful for applying custom or complex operations across groups that aren’t easily handled with summarize().\n\n\n\n\n\n# Identify the top 3 most common genres by number of tracks\n# Extract the genre names into a character vector\ntop_genres &lt;- spotify |&gt;\n  count(track_genre, sort = TRUE) |&gt;\n  slice_head(n = 3) |&gt;\n  pull(track_genre)\n\ntop_genres\n\n[1] \"deep-house\" \"dubstep\"    \"metal\"     \n\n\n\n# For each of the top 3 genres, create a histogram of popularity\n# Save each plot as a PNG file using ggsave()\nwalk(top_genres, function(genre_name) {\n  p &lt;- spotify |&gt;\n    filter(track_genre == genre_name) |&gt;\n    ggplot(aes(x = popularity)) +\n    geom_histogram(binwidth = 5, fill = \"forestgreen\", color = \"black\") +\n    labs(title = paste(\"Popularity for\", genre_name), \n         x = \"Popularity\", y = \"Count\")\n  \n  ggsave(filename = paste0(\"popularity_\", genre_name, \".png\"), plot = p, \n         width = 6, height = 4)\n})\n\n\nWe identify the top 3 genres in the dataset by counting the number of tracks per genre and extracting their names.\n\nwalk() is used to iterate over each top genre and execute a plotting-and-saving routine without returning values.\n\nFor each genre, we filter the data and generate a histogram of track popularity.\n\nggsave() saves each plot as a PNG file with a genre-specific filename.\n\nThis approach is ideal for automating repetitive visualizations or exports for different subgroups in a dataset.\n\n\n\n\n\n# Define a function that returns TRUE if a title is all uppercase\n# It allows spaces, digits, and punctuation but must contain at least one A–Z letter\nis_all_caps &lt;- function(x) {\n  str_detect(x, \"^[A-Z\\\\s0-9[:punct:]]+$\") & str_detect(x, \"[A-Z]\")\n}\n\n\n# Apply the function to each track title to flag shouting titles\n# Add a new logical column and sort the data so TRUE values appear first\n(\n  shout_labeled &lt;- spotify |&gt;\n    mutate(is_shouting = map_lgl(track_name, is_all_caps), .after = track_name) |&gt;\n    arrange(desc(is_shouting))\n)\n\n# A tibble: 4,311 × 22\n   track_id artists album_name track_name is_shouting popularity duration_ms explicit danceability energy   key loudness\n   &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;      &lt;lgl&gt;            &lt;dbl&gt;       &lt;dbl&gt; &lt;lgl&gt;           &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n 1 1gH8Qig… Tim Mc… Sad Count… 7500 OBO   TRUE                 3      221400 FALSE           0.528  0.718     7    -6.95\n 2 1x41485… Koe We… Harold Sa… L.T.W.Y.H… TRUE                48      209849 FALSE           0.439  0.528     9    -7.12\n 3 7yBcGJF… Tyler … Suffer in… C.O.U.N.T… TRUE                45      201026 FALSE           0.459  0.89      9    -4.45\n 4 0BCy325… Florid… Dig Your … H.O.L.Y.   TRUE                71      194186 FALSE           0.523  0.666     7    -4.08\n 5 2S8UMuL… Niko M… GOOD TIME  GOOD TIME  TRUE                70      214720 FALSE           0.802  0.59      5    -7.19\n 6 3rLEBpW… Kelsea… SUBJECT T… MUSCLE ME… TRUE                66      211843 FALSE           0.596  0.786     8    -4.78\n 7 3bWAqKD… Robin … OK         OK         TRUE                63      189306 FALSE           0.653  0.81      7    -6.03\n 8 6JjSoJ2… Chris … MAMI       MAMI       TRUE                66      247896 TRUE            0.758  0.944     3    -4.90\n 9 0FMLbet… James … B2B        B2B        TRUE                54      160000 FALSE           0.799  0.956     0    -6.41\n10 3VQWkf0… ESSEL   BUBBLEGUM  BUBBLEGUM  TRUE                57      148538 FALSE           0.838  0.803     6    -5.58\n# ℹ 4,301 more rows\n# ℹ 10 more variables: mode &lt;dbl&gt;, speechiness &lt;dbl&gt;, acousticness &lt;dbl&gt;, instrumentalness &lt;dbl&gt;, liveness &lt;dbl&gt;,\n#   valence &lt;dbl&gt;, tempo &lt;dbl&gt;, time_signature &lt;dbl&gt;, track_genre &lt;chr&gt;, popular_or_not &lt;chr&gt;\n\n\n\n# Count how many tracks are considered \"shouting\" titles vs not\nshout_labeled |&gt;\n  count(is_shouting)\n\n# A tibble: 2 × 2\n  is_shouting     n\n  &lt;lgl&gt;       &lt;int&gt;\n1 FALSE        4211\n2 TRUE          100\n\n\n\nWe define a custom function is_all_caps() that detects if a string is written entirely in uppercase letters, allowing spaces, numbers, and punctuation.\n\nThe function also ensures that at least one A–Z letter is present, avoiding false positives like strings made only of symbols.\n\nmap_lgl() applies the function to each track name, producing a new logical column is_shouting.\n\nWe insert the new column right after track_name using .after, keeping the data tidy and readable.\n\nSorting the dataset by is_shouting brings all uppercase titles to the top for easy inspection.\n\nFinally, we use count() to summarize how many shouting vs. non-shouting titles are in the dataset.\n\n\n\n\n\n# Identify the top 3 most common genres by track count\n# For each genre, create a filtered data frame with one artist per row\ntop_genre_dfs &lt;- spotify |&gt;\n  count(track_genre, sort = TRUE) |&gt;\n  slice_head(n = 3) |&gt;\n  pull(track_genre) |&gt;\n  map(~ spotify |&gt;\n        filter(track_genre == .x) |&gt;\n        separate_rows(artists, sep = \";\") |&gt;\n        select(track_name, artists))\n\n\n# Combine all genre-specific data frames into one using reduce() and bind_rows()\ntop_genre_combined &lt;- reduce(top_genre_dfs, bind_rows)\n\n# Count how often each artist appears in the top 3 genres\ntop_genre_combined |&gt; count(artists, sort = TRUE)\n\n# A tibble: 1,785 × 2\n   artists                   n\n   &lt;chr&gt;                 &lt;int&gt;\n 1 ILLENIUM                 91\n 2 Linkin Park              59\n 3 SLANDER                  35\n 4 Seven Lions              34\n 5 Tritonal                 29\n 6 Porter Robinson          27\n 7 Red Hot Chili Peppers    27\n 8 Krewella                 25\n 9 Lucas Estrada            24\n10 Said The Sky             24\n# ℹ 1,775 more rows\n\n\n\nWe use map() to apply the same filtering and transformation steps to the top 3 genres, producing a list of genre-specific data frames.\n\nseparate_rows() splits artist collaborations so each artist gets their own row, allowing for accurate counts.\n\nEach mini data frame keeps only the track_name and artists columns for focused analysis.\n\nreduce() with bind_rows() merges all the genre-specific data frames into one unified dataset.\n\nThe final count() tallies how often each artist appears across the top genres, highlighting the most active contributors.\n\nThis pattern is great for when you need to analyze subgroups separately before combining results for broader insight.\n\n\n\n\n\n# Select only character columns for text-based search\n# Use imap_lgl() to check each column for any value that includes the word \"may\" (case-insensitive)\n# Return only the columns where the condition is TRUE\nspotify |&gt;\n  select(where(is.character)) |&gt;\n  imap_lgl(~ any(str_detect(str_to_lower(.x), \"may\"))) |&gt;\n  keep(identity)\n\n  track_id    artists album_name track_name \n      TRUE       TRUE       TRUE       TRUE \n\n\n\nWe limit our search to character columns using select(where(is.character)), focusing only on text-based fields.\n\nimap_lgl() checks each column to see if any of its values include the word “may” (case-insensitive).\n\nThe use of str_to_lower() ensures matches regardless of capitalization (e.g., “May”, “MAY”, “may”).\n\nThe result is a logical vector indicating which columns contain at least one match.\n\nkeep(identity) filters this vector to return only the columns where the condition is TRUE.\n\nThis is a flexible technique for pattern searching across a dataset when you don’t know exactly where a value might be found.\n\n\n\n\n\n# Define which numeric audio features to visualize\nfeatures &lt;- c(\"energy\", \"danceability\", \"valence\")\n\n# Create a function that builds a violin plot of the given feature\n# Plots distribution by popularity group and facets by genre\nmake_boxplot &lt;- function(var_name) {\n  spotify |&gt;\n    ggplot(aes(x = popular_or_not, y = .data[[var_name]], fill = popular_or_not)) +\n    geom_violin(show.legend = FALSE, draw_quantiles = c(0.25, 0.5, 0.75)) +\n    facet_wrap(facets = vars(track_genre), nrow = 2) +\n    labs(\n      title = paste(\"Violin plot of\", var_name, \"by popularity and genre\"),\n      y = var_name,\n      x = NULL\n    )\n}\n\n\n# Use map() to generate a list of plots—one per feature\nboxplots &lt;- map(features, make_boxplot)\n\n# Use walk2() to print a message before showing each plot\nwalk2(\n  .x = boxplots,\n  .y = features,\n  .f = ~ {\n    cat(\"Now plotting:\", .y, \"by popularity\\n\")\n    print(.x)\n  }\n)\n\nNow plotting: energy by popularity\n\n\n\n\n\nNow plotting: danceability by popularity\n\n\n\n\n\nNow plotting: valence by popularity\n\n\n\n\n\n\nWe define a reusable function make_boxplot() that creates a violin plot of any selected audio feature by popularity and genre.\n\n.data[[var_name]] allows dynamic column selection within aes() when working inside a function.\n\nfacet_wrap() creates separate panels for each genre, making genre-wise comparisons easy.\n\nmap() generates a list of plots—one for each feature in the features vector.\n\nwalk2() prints a custom message and displays each plot sequentially, helping to narrate the output.\n\nThis workflow automates repetitive plotting tasks and supports scalable, tidy visual exploration.\n\n\n\n\n\n# Define which numeric features we want to analyze\nfeatures &lt;- c(\"energy\", \"danceability\", \"tempo\", \"valence\")\n\n# Create a function that:\n# (1) finds the most extreme (highest) track for a feature\n# (2) counts how many values are missing\n# (3) creates a histogram of the feature\nfeature_info_plot &lt;- function(var, ...) {\n  \n  # Convert character column name to symbol\n  var_sym &lt;- sym(var)\n  \n  # Find the track with the highest value for the feature\n  top_track &lt;- spotify |&gt;\n    filter(!is.na(!!var_sym)) |&gt;\n    arrange(desc(!!var_sym)) |&gt;\n    slice(1) |&gt;\n    select(track_name, artists, !!var_sym)\n  \n  # Count missing values for the feature\n  n_missing &lt;- spotify |&gt;\n    summarize(missing = sum(is.na(!!var_sym))) |&gt;\n    pull(missing)\n  \n  # Create a histogram for the feature\n  plot &lt;- ggplot(spotify, aes(x = !!var_sym)) +\n    geom_histogram(fill = \"coral\", color = \"black\", ...) +\n    labs(title = paste(\"Distribution of\", var), x = var)\n  \n  # Return a list with all outputs\n  list(top_track = top_track, missing = n_missing, plot = plot)\n}\n\n\n# Apply the summary+plot function to each feature\nresults &lt;- map(features, feature_info_plot, bins = 30)\n\n# Example: View the top track, missing count, and histogram for danceability\nresults[[2]]$top_track\n\n# A tibble: 1 × 3\n  track_name artists                        danceability\n  &lt;chr&gt;      &lt;chr&gt;                                 &lt;dbl&gt;\n1 Pineapple  Ty Dolla $ign;Gucci Mane;Quavo        0.964\n\nresults[[2]]$missing\n\n[1] 0\n\nresults[[2]]$plot\n\n\n\n\n\nWe define a single function that bundles three tasks: finding the top-valued track, counting missing values, and creating a histogram for a given feature.\n\nsym(var) combined with the tidy evaluation operator !! allows us to dynamically reference column names in both dplyr and ggplot2, making the function reusable across variables.\n\nThe top_track output shows which song has the highest value for the selected feature.\n\nThe missing count gives quick insight into data quality for each feature.\n\nEach plot is a histogram of the feature’s distribution, styled with customizable arguments like bins.\n\nMapping the function over multiple features automates a detailed, consistent summary for each variable.\n\n\n\n\n\n(4.1) What is the primary benefit of using map_*() functions from the purrr package?\nA. They allow you to mutate multiple columns in a single step without grouping.\nB. They eliminate the need for using loops by applying a function across lists or vectors, returning a consistent output type.\nC. They automatically create interactive plots for each element of a list.\nD. They convert data frames into nested tibbles grouped by variable type.\n\n(4.2) In the context of functional programming in R, what is a key reason for using walk() instead of map()?\nA. walk() is used when you want to display plots as inline HTML.\nB. walk() is preferred when applying a function with a return value that will be used later.\nC. walk() is for performing operations with side effects (e.g., saving plots), where you don’t need a return value.\nD. walk() is the only purrr function that supports parallel processing out of the box.\n\n(4.3) What is a major advantage of defining reusable functions (e.g., is_all_caps() or feature_info_plot()), especially when paired with map()?\nA. It allows you to convert tidyverse functions into base R equivalents.\nB. It minimizes the need for conditional logic and nesting entirely.\nC. It supports clearer, modular code that can be reused and debugged more easily.\nD. It ensures all results are automatically returned as JSON-compatible outputs.\n\n(4.4) How does the reduce() function complement map() when working with lists?\nA. It generates side-effect functions like ggsave() or print(), replacing the need for walk().\nB. It sequentially combines list elements using a binary function, such as merging multiple data frames.\nC. It transforms character vectors into numeric ones using consistent logic.\nD. It is used to convert factor variables to character to prepare for visualization.\n\n(4.5) Which scenario best illustrates the use of imap_lgl() in exploratory analysis?\nA. Searching a list of numeric vectors to compute trimmed means.\nB. Iterating over grouped plots and saving them to PNGs with labeled filenames.\nC. Searching all character columns to identify which contain a specific keyword like “may”.\nD. Converting grouped data frames into JSON summaries for API output.\n\n\n\n\n(4.1) What is the primary benefit of using map_*() functions from the purrr package?\nCorrect Answer:\nB. They eliminate the need for using loops by applying a function across lists or vectors, returning a consistent output type.\nExplanation:\nmap_*() functions (like map_dbl(), map_chr()) replace loops with concise, type-safe iteration, ensuring uniform output structures.\n\n(4.2) In the context of functional programming in R, what is a key reason for using walk() instead of map()?\nCorrect Answer:\nC. walk() is for performing operations with side effects (e.g., saving plots), where you don’t need a return value.\nExplanation:\nUnlike map(), which returns a value, walk() is used when the function’s purpose is the action itself, like writing files or printing.\n\n(4.3) What is a major advantage of defining reusable functions (e.g., is_all_caps() or feature_info_plot()), especially when paired with map()?\nCorrect Answer:\nC. It supports clearer, modular code that can be reused and debugged more easily.\nExplanation:\nEncapsulating logic into small, named functions improves code clarity and allows consistent reuse across multiple inputs with map().\n\n(4.4) How does the reduce() function complement map() when working with lists?\nCorrect Answer:\nB. It sequentially combines list elements using a binary function, such as merging multiple data frames.\nExplanation:\nWhile map() transforms each list element, reduce() is used to combine them—e.g., stacking multiple data frames into one using bind_rows.\n\n(4.5) Which scenario best illustrates the use of imap_lgl() in exploratory analysis?\nCorrect Answer:\nC. Searching all character columns to identify which contain a specific keyword like “may”.\nExplanation:\nimap_lgl() applies a function to each column (and can use column names), returning a logical vector—perfect for targeted searches."
  },
  {
    "objectID": "answers/day2_walkthrough_answers.html#session-5-interactive-data-visualization-with-plotly",
    "href": "answers/day2_walkthrough_answers.html#session-5-interactive-data-visualization-with-plotly",
    "title": "Exploratory Data Analysis in R with the tidyverse",
    "section": "",
    "text": "# Create a static scatterplot with ggplot2 comparing danceability and energy\n( p &lt;- ggplot(spotify, aes(x = danceability, y = energy)) +\n  geom_point(alpha = 0.1, color = \"red\") +\n  labs(title = \"Energy vs Danceability\") )\n\n\n\n\n\n# Convert the static ggplot to an interactive plot using plotly\nggplotly(p)\n\n\n\n\n\n\nWe create a scatterplot using ggplot2 to explore the relationship between danceability and energy.\n\ngeom_point(alpha = 0.4) adds transparency, helping reveal patterns even in dense areas of the plot.\n\nClear axis labels and a title make the visualization easy to interpret.\n\nWrapping the plot in ggplotly() converts it into an interactive chart with zoom, pan, and tooltip support.\n\nThis quick upgrade improves usability and is ideal for data exploration, teaching, or interactive reporting.\n\n\n\n\n\nset.seed(2025)\n\n# Create a scatterplot with custom hover text showing track name, artists, and genre\np &lt;- ggplot(spotify |&gt; slice_sample(n = 100),\n            aes(x = danceability, y = energy,\n                text = paste(\"Track:\", track_name,\n                             \"&lt;br&gt;Artist(s):\", artists,\n                             \"&lt;br&gt;Genre:\", track_genre))) +\n  geom_point(aes(color = track_genre)) +\n  labs(title = \"Energy vs Danceability (Hover to Explore)\")\n\n\n# Convert the plot to an interactive version with custom tooltip enabled\nggplotly(p, tooltip = \"text\")\n\n\n\n\n\n\nWe use slice_sample(n = 100) to reduce the dataset to a manageable size for visual clarity.\n\nThe text aesthetic customizes hover content to display track name, artist(s), and genre in HTML format.\n\ngeom_point() creates the scatterplot, with transparency set to 0.7 for better visibility.\n\nggplotly(..., tooltip = \"text\") ensures that the interactive tooltips use our custom hover text.\n\nThis approach enhances user experience by adding context to each point in the plot, making it ideal for exploration or dashboards.\n\n\n\n\n\n# Count the number of tracks in each genre and sort from most to least\ngenre_counts &lt;- spotify |&gt; count(track_genre, sort = TRUE)\n\n\n# Create an interactive bar chart using plotly::plot_ly\n# Display track counts with custom hover text\nplot_ly(\n  data = genre_counts,\n  x = ~reorder(track_genre, n),\n  y = ~n,\n  type = \"bar\",\n  hovertext = ~paste(n, \"tracks\"),\n  hoverinfo = \"text\"\n) |&gt; \n  layout(\n    title = \"Number of Tracks by Genre\",\n    xaxis = list(title = \"Genre\"),\n    yaxis = list(title = \"Track Count\")\n  )\n\n\n\n\n\n\nWe use count(track_genre, sort = TRUE) to tally how many tracks belong to each genre, ordered from most to least.\n\nplot_ly() builds an interactive bar chart with type = \"bar\" and uses reorder() to sort genres along the x-axis.\n\nCustom hover text (paste(n, \"tracks\")) enhances readability when exploring the plot.\n\nhoverinfo = \"text\" ensures only the custom tooltip is shown, not raw values.\n\nlayout() adds a clear title and axis labels, making the plot suitable for reports or dashboards.\n\nThis example demonstrates how to create sleek, interactive summaries of categorical variables with minimal code.\n\n\n\n\n\n# Create an interactive boxplot of energy levels across genres\nspotify |&gt; \n  plot_ly(\n    x = ~track_genre,\n    y = ~energy,\n    type = \"box\"\n  )\n\n\n\n\n\n\nWe use plot_ly() with type = \"box\" to visualize the distribution of energy across music genres.\n\nEach boxplot shows the median, interquartile range, and potential outliers for that genre’s energy scores.\n\nThe interactive format allows users to hover and explore exact values, enhancing interpretability.\n\nlayout() adds informative axis labels and a descriptive title for clarity.\n\nThis plot is great for comparing variability and central tendencies across categories in an engaging way.\n\n\n\n\n\n# Convert dataset to long format for multiple features\nspotify_long &lt;- spotify |&gt;\n  select(energy, danceability, valence, popular_or_not) |&gt;\n  pivot_longer(cols = -popular_or_not, names_to = \"feature\", values_to = \"value\")\n\n\n# Create a faceted boxplot comparing distributions across popularity groups\n# One facet per audio feature\np &lt;- ggplot(spotify_long, aes(x = popular_or_not, y = value, fill = popular_or_not)) +\n  geom_boxplot() +\n  facet_wrap(~ feature, scales = \"free\") +\n  labs(title = \"Feature Distributions by Popularity Group\")\n\n\n# Convert the static faceted plot to an interactive plot\nggplotly(p)\n\n\n\n\n\n\nWe use pivot_longer() to reshape multiple audio features into a long format, enabling easy comparison across variables.\n\nThe resulting dataset has one column for feature names (feature) and one for their values (value).\n\nfacet_wrap() creates a separate boxplot for each feature, grouped by popular_or_not, with independent y-axis scales.\n\ngeom_boxplot() summarizes each feature’s distribution, highlighting medians, quartiles, and outliers.\n\nConverting the plot with ggplotly() adds interactivity, letting users hover over each box to see exact values.\n\nThis method is ideal for visualizing how multiple features differ between groups in a clean, side-by-side layout.\n\n\n\n\n\n# Create an interactive line chart of daily max wind gusts at FLG airport\nazflights24::weather |&gt;\n  filter(origin == \"FLG\") |&gt;\n  mutate(date = as_date(time_hour)) |&gt;\n  group_by(date) |&gt;\n  summarize(max_gust = max(wind_gust, na.rm = TRUE)) |&gt;\n  plot_ly(x = ~date, y = ~max_gust, type = \"scatter\", mode = \"lines\") |&gt;\n  layout(\n    title = \"\\nDaily Max Wind Gust in Flagstaff\",\n    xaxis = list(title = \"Date\"),\n    yaxis = list(title = \"Max Wind Gust (mph)\")\n  )\n\n\n\n\n\n\nWe filter the weather dataset for Flagstaff (FLG) and convert hourly timestamps to calendar dates using as_date().\n\ngroup_by(date) and summarize() compute the maximum wind gust for each day.\n\nplot_ly() creates an interactive line chart with type = \"scatter\" and mode = \"lines\" to show the trend over time.\n\nThe interactive plot supports zooming and tooltips, making it easy to explore peaks and seasonal variation.\n\nAxis labels and a clear title are added using layout() to improve readability and presentation.\n\nThis visualization is ideal for analyzing time-based trends in weather or other sensor-style datasets.\n\n\n\n\n\n# Load the scales package for formatting percentages\nlibrary(scales)\n\n# Summarize flight on-time performance and flight counts by origin and carrier\nflights_ontime &lt;- flights |&gt;\n  filter(!is.na(dep_delay), !is.na(arr_delay)) |&gt;\n  group_by(origin, carrier) |&gt;\n  summarize(\n    ontime_dep = mean(dep_delay &lt;= 0, na.rm = TRUE),  # % of flights that left on time\n    ontime_arr = mean(arr_delay &lt;= 0, na.rm = TRUE),  # % of flights that arrived on time\n    n_flights = n(),\n    .groups = \"drop\"\n  ) |&gt;\n  inner_join(airlines, by = \"carrier\") |&gt;  # Add airline names\n  mutate(\n    tooltip = paste0(\n      \"Origin: \", origin,\n      \"&lt;br&gt;Carrier: \", name,\n      \"&lt;br&gt;On-Time Departures: \", percent(ontime_dep, accuracy = 1),\n      \"&lt;br&gt;On-Time Arrivals: \", percent(ontime_arr, accuracy = 1),\n      \"&lt;br&gt;Total Flights: \", n_flights\n    )\n  )\n\n\n# Create scatterplot comparing on-time departure and arrival performance\np &lt;- ggplot(flights_ontime, aes(\n  x = ontime_dep,\n  y = ontime_arr,\n  color = origin,\n  size = n_flights,\n  text = tooltip\n)) +\n  geom_point(alpha = 0.8) +\n  geom_abline(slope = 1, intercept = 0, linetype = \"dashed\", color = \"gray60\") +\n  scale_x_continuous(labels = percent_format(accuracy = 1)) +\n  scale_y_continuous(labels = percent_format(accuracy = 1)) +\n  labs(\n    title = \"On-Time Performance by Origin and Carrier\",\n    subtitle = \"Each point represents one (origin, carrier) combination\",\n    x = \"On-Time Departure Rate\",\n    y = \"On-Time Arrival Rate\",\n    size = \"Flight Volume\",\n    color = \"Origin Airport\"\n  ) +\n  theme_minimal()\n\n\n# Convert to interactive with tooltip\nggplotly(p, tooltip = \"text\")\n\n\n\n\n\n\nWe filter and summarize flight data to calculate the on-time departure and arrival rates by origin and carrier.\n\npercent() from the scales package formats these rates for display in tooltips.\n\nEach point in the scatterplot represents a unique origin–carrier pair, sized by number of flights and colored by airport.\n\nA 45° dashed line indicates equal performance for departures and arrivals, making deviations easy to spot.\n\nCustom tooltips include origin, carrier name, performance metrics, and total flights, enhancing user interaction.\n\nggplotly() makes the plot interactive, letting viewers hover to explore detailed airline punctuality.\n\n\n\n\n\n# Load weather source survey data and calculate percentages\ndata(\"weather_check\", package = \"fivethirtyeight\")\n\nweather_check |&gt;\n  filter(!is.na(weather_source)) |&gt;\n  count(weather_source, sort = TRUE) |&gt;\n  mutate(\n    pct = scales::percent(n / sum(n), accuracy = 0.1),  # Add percentage column\n    text = paste0(n, \" responses (\", pct, \")\")  # Custom hover text\n  ) |&gt;\n  plot_ly(\n    y = ~reorder(weather_source, n),  # Reorder by count\n    x = ~n,\n    type = \"bar\",\n    hovertext = ~text,\n    hoverinfo = \"text\"  # Use custom hover text\n  ) |&gt;\n  layout(\n    title = \"Most Common Weather Sources\",\n    xaxis = list(title = \"Responses\"),\n    yaxis = list(title = \"Weather Source\")\n  )\n\n\n\n\n\n\nWe filter out missing values and count how many respondents preferred each weather source.\n\nA new column pct calculates the percentage of responses per source, formatted with scales::percent().\n\nCustom hover text is created with paste0() to include source name, count, and percentage.\n\nplot_ly() generates an interactive horizontal bar chart, with bars ordered by response count.\n\nhoverinfo = \"text\" ensures only the custom tooltips are shown when hovering.\n\nThis visualization clearly highlights the most common weather sources while enabling detailed exploration.\n\n\n\n\n\n# Create a histogram of the 'energy' feature with custom styling and a range slider\nplot_ly(\n  data = spotify,\n  x = ~energy,\n  type = \"histogram\",\n  marker = list(\n    color = 'lightblue',             # Fill color of the bars\n    line = list(\n      color = 'black',               # Border color\n      width = 1.5                    # Border thickness\n    )\n  )\n) |&gt;\n  layout(\n    title = \"Histogram of Energy\",\n    xaxis = list(\n      title = \"Energy\",\n      rangeslider = list(visible = TRUE)  # Enable interactive range slider\n    ),\n    yaxis = list(title = \"Count\")\n  )\n\n\n\n\n\n\nWe use plot_ly() with type = \"histogram\" to visualize the distribution of the energy feature.\n\nCustom styling improves readability with light blue bars and bold black outlines.\n\nA range slider is added to the x-axis, allowing users to zoom into specific energy ranges interactively.\n\nlayout() defines axis labels and the chart title, making the plot informative and presentation-ready.\n\nThis interactive design is great for exploring distributions with variability or subtle structure.\n\n\n\n\n\n# Step 1: Summarize the monthly high temperatures by airport and year\nmonthly_highs &lt;- weather |&gt;\n  filter(!is.na(temp)) |&gt;\n  mutate(\n    month = month(time_hour, label = TRUE),  # Extract month as a labeled factor\n    year = year(time_hour)                   # Extract year\n  ) |&gt;\n  group_by(origin, year, month) |&gt;\n  summarize(\n    avg_high_temp = max(temp, na.rm = TRUE), # Use max temp as the monthly high\n    .groups = \"drop\"\n  ) |&gt;\n  mutate(\n    tooltip = paste0(\n      \"&lt;b&gt;Origin:&lt;/b&gt; \", origin,\n      \"&lt;br&gt;&lt;b&gt;Month:&lt;/b&gt; \", month,\n      \"&lt;br&gt;&lt;b&gt;Year:&lt;/b&gt; \", year,\n      \"&lt;br&gt;&lt;b&gt;High Temp:&lt;/b&gt; \", round(avg_high_temp, 1), \" °F\"\n    )\n  )\n\n\n# Step 2: Create the ggplot line chart with tooltip text\np &lt;- ggplot(monthly_highs, aes(\n  x = month, \n  y = avg_high_temp, \n  group = interaction(year, origin), \n  color = origin,\n  text = tooltip\n)) +\n  geom_line() +\n  geom_point() +\n  labs(\n    title = \"Monthly High Temperature by Airport\",\n    x = \"Month\",\n    y = \"High Temperature (°F)\",\n    color = \"Airport\"\n  ) +\n  theme_minimal()\n\n\n# Step 3: Convert to an interactive plot with custom tooltip\nggplotly(p, tooltip = \"text\")\n\n\n\n\n\n\nWe compute monthly high temperatures using max(temp) grouped by airport, year, and month for a clear seasonal summary.\n\nMonth labels are extracted with month(..., label = TRUE) for improved plot readability.\n\nA detailed tooltip is created with paste0(), combining airport, month, year, and temperature info.\n\ninteraction(year, origin) ensures each line represents a unique airport–year combination in the plot.\n\nggplotly(p, tooltip = \"text\") adds interactivity, enabling users to hover for insights and compare trends across time and location.\n\nThis is a great example of combining temporal, spatial, and statistical elements into one clear and engaging chart.\n\n\n\n\n\n(5.1) What is the primary advantage of using ggplotly() with an existing ggplot2 plot?\nA. It converts the plot into an interactive version with hover, zoom, and pan capabilities.\nB. It exports the plot directly to PowerPoint or PDF with built-in animations.\nC. It adds static labels to each point for easier print output.\nD. It improves rendering performance by simplifying the plot structure.\n\n(5.2) Why is specifying the tooltip = \"text\" argument useful in ggplotly()?\nA. It automatically maps data aesthetics like size or color into tooltips.\nB. It links tooltips to custom text content, allowing for more informative hover details.\nC. It ensures that labels are automatically translated into multiple languages.\nD. It prevents tooltips from showing variable names when using plot_ly().\n\n(5.3) In plot_ly(), which of the following enhances the readability of categorical plots like bar charts?\nA. Setting hoverinfo = \"none\" to reduce distractions\nB. Using facet_wrap() to group categories into subplots\nC. Adding annotations using geom_text()\nD. Sorting categories manually by reordering the y aesthetic\n\n(5.4) When creating an interactive histogram with a range slider in plotly, which element must be specified?\nA. range_slider = \"x\" in the histogram trace definition\nB. rangeSelector = TRUE in the histogram layout\nC. add_slider() inside geom_histogram()\nD. rangeslider = list(visible = TRUE) inside the xaxis layout\n\n(5.5) What is the benefit of transforming a dataset to long format before plotting multiple features interactively?\nA. It enables easier comparison of multiple variables across a common grouping, such as popular_or_not.\nB. It prevents the need to use the pivot_wider() function for grouped bar plots.\nC. It simplifies layout by removing the need for facetting or coloring.\nD. It allows faster computation since each column becomes a numeric vector.\n\n\n\n\n(5.1)\nCorrect Answer: A. It converts the plot into an interactive version with hover, zoom, and pan capabilities.\nExplanation: ggplotly() transforms static ggplot2 plots into interactive ones, making it easier to explore the data dynamically.\n\n(5.2)\nCorrect Answer: B. It links tooltips to custom text content, allowing for more informative hover details.\nExplanation: The text aesthetic allows you to fully customize hover text when passed into ggplotly() with tooltip = \"text\".\n\n(5.3)\nCorrect Answer: D. Sorting categories manually by reordering the y aesthetic\nExplanation: Reordering categorical axes improves the interpretability of bar charts by presenting data in a logical order.\n\n(5.4)\nCorrect Answer: D. rangeslider = list(visible = TRUE) inside the xaxis layout\nExplanation: This adds a zoomable slider on the x-axis of a histogram, enhancing interactivity.\n\n(5.5)\nCorrect Answer: A. It enables easier comparison of multiple variables across a common grouping, such as popular_or_not.\nExplanation: Long-format data is ideal for faceting and grouped comparisons in ggplot2 and plotly visualizations."
  },
  {
    "objectID": "answers/day2_walkthrough_answers.html#session-6-end-to-end-case-study",
    "href": "answers/day2_walkthrough_answers.html#session-6-end-to-end-case-study",
    "title": "Exploratory Data Analysis in R with the tidyverse",
    "section": "",
    "text": "Part 1: Load and Prepare the Data\n\n\n\n# Load the readr package for reading CSV files\nlibrary(readr)\n\n# Read in the raw data from a CSV file\npalmtrees_raw &lt;- read_csv(\"../palmtrees_funky.csv\")\n\n# Display the dataset to get a quick sense of the structure and contents\npalmtrees_raw\n\n# A tibble: 2,557 × 29\n   spec_name         acc_genus acc_species palm_tribe palm_subfamily climbing acaulescent erect stem_solitary stem_armed\n   &lt;chr&gt;             &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;          &lt;chr&gt;    &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;     \n 1 Acanthophoenix c… Acanthop… crinita     Areceae    Arecoideae     climbing acaulescent non-… non-solitary  non-armed \n 2 Acanthophoenix r… Acanthop… rousselii   Areceae    Arecoideae     climbing acaulescent non-… non-solitary  non-armed \n 3 Acanthophoenix r… Acanthop… rubra       Areceae    Arecoideae     climbing acaulescent non-… non-solitary  non-armed \n 4 Acoelorrhaphe wr… Acoelorr… wrightii    Trachycar… Coryphoideae   climbing acaulescent non-… solitary      armed     \n 5 Acrocomia aculea… Acrocomia aculeata    Cocoseae   Arecoideae     climbing acaulescent non-… non-solitary  non-armed \n 6 Acrocomia crispa  Acrocomia crispa      Cocoseae   Arecoideae     climbing acaulescent non-… non-solitary  non-armed \n 7 Acrocomia emensis Acrocomia emensis     Cocoseae   Arecoideae     climbing non-acaule… erect non-solitary  non-armed \n 8 Acrocomia glauce… Acrocomia glaucescens Cocoseae   Arecoideae     climbing acaulescent non-… non-solitary  non-armed \n 9 Acrocomia hassle… Acrocomia hassleri    Cocoseae   Arecoideae     climbing non-acaule… erect non-solitary  non-armed \n10 Acrocomia intume… Acrocomia intumescens Cocoseae   Arecoideae     climbing acaulescent non-… non-solitary  non-armed \n# ℹ 2,547 more rows\n# ℹ 19 more variables: leaves_armed &lt;chr&gt;, `Max Stem Height (m)` &lt;dbl&gt;, max_stem_dia_cm &lt;dbl&gt;,\n#   understorey_canopy &lt;chr&gt;, `# of Leaves` &lt;dbl&gt;, `max__blade__length_m!!!` &lt;dbl&gt;, max__rachis__length_m &lt;dbl&gt;,\n#   max__petiole_length_m &lt;dbl&gt;, average_fruit_length_cm &lt;dbl&gt;, min_fruit_length_cm &lt;dbl&gt;, max_fruit_length_cm &lt;dbl&gt;,\n#   `Average-Fruit Width (cm)` &lt;dbl&gt;, min_fruit_width_cm &lt;dbl&gt;, max_fruit_width_cm &lt;dbl&gt;, fruit_size_categorical &lt;chr&gt;,\n#   `¿Fruit Shape?` &lt;chr&gt;, `Fruit Color Description (raw)` &lt;chr&gt;, `main fruit COLORS!` &lt;chr&gt;, conspicuousness &lt;chr&gt;\n\n\n\nWe use read_csv() from the readr package to load the palmtrees_funky.csv dataset into R.\n\nPrinting the dataset gives an immediate overview of its structure, column names, and sample data, helping to identify any potential issues.\n\n\n\n\n\n# Load janitor for cleaning messy or inconsistent column names\nlibrary(janitor)\n\n# Clean column names: convert to lowercase, replace spaces and special characters with underscores\npalms &lt;- palmtrees_raw |&gt; clean_names()\n\n# View structure and types of cleaned data\nglimpse(palms)\n\nRows: 2,557\nColumns: 29\n$ spec_name                   &lt;chr&gt; \"Acanthophoenix crinita\", \"Acanthophoenix rousselii\", \"Acanthophoenix rubra\", \"Aco…\n$ acc_genus                   &lt;chr&gt; \"Acanthophoenix\", \"Acanthophoenix\", \"Acanthophoenix\", \"Acoelorrhaphe\", \"Acrocomia\"…\n$ acc_species                 &lt;chr&gt; \"crinita\", \"rousselii\", \"rubra\", \"wrightii\", \"aculeata\", \"crispa\", \"emensis\", \"gla…\n$ palm_tribe                  &lt;chr&gt; \"Areceae\", \"Areceae\", \"Areceae\", \"Trachycarpeae\", \"Cocoseae\", \"Cocoseae\", \"Cocosea…\n$ palm_subfamily              &lt;chr&gt; \"Arecoideae\", \"Arecoideae\", \"Arecoideae\", \"Coryphoideae\", \"Arecoideae\", \"Arecoidea…\n$ climbing                    &lt;chr&gt; \"climbing\", \"climbing\", \"climbing\", \"climbing\", \"climbing\", \"climbing\", \"climbing\"…\n$ acaulescent                 &lt;chr&gt; \"acaulescent\", \"acaulescent\", \"acaulescent\", \"acaulescent\", \"acaulescent\", \"acaule…\n$ erect                       &lt;chr&gt; \"non-erect\", \"non-erect\", \"non-erect\", \"non-erect\", \"non-erect\", \"non-erect\", \"ere…\n$ stem_solitary               &lt;chr&gt; \"non-solitary\", \"non-solitary\", \"non-solitary\", \"solitary\", \"non-solitary\", \"non-s…\n$ stem_armed                  &lt;chr&gt; \"non-armed\", \"non-armed\", \"non-armed\", \"armed\", \"non-armed\", \"non-armed\", \"non-arm…\n$ leaves_armed                &lt;chr&gt; \"non-armed\", \"non-armed\", \"non-armed\", \"non-armed\", \"non-armed\", \"non-armed\", \"non…\n$ max_stem_height_m           &lt;dbl&gt; 10.0, 25.0, 15.0, 9.1, 12.0, 18.0, 0.0, NA, 0.0, NA, 15.0, NA, 9.0, 9.0, 40.0, NA,…\n$ max_stem_dia_cm             &lt;dbl&gt; 20.0, 30.0, 18.0, 15.0, 50.0, 35.0, NA, NA, NA, NA, 30.0, NA, 9.0, 36.0, 30.0, NA,…\n$ understorey_canopy          &lt;chr&gt; \"canopy\", \"canopy\", \"canopy\", \"canopy\", \"canopy\", \"canopy\", \"understorey\", NA, \"un…\n$ number_of_leaves            &lt;dbl&gt; 15, NA, 20, 25, 30, 15, NA, NA, 6, NA, NA, NA, 7, 10, 13, NA, 17, NA, 10, 13, 8, 9…\n$ max_blade_length_m          &lt;dbl&gt; 2.30, 3.00, 3.10, 1.30, 3.50, 3.00, NA, NA, 0.90, NA, NA, NA, 2.35, 1.20, 4.76, NA…\n$ max_rachis_length_m         &lt;dbl&gt; NA, NA, 3.00, 0.70, 2.50, NA, NA, NA, 0.54, NA, NA, NA, 2.10, NA, 4.30, NA, 2.00, …\n$ max_petiole_length_m        &lt;dbl&gt; NA, NA, NA, 0.65, NA, 0.65, NA, NA, 0.51, NA, NA, NA, 1.30, 0.22, 0.51, NA, 0.22, …\n$ average_fruit_length_cm     &lt;dbl&gt; 0.65, 2.00, 1.00, 0.70, 4.25, 2.50, 2.00, NA, 2.25, 4.60, NA, 3.00, 2.60, 3.00, 10…\n$ min_fruit_length_cm         &lt;dbl&gt; 0.6, NA, NA, NA, 3.5, NA, NA, NA, 1.5, 3.8, NA, 2.5, 1.8, NA, NA, NA, NA, NA, NA, …\n$ max_fruit_length_cm         &lt;dbl&gt; 0.7, NA, NA, NA, 5.0, NA, NA, NA, 3.0, 5.4, NA, 3.5, 3.4, NA, NA, NA, NA, NA, NA, …\n$ average_fruit_width_cm      &lt;dbl&gt; 0.50, 0.80, 0.70, 0.70, 4.60, 1.80, 2.00, NA, 2.25, 4.60, NA, 3.00, 1.10, 1.30, 5.…\n$ min_fruit_width_cm          &lt;dbl&gt; NA, NA, NA, 0.5, 3.8, NA, NA, NA, 1.5, 3.8, NA, 2.5, 0.8, NA, 5.0, NA, NA, NA, NA,…\n$ max_fruit_width_cm          &lt;dbl&gt; NA, NA, NA, 0.9, 5.4, NA, NA, NA, 3.0, 5.4, NA, 3.5, 1.4, NA, 6.0, NA, NA, NA, NA,…\n$ fruit_size_categorical      &lt;chr&gt; \"small\", \"small\", \"small\", \"small\", \"large\", \"small\", \"small\", NA, \"small\", \"large…\n$ fruit_shape                 &lt;chr&gt; NA, \"ovoid\", \"ovoid\", \"ovoid\", \"ovoid\", \"globose\", NA, NA, NA, NA, \"ovoid\", NA, \"g…\n$ fruit_color_description_raw &lt;chr&gt; \"black\", \"black\", \"black\", \"orange-brown; becomming black\", \"yellowish green\", \"ye…\n$ main_fruit_colors           &lt;chr&gt; \"black\", \"black\", \"black\", \"brown; black\", \"green\", \"yellow; orange\", NA, NA, \"bro…\n$ conspicuousness             &lt;chr&gt; \"cryptic\", \"cryptic\", \"cryptic\", \"cryptic\", \"cryptic\", \"conspicuous\", NA, NA, \"cry…\n\n\n\njanitor::clean_names() standardizes column names by converting them to lowercase and replacing spaces/special characters with underscores.\n\nglimpse() helps confirm the cleaning worked and shows the structure of the cleaned dataset, including column types.\n\nThis cleanup step improves consistency and reduces potential errors when referencing columns in code.\n\n\n\n\n\n# Summarize how many missing values are in each column\npalms |&gt; \n  summarize(across(everything(), ~ sum(is.na(.)))) |&gt;\n  pivot_longer(cols = everything(), names_to = \"column\", values_to = \"n_missing\") |&gt;\n  arrange(desc(n_missing))\n\n# A tibble: 29 × 2\n   column               n_missing\n   &lt;chr&gt;                    &lt;int&gt;\n 1 min_fruit_length_cm       1651\n 2 max_fruit_length_cm       1641\n 3 min_fruit_width_cm        1563\n 4 max_fruit_width_cm        1555\n 5 max_petiole_length_m      1347\n 6 number_of_leaves          1251\n 7 max_rachis_length_m       1026\n 8 fruit_shape                765\n 9 main_fruit_colors          758\n10 conspicuousness            758\n# ℹ 19 more rows\n\n\n\nWe use across() to count missing values (NAs) in each column, providing an overview of data completeness.\n\npivot_longer() reshapes the result into a tidy format for easier interpretation and analysis.\n\nSorting by the number of missing values helps prioritize columns that may require cleaning or imputation.\n\n\nPart 2: Understand Variable Types and Distributions\n\n\n\n\n# Count the number of unique values in each selected categorical column\npalms |&gt; \n  select(climbing, erect, stem_armed, fruit_size_categorical, \n         fruit_shape, conspicuousness) |&gt;\n  map_df(~ tibble(n_unique = n_distinct(.x, na.rm = TRUE)), .id = \"variable\")\n\n# A tibble: 6 × 2\n  variable               n_unique\n  &lt;chr&gt;                     &lt;int&gt;\n1 climbing                      3\n2 erect                         3\n3 stem_armed                    2\n4 fruit_size_categorical        2\n5 fruit_shape                   7\n6 conspicuousness               2\n\n\n\n# Use moderndive's tidy_summary() for a more descriptive summary of the same traits\npalms |&gt; \n  select(climbing, erect, stem_armed, fruit_size_categorical, \n         fruit_shape, conspicuousness) |&gt;\n  tidy_summary()\n\n# A tibble: 23 × 11\n   group            n column                 type        min    Q1  mean median    Q3   max    sd\n   &lt;chr&gt;        &lt;int&gt; &lt;chr&gt;                  &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 both            16 climbing               character    NA    NA    NA     NA    NA    NA    NA\n 2 climbing      2011 climbing               character    NA    NA    NA     NA    NA    NA    NA\n 3 non-climbing   530 climbing               character    NA    NA    NA     NA    NA    NA    NA\n 4 both            48 erect                  character    NA    NA    NA     NA    NA    NA    NA\n 5 erect          738 erect                  character    NA    NA    NA     NA    NA    NA    NA\n 6 non-erect     1771 erect                  character    NA    NA    NA     NA    NA    NA    NA\n 7 armed         2297 stem_armed             character    NA    NA    NA     NA    NA    NA    NA\n 8 non-armed      205 stem_armed             character    NA    NA    NA     NA    NA    NA    NA\n 9 &lt;NA&gt;            55 stem_armed             character    NA    NA    NA     NA    NA    NA    NA\n10 large          251 fruit_size_categorical character    NA    NA    NA     NA    NA    NA    NA\n# ℹ 13 more rows\n\n\n\nWe use map_df() and n_distinct() to count unique values in selected categorical columns, giving an overview of their diversity.\n\ntidy_summary() from moderndive provides a more detailed summary, including counts, proportions, and missing values.\n\nThese steps help identify well-defined traits and highlight categorical variables that may need cleaning or recoding.\n\n\n\n\n\n# Visualize how species are distributed across fruit size categories\npalms |&gt; ggplot(aes(x = fruit_size_categorical)) +\n  geom_bar(fill = \"forestgreen\") +\n  labs(title = \"Distribution of Palm Fruit Sizes\")\n\n\n\n\n\nWe use geom_bar() to create a bar chart that shows the distribution of palm species across different fruit size categories.\nThis chart helps identify whether some fruit size categories are more common than others, offering a quick assessment of the data’s distribution.\n\n\n\n\n\n# Create a new column that summarizes whether the plant has any armament (on stem or leaves)\npalms &lt;- palms |&gt;\n  mutate(is_armed = case_when(\n    stem_armed == \"armed\" | leaves_armed == \"armed\" ~ \"Armed\",\n    stem_armed == \"non-armed\" & leaves_armed == \"non-armed\" ~ \"Not Armed\",\n    TRUE ~ \"Unknown\"\n  ))\n\n# Count the number of species in each armament category\npalms |&gt; count(is_armed)\n\n# A tibble: 3 × 2\n  is_armed      n\n  &lt;chr&gt;     &lt;int&gt;\n1 Armed      2313\n2 Not Armed   189\n3 Unknown      55\n\n\n\nWe create a new column, is_armed, that combines stem_armed and leaves_armed into a unified classification of “Armed” or “Not Armed”.\n\nThe count of species in each armament category is displayed using count(is_armed), giving us insight into the distribution of plant armament.\n\n\n\n\n\n# Visualize how stem height varies across different fruit size categories\npalms |&gt; \n  filter(!is.na(max_stem_height_m)) |&gt;\n  ggplot(aes(x = fruit_size_categorical, y = max_stem_height_m)) +\n  geom_boxplot(fill = \"tan\") +\n  labs(title = \"Stem Height by Fruit Size\")\n\n\n\n\n\nWe use a boxplot to visualize how stem height varies across different fruit size categories.\n\nfilter() removes missing height values, and geom_boxplot() displays the distribution of stem heights for each fruit size group.\n\n\n\n\n\n# Count how many species belong to each palm subfamily and visualize with a horizontal bar chart\npalms |&gt; \n  count(palm_subfamily, sort = TRUE) |&gt;\n  ggplot(aes(x = reorder(palm_subfamily, n), y = n)) +\n  geom_col(fill = \"lightblue\") +\n  coord_flip() +\n  labs(\n    title = \"Distribution of Palm Subfamilies\",\n    x = \"Palm Subfamily\",\n    y = \"Number of Species\"\n  )\n\n\n\n\n\nWe use a horizontal bar chart to visualize the distribution of palm species across subfamilies, with bars ordered by frequency.\n\ncoord_flip() rotates the chart for better readability, making it easier to compare the number of species in each subfamily.\n\n\n\n\n\n# Count the number of species in each palm subfamily by fruit conspicuousness category\npalms |&gt; \n  filter(!is.na(conspicuousness)) |&gt; \n  count(palm_subfamily, conspicuousness) |&gt; \n  ggplot(aes(x = palm_subfamily, y = n, fill = conspicuousness)) +\n  geom_col(position = \"dodge\") +\n  coord_flip() +\n  labs(\n    title = \"Distribution of Conspicuous vs Cryptic Fruits by Subfamily\",\n    x = \"Palm Subfamily\",\n    y = \"Number of Species\"\n  )\n\n\n\n\n\nWe use a side-by-side bar chart to compare fruit conspicuousness (conspicuous vs. cryptic) across palm subfamilies.\n\nposition = \"dodge\" places the bars next to each other, making it easy to compare the number of species in each category.\n\n\n\n\n\n# Plot a histogram to explore the distribution of stem heights\npalms |&gt; \n  ggplot(aes(x = max_stem_height_m)) +\n  geom_histogram(bins = 30, fill = \"turquoise\", color = \"black\") +\n  labs(title = \"Distribution of Stem Heights\")\n\nWarning: Removed 446 rows containing non-finite outside the scale range (`stat_bin()`).\n\n\n\n\n\n\nThe histogram visualizes the distribution of stem heights across palm species, helping to identify common height ranges and outliers.\n\nThe color choice (turquoise for fill and black for borders) enhances the chart’s clarity and visual appeal.\n\n\n\n\n\n# Select numeric columns and compute mean and standard deviation for each\nnum_cols &lt;- palms |&gt; select(where(is.numeric))\nmap_df(num_cols, \n       ~ tibble(\n         mean = mean(.x, na.rm = TRUE), \n         sd = sd(.x, na.rm = TRUE)\n       ), .id = \"variable\")\n\n# A tibble: 12 × 3\n   variable                  mean     sd\n   &lt;chr&gt;                    &lt;dbl&gt;  &lt;dbl&gt;\n 1 max_stem_height_m       10.9   13.0  \n 2 max_stem_dia_cm         12.4   17.1  \n 3 number_of_leaves        14.4    9.85 \n 4 max_blade_length_m       2.37   2.25 \n 5 max_rachis_length_m      1.97   1.80 \n 6 max_petiole_length_m     0.852  0.842\n 7 average_fruit_length_cm  2.20   2.24 \n 8 min_fruit_length_cm      2.18   2.30 \n 9 max_fruit_length_cm      3.10   3.32 \n10 average_fruit_width_cm   1.59   1.55 \n11 min_fruit_width_cm       1.48   1.36 \n12 max_fruit_width_cm       2.13   2.09 \n\n\n\n# Compare with tidy_summary() for a full tidy-style summary\npalms |&gt; \n  select(where(is.numeric)) |&gt;\n  tidy_summary(na.rm = TRUE) |&gt; \n  select(column, mean, sd)\n\n# A tibble: 12 × 3\n   column                    mean     sd\n   &lt;chr&gt;                    &lt;dbl&gt;  &lt;dbl&gt;\n 1 max_stem_height_m       10.9   13.0  \n 2 max_stem_dia_cm         12.4   17.1  \n 3 number_of_leaves        14.4    9.85 \n 4 max_blade_length_m       2.37   2.25 \n 5 max_rachis_length_m      1.97   1.80 \n 6 max_petiole_length_m     0.852  0.842\n 7 average_fruit_length_cm  2.20   2.24 \n 8 min_fruit_length_cm      2.18   2.30 \n 9 max_fruit_length_cm      3.10   3.32 \n10 average_fruit_width_cm   1.59   1.55 \n11 min_fruit_width_cm       1.48   1.36 \n12 max_fruit_width_cm       2.13   2.09 \n\n\n\nWe use map_df() to compute the mean and standard deviation for each numeric column, creating a tidy summary of the data.\n\ntidy_summary() from the moderndive package provides a more comprehensive summary, including missing values, and is useful for quick reporting.\n\nBoth methods help identify variables with high variability or missing data, preparing the dataset for further analysis or modeling.\n\n\n\n\n\n# Count how many species use each raw fruit color description\npalms |&gt; \n  filter(!is.na(fruit_color_description_raw)) |&gt; \n  count(fruit_color_description_raw, sort = TRUE)\n\n# A tibble: 769 × 2\n   fruit_color_description_raw     n\n   &lt;chr&gt;                       &lt;int&gt;\n 1 black                         160\n 2 red                           147\n 3 brown                          72\n 4 purple-black                   67\n 5 orange                         51\n 6 yellowish                      40\n 7 orange-red                     36\n 8 yellow                         33\n 9 green                          31\n10 brown to black                 29\n# ℹ 759 more rows\n\n\n\nWe filter out missing values and count how many times each raw fruit color description appears in the dataset.\n\nSorting the results helps highlight the most common color descriptions and identifies patterns or inconsistencies.\n\n\n\n\n\n# Count the number of species associated with each unique fruit shape\npalms |&gt; \n  count(fruit_shape, sort = TRUE) |&gt;\n  filter(!is.na(fruit_shape))\n\n# A tibble: 7 × 2\n  fruit_shape     n\n  &lt;chr&gt;       &lt;int&gt;\n1 ovoid         813\n2 globose       800\n3 elongate      110\n4 ellipsoid      53\n5 pyramidal      12\n6 fusiform        3\n7 rounded         1\n\n\n\nWe count the number of species associated with each unique fruit shape, sorting the results to see the most common shapes.\n\nFiltering out NA values ensures we focus on valid entries, providing a clearer view of the fruit shape distribution.\n\n\nPart 3: Explore Relationships Between Traits\n\n\n\n\n# Check how values are distributed across two traits: stem_armed and conspicuousness\npalms |&gt; count(stem_armed)\n\n# A tibble: 3 × 2\n  stem_armed     n\n  &lt;chr&gt;      &lt;int&gt;\n1 armed       2297\n2 non-armed    205\n3 &lt;NA&gt;          55\n\npalms |&gt; count(conspicuousness)\n\n# A tibble: 3 × 2\n  conspicuousness     n\n  &lt;chr&gt;           &lt;int&gt;\n1 conspicuous       739\n2 cryptic          1060\n3 &lt;NA&gt;              758\n\n\n\n# Identify species that are non-armed and have missing conspicuousness data\nrare_traits &lt;- palms |&gt; \n  filter(stem_armed == \"non-armed\", \n         is.na(conspicuousness)) |&gt;\n  select(spec_name, palm_subfamily, palm_tribe, climbing, stem_armed, \n         conspicuousness)\nrare_traits\n\n# A tibble: 32 × 6\n   spec_name                 palm_subfamily palm_tribe climbing stem_armed conspicuousness\n   &lt;chr&gt;                     &lt;chr&gt;          &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;      &lt;chr&gt;          \n 1 Acrocomia emensis         Arecoideae     Cocoseae   climbing non-armed  &lt;NA&gt;           \n 2 Acrocomia glaucescens     Arecoideae     Cocoseae   climbing non-armed  &lt;NA&gt;           \n 3 Aiphanes graminifolia     Arecoideae     Cocoseae   climbing non-armed  &lt;NA&gt;           \n 4 Aiphanes leiostachys      Arecoideae     Cocoseae   climbing non-armed  &lt;NA&gt;           \n 5 Aiphanes linearis         Arecoideae     Cocoseae   climbing non-armed  &lt;NA&gt;           \n 6 Astrocaryum carnosum      Arecoideae     Cocoseae   climbing non-armed  &lt;NA&gt;           \n 7 Astrocaryum mexicanum     Arecoideae     Cocoseae   climbing non-armed  &lt;NA&gt;           \n 8 Astrocaryum minus         Arecoideae     Cocoseae   climbing non-armed  &lt;NA&gt;           \n 9 Astrocaryum perangustatum Arecoideae     Cocoseae   climbing non-armed  &lt;NA&gt;           \n10 Astrocaryum triandrum     Arecoideae     Cocoseae   climbing non-armed  &lt;NA&gt;           \n# ℹ 22 more rows\n\n\n\n# Count how many species have this rare trait combination\nnrow(rare_traits)\n\n[1] 32\n\n\n\n# Summarize how these rare combinations are distributed by palm subfamily\nrare_traits |&gt; count(palm_subfamily, sort = TRUE)\n\n# A tibble: 2 × 2\n  palm_subfamily     n\n  &lt;chr&gt;          &lt;int&gt;\n1 Calamoideae       20\n2 Arecoideae        12\n\n\n\nWe first check the distribution of values in stem_armed and conspicuousness to understand their patterns.\n\nWe then filter for species that are “non-armed” but have missing conspicuousness data, highlighting rare trait combinations.\n\nFinally, we count how many species match this rare combination and summarize its distribution across palm subfamilies, revealing potential data gaps or unusual evolutionary traits.\n\n\n\n\n\n# Compare stem diameter distributions between different growth forms (erect vs. not)\npalms |&gt; filter(!is.na(max_stem_dia_cm)) |&gt;\n  ggplot(aes(x = erect, y = max_stem_dia_cm)) +\n  geom_boxplot() +\n  labs(title = \"Stem Diameter by Erect Growth Form\")\n\n\n\n\n\nWe use a boxplot to compare stem diameter distributions between “erect” and “non-erect” growth forms.\n\nThe plot shows medians and variability, helping identify whether growth form correlates with stem thickness.\n\nThis visualization is useful for understanding structural adaptations related to plant morphology.\n\n\n\n\n\n# Create an interactive dodged bar chart of fruit shapes by growth form\npalms |&gt;\n  filter(!is.na(fruit_shape), !is.na(erect)) |&gt;\n  count(fruit_shape, erect, sort = TRUE) |&gt;\n  mutate(\n    tooltip = paste0(\n      \"&lt;b&gt;Fruit Shape:&lt;/b&gt; \", fruit_shape,\n      \"&lt;br&gt;&lt;b&gt;Growth Form:&lt;/b&gt; \", erect,\n      \"&lt;br&gt;&lt;b&gt;Species Count:&lt;/b&gt; \", n\n    )\n  ) |&gt;\n  plot_ly(\n    x = ~n,\n    y = ~reorder(fruit_shape, n),\n    color = ~erect,\n    type = \"bar\",\n    orientation = \"h\",\n    text = ~tooltip,\n    hoverinfo = \"text\"\n  ) |&gt;\n  layout(\n    title = \"Distribution of Fruit Shapes by Growth Form\",\n    xaxis = list(title = \"Number of Species\"),\n    yaxis = list(title = \"Fruit Shape\"),\n    barmode = \"group\"  # Dodged bars for comparison\n  )\n\n\n\n\n\n\nWe create an interactive dodged bar chart to compare fruit shapes by growth form, using plot_ly() for interactivity.\n\nBars are grouped side-by-side (barmode = \"group\") to compare the number of species for each fruit shape and growth form.\n\nCustom tooltips display additional information, making the chart more informative when hovering over the bars.\n\n\n\n\n\n# Filter to include only complete cases for the relevant variables\npalms_filtered &lt;- palms |&gt;\n  filter(\n    !is.na(average_fruit_length_cm),\n    !is.na(average_fruit_width_cm),\n    !is.na(palm_subfamily)\n  )\n\n# Create a faceted scatterplot with interactive tooltips\np &lt;- ggplot(palms_filtered, aes(\n  x = average_fruit_length_cm,\n  y = average_fruit_width_cm,\n  text = paste(\n    \"&lt;b&gt;Species:&lt;/b&gt;\", spec_name,\n    \"&lt;br&gt;&lt;b&gt;Length:&lt;/b&gt;\", round(average_fruit_length_cm, 2), \"cm\",\n    \"&lt;br&gt;&lt;b&gt;Width:&lt;/b&gt;\", round(average_fruit_width_cm, 2), \"cm\",\n    \"&lt;br&gt;&lt;b&gt;Subfamily:&lt;/b&gt;\", palm_subfamily\n  )\n)) +\n  geom_point(alpha = 0.4, color = \"darkgreen\", size = 2) +\n  facet_wrap(~ palm_subfamily) +\n  labs(\n    title = \"Fruit Length vs. Width by Palm Subfamily\",\n    x = \"Average Fruit Length (cm)\",\n    y = \"Average Fruit Width (cm)\"\n  ) +\n  theme_minimal()\n\n# Convert to interactive\nggplotly(p, tooltip = \"text\")\n\n\n\n\n\n\nWe create a faceted scatterplot to compare fruit length vs. width, with separate plots for each palm subfamily.\n\nTooltips display detailed species-level information, including fruit dimensions and subfamily.\n\nFaceting allows for easy comparison of how fruit dimensions vary across subfamilies, while interactivity enhances data exploration.\n\n\n\n\n\n# Filter for complete data in height, fruit size, and armament\npalms_box &lt;- palms |&gt;\n  filter(\n    !is.na(max_stem_height_m),\n    !is.na(fruit_size_categorical),\n    !is.na(is_armed)\n  )\n\n# Create boxplots grouped by fruit size and dodged by armament status\np &lt;- ggplot(palms_box, aes(\n  x = fruit_size_categorical,\n  y = max_stem_height_m,\n  fill = is_armed\n)) +\n  geom_boxplot(\n    outlier.alpha = 0.3,\n    width = 0.6\n  ) +\n  labs(\n    title = \"Stem Height by Fruit Size and Armament\",\n    x = \"Fruit Size Category\",\n    y = \"Max Stem Height (m)\",\n    fill = \"Is Armed?\"\n  ) +\n  theme_minimal()\n\n# View static version — interactive version misaligns dodges\np\n\n\n\n\n\nThe boxplot compares stem height across different fruit size categories, grouped by whether the plant is armed or not.\n\ngeom_boxplot() visualizes distributions with outliers, while fill = is_armed colors the boxes by armament status.\n\nThe static version provides a clear view, but interactive versions may misalign the dodged bars.\n\n\n\n\n\n# Interactive boxplot showing blade length across fruit conspicuousness groups\npalms |&gt;\n  filter(!is.na(max_blade_length_m), !is.na(conspicuousness)) |&gt;\n  plot_ly(\n    x = ~conspicuousness,\n    y = ~max_blade_length_m,\n    type = \"box\",\n    color = ~conspicuousness,\n    boxpoints = \"outliers\",\n    text = ~paste(\"&lt;b&gt;Species:&lt;/b&gt;\", spec_name),\n    hoverinfo = \"text\"\n  ) |&gt;\n  layout(\n    title = \"Blade Length by Fruit Conspicuousness\",\n    xaxis = list(title = \"Fruit Conspicuousness\"),\n    yaxis = list(title = \"Max Blade Length (m)\")\n  )\n\nWarning in RColorBrewer::brewer.pal(N, \"Set2\"): minimal value for n is 3, returning requested palette with 3 different levels\nWarning in RColorBrewer::brewer.pal(N, \"Set2\"): minimal value for n is 3, returning requested palette with 3 different levels\n\n\n\n\n\n\n\nThe interactive boxplot compares blade length across different levels of fruit conspicuousness, with outliers highlighted.\n\nSpecies names are displayed in tooltips, allowing users to explore individual data points.\n\nThis visualization helps identify variations and outliers in leaf length related to fruit visibility traits.\n\n\n\n\n\n# Horizontal bar chart of the 10 most frequent fruit color labels\npalms |&gt;\n  filter(!is.na(main_fruit_colors)) |&gt;\n  count(main_fruit_colors, sort = TRUE) |&gt;\n  slice_max(n, n = 10) |&gt;\n  mutate(label = paste0(n, \" species\")) |&gt;\n  plot_ly(\n    y = ~reorder(main_fruit_colors, n),\n    x = ~n,\n    type = \"bar\",\n    hoverinfo = ~label,\n    orientation = \"h\",\n    marker = list(color = \"purple\")\n  ) |&gt;\n  layout(\n    title = \"Top 10 Most Common Fruit Colors\",\n    xaxis = list(title = \"Number of Species\"),\n    yaxis = list(title = \"Fruit Color\")\n  )\n\n\n\n\n\n\nThe interactive bar chart displays the top 10 most common fruit colors, with bars ordered by frequency.\n\nHovering over the bars shows a custom tooltip with the number of species for each fruit color.\n\nThis visualization helps identify the most prevalent fruit colors, which may offer insights into visual patterns or ecological traits.\n\n\nWell done! Best wishes on your continued learning journey with R and data science. Remember, the key to honing these skills is practice and exploration. Don’t hesitate to revisit these concepts and apply them to your own projects. Happy coding!"
  },
  {
    "objectID": "answers/day1_walkthrough_answers.html",
    "href": "answers/day1_walkthrough_answers.html",
    "title": "Exploratory Data Analysis in R with the tidyverse",
    "section": "",
    "text": "# Create a vector of package names needed for this course\npackages &lt;- c(\n  \"moderndive\",          # For tidyverse-based data analysis tools and datasets\n  \"fivethirtyeight\",     # Contains curated datasets from FiveThirtyEight.com\n  \"knitr\",               # For formatting outputs and rendering R Markdown documents\n  \"janitor\",             # For cleaning data and column names easily\n  \"plotly\",              # For creating interactive visualizations\n  \"dplyr\",               # For data wrangling: filter(), mutate(), summarize(), etc.\n  \"ggplot2\",             # For static data visualizations using the grammar of graphics\n  \"tidyr\",               # For tidying and reshaping data\n  \"stringr\",             # For working with strings using consistent functions\n  \"forcats\",             # For working with factors (especially useful with categorical variables)\n  \"lubridate\",           # For working with date and time data\n  \"purrr\")               # For functional programming tools to iterate and map over data\n\n# Install all the packages listed above from CRAN using a reliable mirror\ninstall.packages(packages, repos = \"https://cran.rstudio.com\")\n\n# Alternative: You could install a bundled version of these packages using the tidyverse meta-package\n# packages_revised &lt;- c(\n#   \"moderndive\", \"fivethirtyeight\", \"knitr\", \"janitor\", \"plotly\", \n#   \"tidyverse\")  # This includes ggplot2, dplyr, tidyr, stringr, forcats, purrr, etc.\n\n# install.packages(packages_revised, repos = \"https://cran.rstudio.com\")\n\n# Install the azflights24 package from GitHub (not available on CRAN)\ninstall.packages(\"remotes\")  # Make sure the remotes package is available\nremotes::install_github(\"moderndive/azflights24\")  # Install from GitHub directly\n\n\nWe start by setting up our tools—installing packages that support different parts of data analysis.\n\nPackages like dplyr, tidyr, ggplot2, and plotly help us explore, clean, and visualize data.\n\nstringr and lubridate are for handling text and dates, which are common in real-world datasets.\n\njanitor is great for quickly cleaning messy column names and summarizing categorical data.\n\nmoderndive and fivethirtyeight offer built-in datasets and helper functions for EDA practice.\n\nknitr helps us format and output our work, especially when using R Markdown.\n\nWe also install azflights24 from GitHub to explore real-world flight data later in the course.\n\n\n\n\n\n# Load packages we will need\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(ggplot2)\nlibrary(moderndive)\n\n# I'll try to be explicit with using :: as we get started though so\n# you know which package includes the function used.\n\n# Load the spotify_by_genre dataset from the moderndive package\ndata(\"spotify_by_genre\", package = \"moderndive\")\n\n\nWe load core data analysis tools like dplyr for wrangling and ggplot2 for plotting, which are part of the tidyverse.\n\nThe spotify_by_genre dataset from the moderndive package gives us a real-world music dataset with numeric, categorical, and text features to explore.\n\n\n\nThis dataset contains information on 6,000 Spotify tracks, each categorized into one of six genres: country, deep-house, dubstep, hip-hop, metal, and rock. It combines audio feature metrics, track metadata, and a popularity indicator, offering a rich foundation for analyzing music trends, exploring genre-specific characteristics, and building predictive models for track popularity.\n\n\n\n\n21 variables including:\nMetadata: track_id, artists, album_name, track_name, track_genre\nPopularity: popularity (0–100) and a binary label popular_or_not (≥50 considered “popular”)\nAudio Features: danceability, energy, acousticness, valence, etc. (scaled 0–1)\nMusical Structure: tempo, key, mode, time_signature\nTrack Attributes: explicit (logical), duration_ms, loudness, speechiness\n\n\n\n\nData was collected using the Spotify Web API, which provides access to comprehensive track-level metadata and audio analysis.\n\n\n\n\n\n# View the structure of the dataset including variable types and example values\ndplyr::glimpse(spotify_by_genre)\n\nRows: 6,000\nColumns: 21\n$ track_id         &lt;chr&gt; \"2wrJq5XKLnmhRXHIAf9xBa\", \"6AHJTA1BN7ePfChCwqph3z\", \"5eUtyONoPyfZYGrFHmZzlc\", \"1e3QZ42GsP8cTy…\n$ artists          &lt;chr&gt; \"Dan + Shay;Justin Bieber\", \"Luke Bryan\", \"Thomas Rhett\", \"Zach Bryan\", \"Zach Bryan\", \"Zach B…\n$ album_name       &lt;chr&gt; \"10,000 Hours (with Justin Bieber)\", \"Country USA\", \"Mientras hago aromaterapia\", \"New Countr…\n$ track_name       &lt;chr&gt; \"10,000 Hours (with Justin Bieber)\", \"Country On\", \"Die A Happy Man\", \"Something in the Orang…\n$ popularity       &lt;dbl&gt; 78, 0, 1, 3, 4, 4, 2, 2, 1, 2, 1, 0, 8, 0, 0, 2, 3, 1, 5, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 1, 2,…\n$ duration_ms      &lt;dbl&gt; 167693, 236455, 228320, 228013, 228013, 228013, 228013, 228013, 228013, 225560, 228013, 22801…\n$ explicit         &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FA…\n$ danceability     &lt;dbl&gt; 0.654, 0.520, 0.590, 0.369, 0.369, 0.369, 0.369, 0.369, 0.369, 0.644, 0.369, 0.369, 0.464, 0.…\n$ energy           &lt;dbl&gt; 0.630, 0.751, 0.389, 0.192, 0.192, 0.192, 0.192, 0.192, 0.192, 0.904, 0.192, 0.192, 0.755, 0.…\n$ key              &lt;dbl&gt; 10, 5, 2, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 1, 8, 4, 8, 0, 3, 4, 11, 4, 8, 8, 4, 4, 4, 8, 9…\n$ loudness         &lt;dbl&gt; -4.644, -5.064, -9.245, -12.151, -12.151, -12.151, -12.151, -12.151, -12.151, -4.532, -12.151…\n$ mode             &lt;dbl&gt; 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, …\n$ speechiness      &lt;dbl&gt; 0.0259, 0.0551, 0.0387, 0.0400, 0.0400, 0.0400, 0.0400, 0.0400, 0.0400, 0.0464, 0.0400, 0.040…\n$ acousticness     &lt;dbl&gt; 0.15300, 0.17100, 0.41100, 0.55500, 0.55500, 0.55500, 0.55500, 0.55500, 0.55500, 0.02950, 0.5…\n$ instrumentalness &lt;dbl&gt; 0.00e+00, 7.40e-06, 1.48e-06, 8.35e-06, 8.35e-06, 8.35e-06, 8.35e-06, 8.35e-06, 8.35e-06, 0.0…\n$ liveness         &lt;dbl&gt; 0.1110, 0.0624, 0.1170, 0.0954, 0.0954, 0.0954, 0.0954, 0.0954, 0.0954, 0.0834, 0.0954, 0.095…\n$ valence          &lt;dbl&gt; 0.430, 0.519, 0.389, 0.148, 0.148, 0.148, 0.148, 0.148, 0.148, 0.672, 0.148, 0.148, 0.449, 0.…\n$ tempo            &lt;dbl&gt; 89.991, 156.044, 166.055, 175.212, 175.212, 175.212, 175.212, 175.212, 175.212, 105.969, 175.…\n$ time_signature   &lt;dbl&gt; 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 3, 3, 4, 3, 3, 4, 4, 3, 4, 4, 4, 3, 3, 3, 4, 4, 3, 4, 3, 4, 4, …\n$ track_genre      &lt;chr&gt; \"country\", \"country\", \"country\", \"country\", \"country\", \"country\", \"country\", \"country\", \"coun…\n$ popular_or_not   &lt;chr&gt; \"popular\", \"not popular\", \"not popular\", \"not popular\", \"not popular\", \"not popular\", \"not po…\n\n\n\n# Open the dataset in a spreadsheet-style viewer (interactive, only works in RStudio)\nView(spotify_by_genre)\n\n\nglimpse() gives a quick overview of the dataset’s structure, helping us see column types and example values at a glance.\n\nUsing View() in RStudio opens the dataset in a scrollable spreadsheet format, making it easier to explore variable names and spot early patterns.\n\nKey variables for analysis include popularity, track_genre, and features like danceability, energy, and explicit, which offer a mix of numeric and categorical data.\n\n\n\n\n\n# Remove duplicate songs based on the track_name column\n# .keep_all = TRUE keeps the first full row for each unique track_name\nspotify &lt;- spotify_by_genre |&gt;\n  dplyr::distinct(track_name, .keep_all = TRUE)\n\n# View the resulting cleaned dataset\nspotify\n\n# A tibble: 4,311 × 21\n   track_id       artists album_name track_name popularity duration_ms explicit danceability energy   key loudness  mode\n   &lt;chr&gt;          &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;       &lt;dbl&gt; &lt;lgl&gt;           &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1 2wrJq5XKLnmhR… Dan + … 10,000 Ho… 10,000 Ho…         78      167693 FALSE           0.654  0.63     10    -4.64     1\n 2 6AHJTA1BN7ePf… Luke B… Country U… Country On          0      236455 FALSE           0.52   0.751     5    -5.06     1\n 3 5eUtyONoPyfZY… Thomas… Mientras … Die A Hap…          1      228320 FALSE           0.59   0.389     2    -9.24     1\n 4 1e3QZ42GsP8cT… Zach B… New Count… Something…          3      228013 FALSE           0.369  0.192     4   -12.2      0\n 5 43WFp6WBAvNgc… Luke B… Tailgate … Country G…          2      225560 FALSE           0.644  0.904     2    -4.53     1\n 6 16LAkUOZbmqdH… Thomas… Sad Count… Slow Down…          8      216764 FALSE           0.464  0.755     4    -5.71     1\n 7 6rfDtM5aHbsaL… Florid… Sad Count… Stay                2      200426 FALSE           0.493  0.931     1    -2.99     1\n 8 24NRxtqD6oySj… Zach B… Country C… Oklahoma …          3      211739 FALSE           0.544  0.573     8    -5.69     1\n 9 3opqy7HYeNHQa… Thomas… Tailgate … Put It On…          0      184800 FALSE           0.554  0.757     0    -4.30     1\n10 66ERrn57fmkbO… Zach B… rainy day… November …          2      243709 FALSE           0.429  0.197     3    -9.80     1\n# ℹ 4,301 more rows\n# ℹ 9 more variables: speechiness &lt;dbl&gt;, acousticness &lt;dbl&gt;, instrumentalness &lt;dbl&gt;, liveness &lt;dbl&gt;, valence &lt;dbl&gt;,\n#   tempo &lt;dbl&gt;, time_signature &lt;dbl&gt;, track_genre &lt;chr&gt;, popular_or_not &lt;chr&gt;\n\n\n\nWe use distinct() to remove duplicate songs based on track_name, keeping only the first full row for each unique title.\nThis step helps prevent repeated entries from biasing our analysis and ensures each song is counted only once.\n\n\n\n\n\n# Set a random seed so results are reproducible\nset.seed(2025)\n\n# Take a random sample of 10 rows from the full dataset\nspotify |&gt;\n  dplyr::slice_sample(n = 10)\n\n# A tibble: 10 × 21\n   track_id       artists album_name track_name popularity duration_ms explicit danceability energy   key loudness  mode\n   &lt;chr&gt;          &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;       &lt;dbl&gt; &lt;lgl&gt;           &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1 0HJ7K7uauPS05… CALVO;… Let Me Lo… Let Me Lo…         57      160748 FALSE           0.406  0.88      5    -5.56     1\n 2 1G09oEhz0Tye3… KDrew;… Prism      Prism              48      165882 FALSE           0.561  0.847     3    -5.03     0\n 3 0DRMigVA7KEsu… Hunter… Chillin' … You Shoul…          0      176552 FALSE           0.609  0.66      6    -5.66     1\n 4 2qZBjaOuBM8M8… ILLENI… Top of th… Story of …          0      240608 FALSE           0.537  0.884     0    -4.09     0\n 5 0HGpVO2aqh9Da… Faith … Finest Co… Like We N…          0      257693 FALSE           0.494  0.467     2    -8.18     1\n 6 61bUwAYTGluUH… Embody  I Miss You I Miss You         48      176000 FALSE           0.702  0.828     0    -3.07     1\n 7 71BwuaJ5VjGx9… The Ki… Home For … Don't Sho…          0      245106 FALSE           0.588  0.847     8    -4.16     1\n 8 2VTtxoSgxXQS7… WE ARE… DUALITY    Sad Story          41      183111 FALSE           0.499  0.587     7    -5.91     0\n 9 0apCPw4wHWMtW… Whales… High       High               47      184258 FALSE           0.616  0.643     6    -5.86     0\n10 20hTmPgYgVWwt… Tyler … Bottles a… Silence            42      125413 FALSE           0.502  0.301     7   -12.5      1\n# ℹ 9 more variables: speechiness &lt;dbl&gt;, acousticness &lt;dbl&gt;, instrumentalness &lt;dbl&gt;, liveness &lt;dbl&gt;, valence &lt;dbl&gt;,\n#   tempo &lt;dbl&gt;, time_signature &lt;dbl&gt;, track_genre &lt;chr&gt;, popular_or_not &lt;chr&gt;\n\n\n\n# Take a random sample of 10 rows but focus only on selected columns\nspotify |&gt;\n  dplyr::select(track_name, artists, track_genre, popularity) |&gt;\n  dplyr::slice_sample(n = 10)\n\n# A tibble: 10 × 4\n   track_name                               artists                                            track_genre popularity\n   &lt;chr&gt;                                    &lt;chr&gt;                                              &lt;chr&gt;            &lt;dbl&gt;\n 1 \"Take on Me\"                             a-ha                                               rock                85\n 2 \"Dawood\"                                 Sidhu Moose Wala                                   hip-hop             63\n 3 \"Tere Naal Nachna (From \\\"Nawabzaade\\\")\" Badshah;Sunanda Sharma                             hip-hop             60\n 4 \"Paper Thin - Headhunterz Remix\"         ILLENIUM;Tom DeLonge;Angels & Airwaves;Headhunterz dubstep             57\n 5 \"More\"                                   Jan Blomqvist;Elena Pitoulis                       deep-house          62\n 6 \"The Fight Song\"                         Marilyn Manson                                     metal                1\n 7 \"Summertime Sadness\"                     Y.V.E. 48                                          deep-house           0\n 8 \"Dracula\"                                King                                               hip-hop             56\n 9 \"THATS WHAT I WANT\"                      Lil Nas X                                          hip-hop             87\n10 \"No More Sorrow\"                         Linkin Park                                        metal               48\n\n\n\nWe use slice_sample() to view a random subset of songs, which helps us get a quick feel for the dataset’s content.\n\nSetting a seed ensures the sample is reproducible, which is helpful for teaching or collaboration.\n\nUsing select() lets us narrow down to key columns like song name, artist, genre, and popularity for a more focused look.\n\n\n\n\n\n# Count the number of tracks in each genre and sort from most to least\nspotify |&gt;\n  dplyr::count(track_genre, sort = TRUE)\n\n# A tibble: 6 × 2\n  track_genre     n\n  &lt;chr&gt;       &lt;int&gt;\n1 deep-house    903\n2 dubstep       871\n3 metal         775\n4 hip-hop       714\n5 country       595\n6 rock          453\n\n\n\nWe count how many tracks belong to each genre, which reveals how the dataset is distributed across categories.\n\nSorting by count highlights which genres are most and least represented, helping us spot potential imbalances early in our analysis.\n\n\n\n\n\n# For each column, count how many missing (NA) values there are\nspotify |&gt;\n  dplyr::summarize(across(everything(), ~sum(is.na(.)))) |&gt; \n  dplyr::glimpse()\n\nRows: 1\nColumns: 21\n$ track_id         &lt;int&gt; 0\n$ artists          &lt;int&gt; 0\n$ album_name       &lt;int&gt; 0\n$ track_name       &lt;int&gt; 0\n$ popularity       &lt;int&gt; 0\n$ duration_ms      &lt;int&gt; 0\n$ explicit         &lt;int&gt; 0\n$ danceability     &lt;int&gt; 0\n$ energy           &lt;int&gt; 0\n$ key              &lt;int&gt; 0\n$ loudness         &lt;int&gt; 0\n$ mode             &lt;int&gt; 0\n$ speechiness      &lt;int&gt; 0\n$ acousticness     &lt;int&gt; 0\n$ instrumentalness &lt;int&gt; 0\n$ liveness         &lt;int&gt; 0\n$ valence          &lt;int&gt; 0\n$ tempo            &lt;int&gt; 0\n$ time_signature   &lt;int&gt; 0\n$ track_genre      &lt;int&gt; 0\n$ popular_or_not   &lt;int&gt; 0\n\n\n\nWe check each column for missing values using summarize() and across(), which helps us spot potential issues before analysis.\n\nIdentifying missing data early is essential since it can interfere with visualizations, summaries, or modeling steps later on.\n\n\n\n\n\n# Check the class of the entire dataset (it's a tibble/data frame)\nclass(spotify)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n# Check the class of a specific column: track_genre (should be character or factor)\nclass(spotify$track_genre)\n\n[1] \"character\"\n\n# Check the class of a numeric column: popularity (should be numeric or integer)\nclass(spotify$popularity)\n\n[1] \"numeric\"\n\n# Use purrr::map_dfr() to apply class() to every column and return results as a data frame\npurrr::map_dfr(spotify, class) \n\n# A tibble: 1 × 21\n  track_id  artists   album_name track_name popularity duration_ms explicit danceability energy  key     loudness mode  \n  &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;        &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;    &lt;chr&gt; \n1 character character character  character  numeric    numeric     logical  numeric      numeric numeric numeric  numer…\n# ℹ 9 more variables: speechiness &lt;chr&gt;, acousticness &lt;chr&gt;, instrumentalness &lt;chr&gt;, liveness &lt;chr&gt;, valence &lt;chr&gt;,\n#   tempo &lt;chr&gt;, time_signature &lt;chr&gt;, track_genre &lt;chr&gt;, popular_or_not &lt;chr&gt;\n\n# Glimpse the result for a readable, wide-format view of column types\npurrr::map_dfr(spotify, class) |&gt; \n  dplyr::glimpse()\n\nRows: 1\nColumns: 21\n$ track_id         &lt;chr&gt; \"character\"\n$ artists          &lt;chr&gt; \"character\"\n$ album_name       &lt;chr&gt; \"character\"\n$ track_name       &lt;chr&gt; \"character\"\n$ popularity       &lt;chr&gt; \"numeric\"\n$ duration_ms      &lt;chr&gt; \"numeric\"\n$ explicit         &lt;chr&gt; \"logical\"\n$ danceability     &lt;chr&gt; \"numeric\"\n$ energy           &lt;chr&gt; \"numeric\"\n$ key              &lt;chr&gt; \"numeric\"\n$ loudness         &lt;chr&gt; \"numeric\"\n$ mode             &lt;chr&gt; \"numeric\"\n$ speechiness      &lt;chr&gt; \"numeric\"\n$ acousticness     &lt;chr&gt; \"numeric\"\n$ instrumentalness &lt;chr&gt; \"numeric\"\n$ liveness         &lt;chr&gt; \"numeric\"\n$ valence          &lt;chr&gt; \"numeric\"\n$ tempo            &lt;chr&gt; \"numeric\"\n$ time_signature   &lt;chr&gt; \"numeric\"\n$ track_genre      &lt;chr&gt; \"character\"\n$ popular_or_not   &lt;chr&gt; \"character\"\n\n\n\nWe use class() to identify the type of the dataset and specific columns, such as track_genre and popularity.\n\nThis helps us confirm whether a column is numeric, character, factor, or another type.\n\nclass(spotify) tells us that the dataset is stored as a tibble/data frame.\n\nChecking individual columns like track_genre and popularity helps us know how R will treat them in summaries and plots.\n\npurrr::map_dfr() applies class() to every column and returns the results in a tidy format.\n\nUnderstanding variable types is critical because it guides how we clean, summarize, visualize, and model the data. (Here’s a mind map to help you get started with basic types if needed.)\n\n\n\n\n\n# Use dplyr to compute common summary statistics for the popularity column\nspotify |&gt;\n  dplyr::summarize(\n    avg_popularity = mean(popularity),         # Mean (average) popularity\n    median_popularity = median(popularity),    # Median popularity\n    sd_popularity = sd(popularity)             # Standard deviation of popularity\n  )\n\n# A tibble: 1 × 3\n  avg_popularity median_popularity sd_popularity\n           &lt;dbl&gt;             &lt;dbl&gt;         &lt;dbl&gt;\n1           41.7                48          26.3\n\n# Use moderndive's tidy_summary() to get a full summary of one or more columns\nspotify |&gt; \n  moderndive::tidy_summary(columns = popularity)\n\n# A tibble: 1 × 11\n  column         n group type      min    Q1  mean median    Q3   max    sd\n  &lt;chr&gt;      &lt;int&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 popularity  4311 &lt;NA&gt;  numeric     0    22  41.7     48    61    99  26.3\n\n\n\nWe calculate summary statistics like mean, median, and standard deviation to understand the center and spread of the popularity variable.\n\nThe mean gives the average popularity, while the median shows the midpoint, and the standard deviation tells us how much scores vary.\n\nsummarize() is a flexible way to compute custom statistics for any variable.\n\ntidy_summary() from the moderndive package provides a full summary in one step, including min, max, and quartiles.\n\nUsing both methods together gives a quick yet detailed picture of a variable’s distribution.\n\nThese summaries help us assess whether the data is skewed, spread out, or centered around a typical value.\n\n\n\n\n\n# Create a histogram to visualize the distribution of track popularity scores\nggplot(data = spotify, aes(x = popularity)) +\n  geom_histogram(binwidth = 5, fill = \"steelblue\", color = \"black\") +\n  labs(title = \"Distribution of Track Popularity\", \n       x = \"Popularity Score\", \n       y = \"Count\")\n\n\n\n\n\nWe use a histogram to explore how the popularity scores are distributed across all tracks.\n\nbinwidth = 5 groups scores into intervals of 5, making it easier to see patterns and trends.\n\nMost bars show how many songs fall within each popularity range, helping us spot common and rare values.\n\nThe visualization helps us check for skew—whether most songs are clustered toward high or low popularity.\n\nIt also makes it easier to spot outliers or unusual peaks in the data.\n\nThis plot gives us a solid starting point for understanding overall patterns before diving into comparisons or models.\n\n\n\n\n\n(1.1) Why is Exploratory Data Analysis (EDA) considered a crucial first step in any data science project?\nA. It allows you to train models more quickly.\nB. It helps reveal patterns, identify data issues, and guide analysis decisions.\nC. It replaces the need for data cleaning by automating it.\nD. It transforms all variables into numeric format for modeling.\n\n(1.2) What is the role of the distinct() function in preparing your data?\nA. It filters out rows with missing values.\nB. It removes duplicate rows based on selected columns.\nC. It transforms all character variables into factors.\nD. It visualizes the distribution of numeric variables.\n\n(1.3) What does the spotify_by_genre dataset contain?\nA. Only audio features from 6,000 classical music tracks\nB. Survey results about Spotify users’ listening habits\nC. Metadata and audio features of 6,000 songs across six genres\nD. Real-time streaming counts of trending tracks globally\n\n(1.4) Which function is best used to take a random subset of rows from a dataset?\nA. sample_n()\nB. slice_sample()\nC. randomize()\nD. filter()\n\n(1.5) What is the purpose of using purrr::map_dfr() in this session?\nA. To count the number of missing values in a column\nB. To classify songs into popular and non-popular categories\nC. To apply a function across all columns and return the results in a single data frame\nD. To create visualizations for each genre using ggplot2\n\n\n\n\n(1.1) Why is Exploratory Data Analysis (EDA) considered a crucial first step in any data science project?\nCorrect Answer:\nB. It helps reveal patterns, identify data issues, and guide analysis decisions.\nExplanation:\nEDA helps uncover structure, detect errors, and build intuition about the dataset before modeling or advanced analysis.\n\n(1.2) What is the role of the distinct() function in preparing your data?\nCorrect Answer:\nB. It removes duplicate rows based on selected columns.\nExplanation:\nUsing distinct() ensures you’re not analyzing repeated entries, which could bias your results.\n\n(1.3) What does the spotify_by_genre dataset contain?\nCorrect Answer:\nC. Metadata and audio features of 6,000 songs across six genres\nExplanation:\nThis dataset combines categorical and numeric variables useful for EDA, such as genre, popularity, danceability, and more.\n\n(1.4) Which function is best used to take a random subset of rows from a dataset?\nCorrect Answer:\nB. slice_sample()\nExplanation:\nslice_sample() provides a random selection of rows, which is useful for quick spot-checks or previews of the data.\n\n(1.5) What is the purpose of using purrr::map_dfr() in this session?\nCorrect Answer:\nC. To apply a function across all columns and return the results in a single data frame\nExplanation:\nThis function was used to inspect the class of each column by mapping class() over the dataset and combining the results row-wise.\n\n\n\n\n\n\n\n\n# Select a subset of columns and rename track_genre to genre\n# Then take a random sample of 20 rows to explore\nspotify |&gt;\n  select(track_name, artists, genre = track_genre, popularity, energy, \n         danceability) |&gt; \n  slice_sample(n = 20)\n\n# A tibble: 20 × 6\n   track_name                                                               artists genre popularity energy danceability\n   &lt;chr&gt;                                                                    &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;        &lt;dbl&gt;\n 1 Somewhere That I Belong                                                  Fairla… dubs…          0  0.911        0.532\n 2 Don't Worry My Love                                                      Kaivon  dubs…         55  0.804        0.511\n 3 Falling to Pieces                                                        Faith … metal         41  0.919        0.545\n 4 In Your Eyes (feat. Alida) - LUM!X Remix                                 Robin … deep…         54  0.777        0.692\n 5 Baanina Haniyu                                                           Raghu … rock          47  0.384        0.484\n 6 Bella Luna                                                               Jason … rock           1  0.454        0.755\n 7 If the World Was Ending                                                  Hannah… coun…         49  0.399        0.492\n 8 Hanji Hanji                                                              Amrit … hip-…         63  0.553        0.871\n 9 Wolf Totem                                                               The HU  metal         61  0.718        0.557\n10 An Old Fashioned Love Song - Single Version                              Three … coun…          0  0.555        0.456\n11 Walk Away (feat. Kaptan)                                                 LVNDSC… deep…         45  0.778        0.677\n12 Music Sounds Better with You                                             Alle F… deep…         60  0.912        0.724\n13 Spider                                                                   Said T… dubs…         40  0.619        0.55 \n14 Most Really Pretty Girls Have Pretty Ugly Feet                           HNNY    deep…         57  0.449        0.929\n15 Elevator (Lift Me Up) - Jerry Ropero Tech Boom Mix                       Todd T… deep…          0  0.698        0.798\n16 Message In A Bottle - Remastered 2003                                    The Po… rock           3  0.808        0.568\n17 Forgotten                                                                Linkin… metal         61  0.947        0.615\n18 Good Things Fall Apart vs. Sad Songs (With Said The Sky feat. Annika We… ILLENI… dubs…         59  0.555        0.563\n19 Figure.09                                                                Linkin… metal         60  0.951        0.518\n20 Count On Me                                                              Hoglan… deep…         49  0.852        0.396\n\n\n\n# Filter for only songs with popularity greater than 80\n# Select only key identifying columns, randomly sample 20, then arrange by popularity (descending)\nspotify |&gt;\n  filter(popularity &gt; 80) |&gt;\n  select(track_name, artists, popularity) |&gt; \n  slice_sample(n = 20) |&gt; \n  arrange(desc(popularity))\n\n# A tibble: 20 × 3\n   track_name                                             artists                     popularity\n   &lt;chr&gt;                                                  &lt;chr&gt;                            &lt;dbl&gt;\n 1 I Ain't Worried                                        OneRepublic                         96\n 2 Hold Me Closer                                         Elton John;Britney Spears           89\n 3 STAY (with Justin Bieber)                              The Kid LAROI;Justin Bieber         89\n 4 Bones                                                  Imagine Dragons                     89\n 5 No Role Modelz                                         J. Cole                             88\n 6 Without Me                                             Eminem                              88\n 7 You Proof                                              Morgan Wallen                       86\n 8 Running Up That Hill (A Deal With God) - 2018 Remaster Kate Bush                           85\n 9 Counting Stars                                         OneRepublic                         83\n10 Safe And Sound                                         Capital Cities                      83\n11 Fuck Love (feat. Trippie Redd)                         XXXTENTACION;Trippie Redd           83\n12 MONTERO (Call Me By Your Name)                         Lil Nas X                           83\n13 Unforgettable                                          French Montana;Swae Lee             82\n14 All I Want                                             Kodaline                            82\n15 Prom Queen                                             Beach Bunny                         82\n16 Not Afraid                                             Eminem                              81\n17 Tu Aake Dekhle                                         King                                81\n18 Whiskey Glasses                                        Morgan Wallen                       81\n19 Tennessee Whiskey                                      Chris Stapleton                     81\n20 Heathens                                               Twenty One Pilots                   81\n\n\n\nWe use select() to focus on specific columns, helping us reduce clutter and explore only what’s relevant.\n\nRenaming track_genre to genre makes the column name shorter and easier to work with.\n\nslice_sample() lets us inspect a small, random subset of rows, which is useful for getting a feel for the data.\n\nfilter(popularity &gt; 80) narrows the data to only include high-popularity songs, helping us analyze standout tracks.\n\narrange(desc(popularity)) sorts songs from most to least popular, making top-performing tracks easy to spot.\n\nThese wrangling steps are key in EDA for zooming in on trends, patterns, or interesting subsets of your data.\n\n\n\n\n\n# Create a new logical column to flag songs with both high energy and high danceability\nspotify |&gt;\n  mutate(high_energy_dance = energy &gt; 0.7 & danceability &gt; 0.7) |&gt;\n  count(high_energy_dance)\n\n# A tibble: 2 × 2\n  high_energy_dance     n\n  &lt;lgl&gt;             &lt;int&gt;\n1 FALSE              3666\n2 TRUE                645\n\n\n\n# Create a new categorical column for popularity levels using case_when\n# Then count how many songs fall into each category\nspotify |&gt;\n  mutate(popularity_group = case_when(\n    popularity &gt;= 75 ~ \"high\",\n    popularity &gt;= 40 ~ \"medium\",\n    TRUE ~ \"low\"\n  )) |&gt;\n  count(popularity_group)\n\n# A tibble: 3 × 2\n  popularity_group     n\n  &lt;chr&gt;            &lt;int&gt;\n1 high               295\n2 low               1407\n3 medium            2609\n\n\n\nWe use mutate() to create new columns based on conditions, helping us flag or group rows for deeper analysis.\n\nThe high_energy_dance column identifies songs that are both energetic and danceable by checking if both values exceed 0.7.\n\nCounting TRUE and FALSE values helps us see how common that combination is in the dataset.\n\ncase_when() allows us to group numeric values (like popularity) into meaningful categories such as “low,” “medium,” and “high.”\n\nCreating categorical groupings from continuous variables simplifies comparisons and improves visualizations.\n\nThese custom columns make it easier to answer specific questions and communicate insights clearly.\n\n\n\n\n\n# Create a new column that calculates the ratio of energy to danceability\nspotify |&gt;\n  mutate(energy_dance_ratio = energy / danceability) |&gt;\n  select(track_name, artists, track_genre, energy, \n         danceability, energy_dance_ratio) |&gt; \n  slice_sample(n = 20)\n\n# A tibble: 20 × 6\n   track_name                                    artists              track_genre energy danceability energy_dance_ratio\n   &lt;chr&gt;                                         &lt;chr&gt;                &lt;chr&gt;        &lt;dbl&gt;        &lt;dbl&gt;              &lt;dbl&gt;\n 1 \"Ele Se Foi\"                                  Oficina G3           metal        0.595        0.551              1.08 \n 2 \"Freewheelin'\"                                Jack Wins;Caitlyn S… deep-house   0.822        0.598              1.37 \n 3 \"In Pieces\"                                   Linkin Park          metal        0.886        0.508              1.74 \n 4 \"Sete\"                                        BLOND:ISH;Francis M… deep-house   0.827        0.736              1.12 \n 5 \"Meus Passos\"                                 Oficina G3           metal        0.941        0.521              1.81 \n 6 \"Kudi Nu Nachne De (From \\\"Angrezi Medium\\\")\" Vishal Dadlani;Sach… hip-hop      0.688        0.834              0.825\n 7 \"Senjitaley\"                                  Anirudh Ravichander  hip-hop      0.941        0.655              1.44 \n 8 \"Welcome to the Family\"                       Avenged Sevenfold    metal        0.946        0.567              1.67 \n 9 \"Didn't I\"                                    OneRepublic          rock         0.61         0.611              0.998\n10 \"Laal Bindi\"                                  Akull                hip-hop      0.599        0.746              0.803\n11 \"It’s All on U\"                               ILLENIUM;Liam O'Don… dubstep      0.82         0.498              1.65 \n12 \"Man! I Feel Like A Woman!\"                   Shania Twain         country      0.889        0.654              1.36 \n13 \"Never Loved You At All\"                      Parker McCollum      country      0.891        0.552              1.61 \n14 \"Uchiyaan Dewaraan\"                           Bilal Saeed;Momina … hip-hop      0.577        0.428              1.35 \n15 \"Can't Stop Lovin' You\"                       Van Halen            metal        0.898        0.592              1.52 \n16 \"Hope For The Future\"                         Bastille             rock         0.411        0.449              0.915\n17 \"Call on Me (Ryan Riback Remix)\"              Starley;Ryan Riback  deep-house   0.839        0.67               1.25 \n18 \"Sidhu Son\"                                   Sidhu Moose Wala     hip-hop      0.732        0.571              1.28 \n19 \"Wasted Years - 2015 Remaster\"                Iron Maiden          metal        0.959        0.314              3.05 \n20 \"B2B\"                                         James Hype;Tita Lau  deep-house   0.956        0.799              1.20 \n\n\n\n# Add a logical column that flags songs with tempo greater than 140 as high tempo\n# Then count how many songs fall into each category\nspotify |&gt;\n  mutate(high_tempo = tempo &gt; 140) |&gt;\n  count(high_tempo)\n\n# A tibble: 2 × 2\n  high_tempo     n\n  &lt;lgl&gt;      &lt;int&gt;\n1 FALSE       3079\n2 TRUE        1232\n\n\n\nWe use mutate() to create new variables that help us explore relationships between existing features.\n\nThe energy_dance_ratio compares energy and danceability, offering a new way to assess the feel of a track.\n\nViewing a sample of songs with this new ratio lets us explore how it varies across genres and artists.\n\nCreating a high_tempo flag helps us classify songs based on a threshold (tempo &gt; 140 BPM).\n\nLogical columns like high_tempo are useful for quick counts, filtering, or subgroup analysis.\n\nAdding derived variables allows us to go beyond surface-level data and uncover more meaningful patterns.\n\n\n\n\n\n# Group the data by genre and calculate the average energy for each group\nspotify |&gt;\n  group_by(track_genre) |&gt;\n  summarize(mean_energy = mean(energy, na.rm = TRUE))\n\n# A tibble: 6 × 2\n  track_genre mean_energy\n  &lt;chr&gt;             &lt;dbl&gt;\n1 country           0.628\n2 deep-house        0.742\n3 dubstep           0.763\n4 hip-hop           0.691\n5 metal             0.839\n6 rock              0.661\n\n\n\n# Count how many songs are popular or not within each genre\nspotify |&gt;\n  count(track_genre, popular_or_not)\n\n# A tibble: 12 × 3\n   track_genre popular_or_not     n\n   &lt;chr&gt;       &lt;chr&gt;          &lt;int&gt;\n 1 country     not popular      462\n 2 country     popular          133\n 3 deep-house  not popular      412\n 4 deep-house  popular          491\n 5 dubstep     not popular      691\n 6 dubstep     popular          180\n 7 hip-hop     not popular      170\n 8 hip-hop     popular          544\n 9 metal       not popular      302\n10 metal       popular          473\n11 rock        not popular      288\n12 rock        popular          165\n\n\n\nWe use group_by() and summarize() to calculate the average energy level within each music genre.\n\nThis helps us compare genres to see which ones tend to have more energetic tracks.\n\nThe na.rm = TRUE argument ensures missing values don’t interfere with our summary statistics.\n\nCounting by both track_genre and popular_or_not gives us a two-way frequency table.\n\nThis count reveals how popularity is distributed across different genres.\n\nGrouped summaries are essential for spotting trends, differences, and relationships across categories.\n\n\n\n\n\n# Reshape selected audio features from wide format to long format\n# This creates a 'feature' column for the variable name and a 'value' column for its value\nspotify |&gt;\n  select(track_name, energy, danceability, acousticness) |&gt;\n  tidyr::pivot_longer(cols = c(energy, danceability, acousticness),\n                      names_to = \"feature\",\n                      values_to = \"value\")\n\n# A tibble: 12,933 × 3\n   track_name                        feature      value\n   &lt;chr&gt;                             &lt;chr&gt;        &lt;dbl&gt;\n 1 10,000 Hours (with Justin Bieber) energy       0.63 \n 2 10,000 Hours (with Justin Bieber) danceability 0.654\n 3 10,000 Hours (with Justin Bieber) acousticness 0.153\n 4 Country On                        energy       0.751\n 5 Country On                        danceability 0.52 \n 6 Country On                        acousticness 0.171\n 7 Die A Happy Man                   energy       0.389\n 8 Die A Happy Man                   danceability 0.59 \n 9 Die A Happy Man                   acousticness 0.411\n10 Something in the Orange           energy       0.192\n# ℹ 12,923 more rows\n\n\n\nWe use pivot_longer() to reshape the dataset from wide format to long format.\n\nThree audio features—energy, danceability, and acousticness—are transformed into a single feature column.\n\nTheir corresponding values are placed into a new value column, making the data more compact and tidy.\n\nThis format is ideal for creating faceted plots or grouped summaries across multiple features.\n\nIt allows us to treat multiple columns as levels of a single variable, which simplifies plotting and analysis.\n\nReshaping data like this is a powerful technique for scaling EDA workflows.\n\n\n\n\n\n# Count the number of songs in each genre by popularity category\n# Then reshape the data to have separate columns for 'popular' and 'not popular'\nspotify |&gt;\n  count(track_genre, popular_or_not) |&gt;\n  tidyr::pivot_wider(names_from = popular_or_not, values_from = n)\n\n# A tibble: 6 × 3\n  track_genre `not popular` popular\n  &lt;chr&gt;               &lt;int&gt;   &lt;int&gt;\n1 country               462     133\n2 deep-house            412     491\n3 dubstep               691     180\n4 hip-hop               170     544\n5 metal                 302     473\n6 rock                  288     165\n\n\n\nWe start by counting how many songs are labeled as popular or not popular within each genre.\n\nThis gives us a tall (long) format table showing counts for each genre-popularity combination.\n\nUsing pivot_wider(), we reshape the data to create separate columns for “popular” and “not popular”.\n\nEach genre becomes a row with its respective counts shown side by side.\n\nThis wide format makes it easier to compare popularity across genres at a glance.\n\nIt’s useful for tables, reports, or bar plots that benefit from side-by-side values.\n\n\n\n\n\n# Find the maximum number of artists in any single song by counting semicolons\n# Add 1 since semicolons separate the names (n artists = n semicolons + 1)\nmax_artists &lt;- spotify |&gt;\n  filter(stringr::str_detect(artists, \";\")) |&gt;\n  mutate(n_artists = stringr::str_count(artists, \";\") + 1) |&gt;\n  pull(n_artists) |&gt;\n  max(na.rm = TRUE)\n\n\n# Identify the song that has the most artists\nspotify |&gt;\n  mutate(n_artists = stringr::str_count(artists, \";\") + 1) |&gt;\n  arrange(desc(n_artists)) |&gt;\n  slice(1) |&gt;\n  select(track_name, artists, n_artists)\n\n# A tibble: 1 × 3\n  track_name     artists                                                                                       n_artists\n  &lt;chr&gt;          &lt;chr&gt;                                                                                             &lt;dbl&gt;\n1 Punjabi Mashup Arjun;Badshah;Bohemia;Diljit Dosanjh;Fateh;Gippy Grewal;Girik Aman;Gupz Sehra;Guru Randhawa;…        31\n\n\n\n# Create a vector of new column names based on the maximum number of artists found\nartist_cols &lt;- paste0(\"artist_\", seq_len(max_artists))\n\n\n# Use separate() to split the 'artists' column into multiple artist columns\n# Use fill = \"right\" to handle cases with fewer than max_artists\n# Keep the original 'artists' column for reference\nsplit_by_artists &lt;- spotify |&gt;\n  filter(stringr::str_detect(artists, \";\")) |&gt;\n  tidyr::separate(artists, into = artist_cols, sep = \";\", fill = \"right\", remove = FALSE) |&gt;\n  select(track_name, artists, track_genre, all_of(artist_cols))\nsplit_by_artists\n\n# A tibble: 1,704 × 34\n   track_name       artists track_genre artist_1 artist_2 artist_3 artist_4 artist_5 artist_6 artist_7 artist_8 artist_9\n   &lt;chr&gt;            &lt;chr&gt;   &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   \n 1 10,000 Hours (w… Dan + … country     Dan + S… Justin … &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n 2 Put It On Ice    Thomas… country     Thomas … HARDY    &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n 3 Playing With Fi… Thomas… country     Thomas … Daniell… &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n 4 10,000 Hours     Dan + … country     Dan + S… Justin … &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n 5 Buy Dirt         Jordan… country     Jordan … Luke Br… &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n 6 Tequila - Mushr… Dan + … country     Dan + S… Mushroo… &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n 7 Silent Night     Cody J… country     Cody Jo… Clara J… Brandi … Cori Jo… &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n 8 Little Drummer … Carrie… country     Carrie … Isaiah … &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n 9 Hallelujah       Carrie… country     Carrie … John Le… &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n10 Happy Anywhere   Blake … country     Blake S… Gwen St… &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n# ℹ 1,694 more rows\n# ℹ 22 more variables: artist_10 &lt;chr&gt;, artist_11 &lt;chr&gt;, artist_12 &lt;chr&gt;, artist_13 &lt;chr&gt;, artist_14 &lt;chr&gt;,\n#   artist_15 &lt;chr&gt;, artist_16 &lt;chr&gt;, artist_17 &lt;chr&gt;, artist_18 &lt;chr&gt;, artist_19 &lt;chr&gt;, artist_20 &lt;chr&gt;,\n#   artist_21 &lt;chr&gt;, artist_22 &lt;chr&gt;, artist_23 &lt;chr&gt;, artist_24 &lt;chr&gt;, artist_25 &lt;chr&gt;, artist_26 &lt;chr&gt;,\n#   artist_27 &lt;chr&gt;, artist_28 &lt;chr&gt;, artist_29 &lt;chr&gt;, artist_30 &lt;chr&gt;, artist_31 &lt;chr&gt;\n\n\n\n# Summarize how many multi-artist songs exist by genre\nsplit_by_artists |&gt;\n  group_by(track_genre) |&gt;\n  summarize(n_artists = sum(!is.na(artist_1))) |&gt;\n  arrange(desc(n_artists))\n\n# A tibble: 6 × 2\n  track_genre n_artists\n  &lt;chr&gt;           &lt;int&gt;\n1 dubstep           616\n2 deep-house        562\n3 hip-hop           364\n4 country            74\n5 rock               59\n6 metal              29\n\n\n\nWe detect songs with multiple artists by counting semicolons in the artists column, then find the maximum number of artists in any song.\n\nslice(1) after sorting lets us identify the specific track with the most artists listed.\n\nWe use paste0() to dynamically generate new column names like artist_1, artist_2, etc., based on the max number found.\n\nThe separate() function splits the artists column into multiple new columns for easier analysis of individual contributors.\n\nfill = \"right\" ensures shorter artist lists don’t break the structure—missing entries are filled with NA.\n\nWe summarize how many multi-artist songs exist per genre to examine which genres tend to have more collaborations.\n\n\n\n\n\n# Combine the track_name and artists columns into a single column called track_artist\n# Use \" by \" as the separator between the song title and the artist(s)\nspotify |&gt;\n  tidyr::unite(\"track_artist\", track_name, artists, sep = \" by \") |&gt;\n  select(track_artist, popularity) |&gt;\n  slice_sample(n = 20) |&gt; \n  arrange(desc(popularity))\n\n# A tibble: 20 × 2\n   track_artist                                                 popularity\n   &lt;chr&gt;                                                             &lt;dbl&gt;\n 1 Do I Wanna Know? by Arctic Monkeys                                   88\n 2 Hurt by Johnny Cash                                                  74\n 3 Born To Be Wild by Steppenwolf                                       73\n 4 Nightmare by Avenged Sevenfold                                       72\n 5 Hurricane by I Prevail                                               68\n 6 House Of The Rising Sun by Nora Van Elken                            61\n 7 Sidhu Son by Sidhu Moose Wala                                        59\n 8 Baitikochi Chuste by Anirudh Ravichander                             56\n 9 Promises by NERO                                                     56\n10 Beautiful by Deepend;Griff Clawson                                   56\n11 Empty Floor by Jan Blomqvist                                         53\n12 Empty Love by Lulleaux;Kid Princess                                  51\n13 Promises - Skrillex & Nero Remix by NERO                             44\n14 Stomach It by Crywolf;EDEN                                           44\n15 Forgive Me Now by BH                                                 42\n16 Ammunition by Krewella                                               38\n17 Xelela Abazali by Deep Sen;KingTalkzin;KnightSA;Russell Zuma         29\n18 Like a Movie feat. Haexxa by Alfred Heinrichs;Haexxa                 26\n19 O Holy Night by Lauren Alaina                                         0\n20 Christmas Makes Me Cry by Kacey Musgraves                             0\n\n\n\nWe use unite() to merge track_name and artists into a single column called track_artist for clearer labeling.\n\nThe separator \" by \" makes the new string easy to read and interpret, like a song title in a playlist.\n\nSelecting just track_artist and popularity keeps the focus on key information.\n\nRandomly sampling 20 rows gives us a manageable view of the data.\n\nSorting by descending popularity helps us quickly identify top-performing tracks.\n\nThis technique is useful for creating labels in plots or tables that clearly identify each observation.\n\n\n\n\n\n# Simulate messy column names by renaming clean ones to include emojis, symbols, and inconsistent formatting\nspotify_unruly &lt;- spotify |&gt;\n  rename(\n    `Track Name 🎵` = track_name,\n    `ARTISTS (main + featured)` = artists,\n    `Album-Name___v2` = album_name,\n    `DURATION (ms)` = duration_ms,\n    `Popularity SCORE (%)` = popularity,\n    `track genre!` = track_genre,\n    `Explicit?` = explicit,\n    `IS_IT_POPULAR????` = popular_or_not\n  ) |&gt; \n  mutate(valence = NA_real_)  # Add an entirely empty column to test janitor functions\n\n# Check the column names and dimensions before cleaning\nnames(spotify_unruly)\n\n [1] \"track_id\"                  \"ARTISTS (main + featured)\" \"Album-Name___v2\"           \"Track Name 🎵\"            \n [5] \"Popularity SCORE (%)\"      \"DURATION (ms)\"             \"Explicit?\"                 \"danceability\"             \n [9] \"energy\"                    \"key\"                       \"loudness\"                  \"mode\"                     \n[13] \"speechiness\"               \"acousticness\"              \"instrumentalness\"          \"liveness\"                 \n[17] \"valence\"                   \"tempo\"                     \"time_signature\"            \"track genre!\"             \n[21] \"IS_IT_POPULAR????\"        \n\ndim(spotify_unruly)\n\n[1] 4311   21\n\n\n\n# Clean the messy column names: make them lowercase, snake_case, and remove special characters\n# Remove any completely empty columns\nspotify_cleaned_some &lt;- spotify_unruly |&gt;\n  janitor::clean_names() |&gt;\n  janitor::remove_empty(which = \"cols\")\n\n# Check the new cleaned column names and dimensions\nnames(spotify_cleaned_some)\n\n [1] \"track_id\"                 \"artists_main_featured\"    \"album_name_v2\"            \"track_name\"              \n [5] \"popularity_score_percent\" \"duration_ms\"              \"explicit\"                 \"danceability\"            \n [9] \"energy\"                   \"key\"                      \"loudness\"                 \"mode\"                    \n[13] \"speechiness\"              \"acousticness\"             \"instrumentalness\"         \"liveness\"                \n[17] \"tempo\"                    \"time_signature\"           \"track_genre\"              \"is_it_popular\"           \n\ndim(spotify_cleaned_some)\n\n[1] 4311   20\n\n\n\nWe simulate messy data by renaming columns with emojis, inconsistent formatting, and symbols to reflect real-world issues.\n\nclean_names() from the janitor package standardizes column names to lowercase snake_case, making them easier to reference in code.\n\nThis function also removes special characters and spaces, which can cause problems in analysis scripts.\n\nWe add a fully missing column to test how remove_empty() eliminates columns with only NA values.\n\nAfter cleaning, column names become consistent and safe for programming, reducing the chance of errors.\n\nThese cleaning steps are essential when preparing raw or imported data for analysis.\n\n\n\n\n\n# Move the track_genre column to appear right before track_id\n# Recode popular_or_not into a new column popular_recoded using case_match\n# Place the new column directly after track_genre\nspotify |&gt;\n  relocate(track_genre, .before = track_id) |&gt;\n  mutate(popular_recoded = case_match(popular_or_not, \n                                      \"popular\" ~ \"yes\", \n                                      \"not popular\" ~ \"no\"),\n         .after = track_genre) |&gt; \n  select(1:6) |&gt; \n  slice_head(n = 10)\n\n# A tibble: 10 × 6\n   track_genre popular_recoded track_id               artists                  album_name                     track_name\n   &lt;chr&gt;       &lt;chr&gt;           &lt;chr&gt;                  &lt;chr&gt;                    &lt;chr&gt;                          &lt;chr&gt;     \n 1 country     yes             2wrJq5XKLnmhRXHIAf9xBa Dan + Shay;Justin Bieber 10,000 Hours (with Justin Bie… 10,000 Ho…\n 2 country     no              6AHJTA1BN7ePfChCwqph3z Luke Bryan               Country USA                    Country On\n 3 country     no              5eUtyONoPyfZYGrFHmZzlc Thomas Rhett             Mientras hago aromaterapia     Die A Hap…\n 4 country     no              1e3QZ42GsP8cTy5uQ0G7J3 Zach Bryan               New Country                    Something…\n 5 country     no              43WFp6WBAvNgc7iaFFEUJp Luke Bryan               Tailgate Country               Country G…\n 6 country     no              16LAkUOZbmqdHgicUsHY1S Thomas Rhett             Sad Country Songs              Slow Down…\n 7 country     no              6rfDtM5aHbsaLGAUxfIgpN Florida Georgia Line     Sad Country Songs              Stay      \n 8 country     no              24NRxtqD6oySjRnAZxa4Hf Zach Bryan               Country Car Hits               Oklahoma …\n 9 country     no              3opqy7HYeNHQaUwYVS7cLo Thomas Rhett;HARDY       Tailgate Country               Put It On…\n10 country     no              66ERrn57fmkbOq9zhELGPv Zach Bryan               rainy day indie                November …\n\n\n\nWe use relocate() to reposition track_genre before track_id, improving the layout for easier scanning.\n\nmutate() with case_match() creates a new column that recodes popular_or_not into simpler “yes” or “no” values.\n\nThe .after = track_genre argument places the new popular_recoded column right after track_genre for better grouping.\n\nUsing select(1:6) limits our view to the first six columns, which helps keep previews focused and readable.\n\nslice_head(n = 10) displays the first 10 rows of the updated dataset for a quick check.\n\nThese layout and recoding steps make the dataset more intuitive and better organized for analysis or reporting.\n\n\n\n\n\n(2.1) What is the purpose of using filter() in data wrangling with dplyr?\nA. To remove missing values from all columns.\nB. To select specific columns by name.\nC. To remove duplicate rows from a dataset.\nD. To return only rows that meet a certain condition.\n\n(2.2) What is the result of using the mutate() function in a dplyr pipeline?\nA. It permanently deletes rows that contain NA values.\nB. It creates new columns or modifies existing ones.\nC. It filters the dataset by logical conditions.\nD. It combines multiple columns into one.\n\n(2.3) What does the following code do in the context of the spotify_by_genre dataset?\nspotify |&gt;\n  mutate(high_acoustic_mellow = acousticness &gt; 0.8 & valence &lt; 0.4)\nA. It filters the dataset to only include mellow and acoustic songs.\nB. It creates a new variable indicating whether a song is both highly acoustic and low in valence.\nC. It summarizes acousticness and valence for mellow songs.\nD. It creates a histogram of acousticness for songs with low valence.\n\n(2.4) What is the effect of pivot_longer() on a dataset?\nA. It removes NA values from multiple columns.\nB. It splits a character column into multiple columns.\nC. It summarizes grouped values into wider format tables.\nD. It transforms columns into key-value pairs, increasing the number of rows.\n\n(2.5) Why is janitor::clean_names() helpful in the data cleaning process?\nA. It changes all character variables to numeric format.\nB. It fills in missing values in your dataset.\nC. It converts messy column names to consistent, lowercase, snake_case format.\nD. It rearranges the rows of the dataset based on alphabetical order.\n\n\n\n\n(2.1) What is the purpose of using filter() in data wrangling with dplyr?\nCorrect Answer:\nD. To return only rows that meet a certain condition.\nExplanation:\nfilter() keeps rows based on a logical condition, helping narrow your dataset to just what you’re interested in analyzing.\n\n(2.2) What is the result of using the mutate() function in a dplyr pipeline?\nCorrect Answer:\nB. It creates new columns or modifies existing ones.\nExplanation:\nmutate() allows you to add or alter columns using logic, math, or transformations, making it essential for feature engineering.\n\n(2.3) What does the following code do in the context of the spotify_by_genre dataset?\nspotify |&gt;\n  mutate(high_acoustic_mellow = acousticness &gt; 0.8 & valence &lt; 0.4)\nCorrect Answer:\nB. It creates a new variable indicating whether a song is both highly acoustic and low in valence.\nExplanation:\nThis code adds a new logical column called high_acoustic_mellow, which is TRUE if the song’s acousticness is greater than 0.8 and its valence is less than 0.4—capturing songs that are both acoustic and emotionally mellow.\n\n(2.4) What is the effect of pivot_longer() on a dataset?\nCorrect Answer:\nD. It transforms columns into key-value pairs, increasing the number of rows.\nExplanation:\npivot_longer() reshapes wide data into long format, useful for tidy plotting and modeling.\n\n(2.5) Why is janitor::clean_names() helpful in the data cleaning process?\nCorrect Answer:\nC. It converts messy column names to consistent, lowercase, snake_case format.\nExplanation:\nThis function simplifies variable names by removing special characters and spaces, making them easier to reference in code.\n\n\n\n\n\n\n\n\nlibrary(stringr)\n\n# Create a new column that counts the number of characters in each track name\n# Then display the track names sorted by length in descending order\nspotify |&gt;\n  mutate(name_length = str_length(track_name)) |&gt;\n  select(track_name, name_length) |&gt;\n  arrange(desc(name_length)) \n\n# A tibble: 4,311 × 2\n   track_name                                                                                  name_length\n   &lt;chr&gt;                                                                                             &lt;int&gt;\n 1 \"A Thousand Years (feat. Steve Kazee) - Pt. 2; The Twilight Saga: Breaking Dawn Soundtrack\"          89\n 2 \"Where Are You Christmas - From \\\"Dr. Seuss' How The Grinch Stole Christmas\\\" Soundtrack\"            85\n 3 \"I Put A Spell On You (Fifty Shades of Grey) - From \\\"Fifty Shades Of Grey\\\" Soundtrack\"             84\n 4 \"Last One Standing (feat. Polo G, Mozzy & Eminem) - From Venom: Let There Be Carnage\"                83\n 5 \"Double Talkin' Jive - Live In Las Vegas, Thomas & Mack Center - January 25, 1992\"                   80\n 6 \"Rockin' Around The Christmas Tree - From The Kacey Musgraves Christmas Show\"                        75\n 7 \"Good Things Fall Apart vs. Sad Songs (With Said The Sky feat. Annika Wells)\"                        75\n 8 \"I'll Be Home For Christmas - From The Kacey Musgraves Christmas Show\"                               68\n 9 \"Good Things Fall Apart (with Jon Bellion) [Tiësto's Big Room Remix]\"                                67\n10 \"Sympathy For The Devil - 50th Anniversary Edition / Remastered 2018\"                                67\n# ℹ 4,301 more rows\n\n\n\n# Detect songs where the title includes the word \"love\" (case-insensitive)\n# Use str_to_lower to ensure consistent matching\n(\n  love_songs &lt;- spotify |&gt;\n    filter(str_detect(str_to_lower(track_name), \"love\")) |&gt;\n    select(track_genre, track_name)\n)\n\n# A tibble: 147 × 2\n   track_genre track_name                       \n   &lt;chr&gt;       &lt;chr&gt;                            \n 1 country     I Love My Country                \n 2 country     Fall in Love                     \n 3 country     Never Been in Love               \n 4 country     Don't Fall In Love With A Dreamer\n 5 country     Like We Never Loved at All       \n 6 country     Let's Make Love                  \n 7 country     Drunk on Your Love               \n 8 country     I Love You, I Love You           \n 9 country     You Should Be Loved              \n10 country     Love Will Keep Us Alive          \n# ℹ 137 more rows\n\n\n\n# Count how many \"love\" songs appear in each genre\n# Calculate the percentage of total songs that mention \"love\" for each genre\nlove_songs |&gt;\n  mutate(love = 1) |&gt;\n  group_by(track_genre) |&gt;\n  summarize(n_love = sum(love)) |&gt;\n  ungroup() |&gt;\n  mutate(pct_love = n_love / nrow(spotify) * 100) |&gt;\n  arrange(desc(pct_love))\n\n# A tibble: 6 × 3\n  track_genre n_love pct_love\n  &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;\n1 deep-house      55    1.28 \n2 dubstep         31    0.719\n3 hip-hop         21    0.487\n4 country         20    0.464\n5 metal           11    0.255\n6 rock             9    0.209\n\n\n\nWe use str_length() to measure the number of characters in each song title, helping us identify especially long or short track names.\n\nSorting by name_length reveals songs with the most elaborate titles.\n\nstr_detect() finds tracks that contain the word “love” in the title, using str_to_lower() to ensure case-insensitive matching.\n\nThis lets us explore themes in the data—like how often love appears in song titles.\n\nWe add a flag (love = 1) to count and summarize how many love-themed songs exist in each genre.\n\nCalculating percentages gives insight into which genres most frequently use “love” in their track titles relative to the full dataset.\n\n\n\n\n\n# Remove all parentheses from track names\nspotify |&gt;\n  mutate(track_name_clean = str_remove_all(track_name, \"\\\\(.*?\\\\)\")) |&gt;\n  select(track_name, track_name_clean)\n\n# A tibble: 4,311 × 2\n   track_name                        track_name_clean         \n   &lt;chr&gt;                             &lt;chr&gt;                    \n 1 10,000 Hours (with Justin Bieber) \"10,000 Hours \"          \n 2 Country On                        \"Country On\"             \n 3 Die A Happy Man                   \"Die A Happy Man\"        \n 4 Something in the Orange           \"Something in the Orange\"\n 5 Country Girl (Shake It For Me)    \"Country Girl \"          \n 6 Slow Down Summer                  \"Slow Down Summer\"       \n 7 Stay                              \"Stay\"                   \n 8 Oklahoma Smokeshow                \"Oklahoma Smokeshow\"     \n 9 Put It On Ice                     \"Put It On Ice\"          \n10 November Air                      \"November Air\"           \n# ℹ 4,301 more rows\n\n\n\n# Extract featured artist from parentheses\nspotify |&gt;\n  mutate(featuring = str_extract(\n    track_name, \n    \"(?i)(?&lt;=\\\\()(with|feat\\\\.)[^)]*(?=\\\\))\")) |&gt;\n  select(track_name, featuring) |&gt;\n  mutate(featuring = str_replace_all(featuring, \"with |feat. \", \"\")) |&gt; \n  filter(!is.na(featuring))\n\n# A tibble: 261 × 2\n   track_name                                                  featuring            \n   &lt;chr&gt;                                                       &lt;chr&gt;                \n 1 10,000 Hours (with Justin Bieber)                           Justin Bieber        \n 2 Whiskey Lullaby (feat. Alison Krauss)                       Alison Krauss        \n 3 10,000 Hours (with Justin Bieber) - Piano                   Justin Bieber        \n 4 I Hope (feat. Charlie Puth)                                 Charlie Puth         \n 5 Dance with the Devil (feat. Katie Noel & Chucky V)          Katie Noel & Chucky V\n 6 On Me (feat. Ava Max)                                       Ava Max              \n 7 Take Me Home (with Kane Brown)                              Kane Brown           \n 8 What Ifs (feat. Lauren Alaina)                              Lauren Alaina        \n 9 Trying to Reason With Hurricane Season (with Jimmy Buffett) Jimmy Buffett        \n10 Sugar (feat. Francesco Yates)                               Francesco Yates      \n# ℹ 251 more rows\n\n\n\nWe use str_remove_all() with a non-greedy regex to remove any text in parentheses from song titles, creating a cleaner version of track_name.\n\nThe regex \"\\\\(.*?\\\\)\" ensures only the text inside the first set of parentheses is removed, not everything between the first ( and the last ).\n\nThis cleaning step is useful for removing remix labels or featured artist notes for clearer display or grouping.\n\nIn the second block, we use str_extract() to pull out featured artist names from parentheses that include “with” or “feat.”\n\nThe use of lookarounds (?&lt;=\\\\() and (?=\\\\)) ensures we extract the content inside the parentheses without including the parentheses themselves.\n\nAfter extracting, we strip out “with” or “feat.” using str_replace_all() to leave just the artist names, which can be helpful for analyzing collaborations.\n\n\n\n\n\n# Use separate_rows() to split multiple artists into individual rows\n# This turns collaborations into separate entries for each artist\n(\n  artists_long &lt;- spotify |&gt;\n    tidyr::separate_rows(artists, sep = \";\")\n)\n\n# A tibble: 6,642 × 21\n   track_id       artists album_name track_name popularity duration_ms explicit danceability energy   key loudness  mode\n   &lt;chr&gt;          &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;       &lt;dbl&gt; &lt;lgl&gt;           &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1 2wrJq5XKLnmhR… Dan + … 10,000 Ho… 10,000 Ho…         78      167693 FALSE           0.654  0.63     10    -4.64     1\n 2 2wrJq5XKLnmhR… Justin… 10,000 Ho… 10,000 Ho…         78      167693 FALSE           0.654  0.63     10    -4.64     1\n 3 6AHJTA1BN7ePf… Luke B… Country U… Country On          0      236455 FALSE           0.52   0.751     5    -5.06     1\n 4 5eUtyONoPyfZY… Thomas… Mientras … Die A Hap…          1      228320 FALSE           0.59   0.389     2    -9.24     1\n 5 1e3QZ42GsP8cT… Zach B… New Count… Something…          3      228013 FALSE           0.369  0.192     4   -12.2      0\n 6 43WFp6WBAvNgc… Luke B… Tailgate … Country G…          2      225560 FALSE           0.644  0.904     2    -4.53     1\n 7 16LAkUOZbmqdH… Thomas… Sad Count… Slow Down…          8      216764 FALSE           0.464  0.755     4    -5.71     1\n 8 6rfDtM5aHbsaL… Florid… Sad Count… Stay                2      200426 FALSE           0.493  0.931     1    -2.99     1\n 9 24NRxtqD6oySj… Zach B… Country C… Oklahoma …          3      211739 FALSE           0.544  0.573     8    -5.69     1\n10 3opqy7HYeNHQa… Thomas… Tailgate … Put It On…          0      184800 FALSE           0.554  0.757     0    -4.30     1\n# ℹ 6,632 more rows\n# ℹ 9 more variables: speechiness &lt;dbl&gt;, acousticness &lt;dbl&gt;, instrumentalness &lt;dbl&gt;, liveness &lt;dbl&gt;, valence &lt;dbl&gt;,\n#   tempo &lt;dbl&gt;, time_signature &lt;dbl&gt;, track_genre &lt;chr&gt;, popular_or_not &lt;chr&gt;\n\n\n\n# Count how many times each artist appears across all tracks\n# Artists involved in collaborations will be counted multiple times\nartists_long |&gt; \n  count(artists, sort = TRUE)\n\n# A tibble: 2,688 × 2\n   artists                   n\n   &lt;chr&gt;                 &lt;int&gt;\n 1 ILLENIUM                 91\n 2 Anirudh Ravichander      79\n 3 Sidhu Moose Wala         63\n 4 Linkin Park              59\n 5 SLANDER                  35\n 6 Seven Lions              34\n 7 Tritonal                 29\n 8 AP Dhillon               28\n 9 Red Hot Chili Peppers    28\n10 Porter Robinson          27\n# ℹ 2,678 more rows\n\n\n\nWe use separate_rows() to split the artists column into multiple rows whenever songs have more than one artist listed.\n\nThis transformation puts the data in long format, allowing each artist to be analyzed individually—even in collaborations.\n\nAll other columns (e.g., track name, genre) are repeated for each artist, preserving context.\n\nUsing count() on the artists column gives us a ranked list of how frequently each artist appears.\n\nThis method captures both solo tracks and group efforts, giving a more complete view of artist participation.\n\nIt’s especially useful for identifying the most active or featured artists in the dataset.\n\n\n\n\n\n# Use fct_lump() to group all but the top 3 most common genres into \"Other\"\nspotify |&gt;\n  mutate(track_genre = forcats::fct_lump(track_genre, n = 3)) |&gt;\n  count(track_genre)\n\n# A tibble: 4 × 2\n  track_genre     n\n  &lt;fct&gt;       &lt;int&gt;\n1 deep-house    903\n2 dubstep       871\n3 metal         775\n4 Other        1762\n\n\n\n# View the current counts for popular_or_not to check the ordering and distribution\nspotify |&gt; \n  count(popular_or_not)\n\n# A tibble: 2 × 2\n  popular_or_not     n\n  &lt;chr&gt;          &lt;int&gt;\n1 not popular     2325\n2 popular         1986\n\n\n\n# Reorder factor levels for popular_or_not so that \"popular\" appears first\nspotify |&gt;\n  mutate(popular_or_not = forcats::fct_relevel(popular_or_not, \"popular\")) |&gt;\n  count(popular_or_not)\n\n# A tibble: 2 × 2\n  popular_or_not     n\n  &lt;fct&gt;          &lt;int&gt;\n1 popular         1986\n2 not popular     2325\n\n\n\nWe use fct_lump() to combine less common genres into an “Other” category, keeping the focus on the top 3 most frequent ones.\n\nThis simplifies plots and summaries by reducing clutter from too many categories.\n\ncount(popular_or_not) helps us inspect the current distribution and order of that categorical variable.\n\nWe use fct_relevel() to move \"popular\" to the first position, which can influence plotting order and improve clarity.\n\nReordering factor levels helps ensure categories appear in a meaningful or intuitive order in visualizations.\n\nThese factor tools from the forcats package are essential for making categorical variables more analysis- and presentation-friendly.\n\n\n\n\n\nlibrary(forcats)\n\n# Create a new column that counts the number of words in each track name\nspotify |&gt;\n  mutate(\n    word_count = str_count(track_name, \"\\\\w+\")\n  ) |&gt;\n  \n  # Group by genre and calculate the average word count per genre\n  group_by(track_genre) |&gt;\n  summarize(\n    avg_words = mean(word_count, na.rm = TRUE),\n    .groups = \"drop\"\n  ) |&gt;\n  \n  # Reorder genres based on average word count for clearer plotting\n  mutate(track_genre = fct_reorder(track_genre, avg_words)) |&gt;\n  \n  # Create a horizontal bar chart of average word counts by genre\n  ggplot(aes(x = track_genre, y = avg_words)) +\n  geom_col(fill = \"steelblue\") +\n  \n  # Add the rounded average word count at the end of each bar\n  geom_text(aes(label = round(avg_words, 1)), hjust = -0.1, size = 3.5) +\n  \n  # Flip coordinates so genres appear on the y-axis\n  coord_flip() +\n  \n  # Add labels and title\n  labs(\n    title = \"Average Number of Words in Track Names by Genre\",\n    x = \"Track Genre\",\n    y = \"Average Word Count\"\n  ) +\n  \n  # Apply a clean minimal theme\n  theme_minimal()\n\n\n\n\n\nWe use str_count() with the \\\\w+ pattern to count the number of words in each track title.\n\nGrouping by track_genre and calculating the mean gives us the average word count per genre.\n\nfct_reorder() reorders genres based on average word count, improving the readability of the plot.\n\nA horizontal bar chart (geom_col() with coord_flip()) displays genre comparisons clearly.\n\ngeom_text() adds numeric labels to each bar, making the values easy to interpret at a glance.\n\nThis combines text processing and visualization to uncover stylistic patterns in how songs are titled across genres.\n\n\n\n\n\nlibrary(tidyr)\n\n# Split artists so each appears in their own row (for collaborations)\nspotify |&gt;\n  separate_rows(artists, sep = \";\") |&gt;\n  \n  # Keep only distinct artist–genre pairs\n  distinct(artists, track_genre) |&gt;\n  \n  # Group by artist and filter for those appearing in more than one genre\n  group_by(artists) |&gt;\n  filter(n_distinct(track_genre) &gt; 1) |&gt;\n  \n  # Sort alphabetically and display artist–genre combinations\n  arrange(artists) |&gt;\n  select(artists, track_genre)\n\n# A tibble: 115 × 2\n# Groups:   artists [57]\n   artists           track_genre\n   &lt;chr&gt;             &lt;chr&gt;      \n 1 Alok              dubstep    \n 2 Alok              rock       \n 3 Asking Alexandria dubstep    \n 4 Asking Alexandria metal      \n 5 Atreyu            dubstep    \n 6 Atreyu            metal      \n 7 BANNERS           dubstep    \n 8 BANNERS           rock       \n 9 Billy Ray Cyrus   country    \n10 Billy Ray Cyrus   hip-hop    \n# ℹ 105 more rows\n\n\n\nWe use separate_rows() to split collaborations so each artist appears on their own row.\n\ndistinct() ensures we only keep unique artist–genre pairs, removing duplicates.\n\nGrouping by artist allows us to analyze their genre diversity across tracks.\n\nfilter(n_distinct(track_genre) &gt; 1) identifies artists who appear in more than one genre.\n\nSorting and selecting just artists and track_genre gives a clean view of cross-genre activity.\n\nThis technique highlights artist versatility and reveals patterns of collaboration across genres.\n\n\n\n\n\n# Load the azflights24 and lubridate packages for flight data and date manipulation\nlibrary(azflights24)\nlibrary(lubridate)\n\n\nAttaching package: 'lubridate'\n\n\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n\n# Preview a random sample of flight records\nflights |&gt; \n  slice_sample(n = 30)\n\n# A tibble: 30 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier flight tailnum origin\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt; &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;   &lt;chr&gt; \n 1  2024     5     7     1544           1552        -8     2140           2217       -37 AA         644 N954NN  PHX   \n 2  2024    11    20      732            735        -3      836            840        -4 WN         141 N8759Q  PHX   \n 3  2024    10     7     1330           1335        -5     1649           1651        -2 OO        1316 N732SK  PHX   \n 4  2024     2     8     1710           1712        -2     2331           2359       -28 AA         119 N443AA  PHX   \n 5  2024     5     3     1731           1725         6     1849           1855        -6 WN         878 N436WN  PHX   \n 6  2024    11    27      859            900        -1     1006           1000         6 WN         347 N930WN  PHX   \n 7  2024    11    30     2255           2300        -5     2353           2353         0 OO        1754 N774SK  PHX   \n 8  2024     8    30     1719           1715         4     2122           2120         2 WN         725 N258WN  PHX   \n 9  2024     3     7      953            959        -6     1051           1106       -15 OO        1046 N724EV  PHX   \n10  2024     7    10      839            843        -4     1105           1120       -15 OO        1085 N521SY  PHX   \n# ℹ 20 more rows\n# ℹ 6 more variables: dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n# Create a proper date column by combining year, month, and day\n(\n  flights_fixed &lt;- flights |&gt;\n    mutate(flight_date = make_date(year, month, day)) |&gt;\n    select(flight, origin, dest, carrier, year, month, day, flight_date)\n)\n\n# A tibble: 221,144 × 8\n   flight origin dest  carrier  year month   day flight_date\n    &lt;int&gt; &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;date&gt;     \n 1   1024 PHX    CLT   AA       2024     1     1 2024-01-01 \n 2    643 PHX    EWR   UA       2024     1     1 2024-01-01 \n 3    126 PHX    DCA   AA       2024     1     1 2024-01-01 \n 4   1155 PHX    DFW   F9       2024     1     1 2024-01-01 \n 5   1260 PHX    EWR   NK       2024     1     1 2024-01-01 \n 6    376 PHX    MCO   F9       2024     1     1 2024-01-01 \n 7    152 PHX    ORD   UA       2024     1     1 2024-01-01 \n 8   1379 PHX    ATL   F9       2024     1     1 2024-01-01 \n 9     99 PHX    DEN   WN       2024     1     1 2024-01-01 \n10    410 PHX    SAT   WN       2024     1     1 2024-01-01 \n# ℹ 221,134 more rows\n\n\n\n# Extract the month name (abbreviated) from the flight_date column for PHX-origin flights\nflights |&gt;\n  filter(origin == \"PHX\") |&gt; \n  mutate(\n    flight_date = make_date(year, month, day),\n    month_name = month(flight_date, label = TRUE)\n  ) |&gt;\n  count(month_name)\n\n# A tibble: 12 × 2\n   month_name     n\n   &lt;ord&gt;      &lt;int&gt;\n 1 Jan        15378\n 2 Feb        14823\n 3 Mar        17375\n 4 Apr        16531\n 5 May        16741\n 6 Jun        15326\n 7 Jul        15733\n 8 Aug        15416\n 9 Sep        15081\n10 Oct        16978\n11 Nov        16827\n12 Dec        17342\n\n\n\nWe use make_date() from lubridate to combine year, month, and day into a proper Date column, simplifying date operations.\n\nCreating a flight_date column makes it easier to filter, sort, or extract time-based features.\n\nUsing month(flight_date, label = TRUE) lets us extract readable, abbreviated month names.\n\nFiltering for flights from Phoenix (PHX) helps narrow the focus to a specific origin airport.\n\ncount(month_name) shows the number of flights from PHX by month, revealing potential seasonal trends.\n\nThis workflow highlights how lubridate integrates smoothly with tidyverse tools for effective date manipulation and analysis.\n\n\n\n\n\n\n\n# Filter for flights that originated in PHX\n# Count how many flights went to each destination\n# Reorder destinations so the bars display in order of frequency\nflights |&gt;\n  filter(origin == \"PHX\") |&gt;\n  count(dest) |&gt;\n  mutate(dest = forcats::fct_reorder(dest, n)) |&gt;\n  ggplot(aes(x = dest, y = n)) +\n  geom_col() +\n  coord_flip() +\n  labs(title = \"Number of Flights from PHX to Each Destination\",\n       x = \"Destination\", y = \"Number of Flights\")\n\n\n\n\n\n# Filter for flights from PHX again\n# Group rare destinations with fewer than 1000 flights into an \"Other\" category\n# Reorder factor levels by count and visualize as a bar chart\nflights |&gt;\n  filter(origin == \"PHX\") |&gt;\n  mutate(dest_lumped = forcats::fct_lump_min(\n    dest, min = 1000, other_level = \"Other\")\n  ) |&gt;\n  count(dest_lumped, name = \"n\") |&gt;\n  mutate(dest_lumped = fct_reorder(dest_lumped, n)) |&gt;\n  ggplot(aes(x = dest_lumped, y = n)) +\n  geom_col() +\n  coord_flip() +\n  labs(\n    title = \"Number of Flights from PHX to Each Destination\",\n    x = \"Destination\",\n    y = \"Number of Flights\"\n  )\n\n\n\n\n\n\n\n\n# Reorder track genres by the median popularity of their songs\n# Create a violin plot with quantile lines to show distribution\nspotify |&gt;\n  mutate(track_genre = fct_reorder(track_genre, popularity, .fun = median)) |&gt;\n  ggplot(aes(x = track_genre, y = popularity)) +\n  geom_violin(draw_quantiles = c(0.25, 0.5, 0.75)) +\n  coord_flip()\n\n\n\n\n\nWe use fct_reorder() to sort bars in descending order of flight count, making plots easier to read and interpret.\n\ncoord_flip() rotates the bar chart so destinations appear on the y-axis—ideal for longer text labels.\n\nfct_lump_min() groups destinations with fewer than 1000 flights into an “Other” category, reducing clutter.\n\nThese techniques highlight the most traveled routes from Phoenix while simplifying less important details.\n\nIn the second example, we reorder genres by the median popularity of songs to make genre comparisons more meaningful.\n\nViolin plots with quantile lines reveal the distribution and spread of song popularity within each genre, not just the average.\n\n\n\n\n\n\n# Prepare weather data for PHX and FLG airports during July 2024\n# Bin timestamps into 6-hour intervals, create human-readable labels\nweather_az_binned &lt;- azflights24::weather |&gt; \n  filter(origin %in% c(\"PHX\", \"FLG\")) |&gt; \n  filter(between(time_hour, ymd(\"2024-07-01\"), ymd(\"2024-07-31\"))) |&gt; \n  mutate(\n    time_bin_start = floor_date(time_hour, unit = \"6 hours\"),\n    time_bin_end = time_bin_start + hours(6),\n    label = str_c(\n      wday(time_bin_start, label = TRUE), \", \",\n      month(time_bin_start, label = TRUE), \" \",\n      day(time_bin_start), \" @ \",\n      strftime(time_bin_start, \"%I:%M %p\"), \"–\",\n      strftime(time_bin_end, \"%I:%M %p\")\n    )\n  ) |&gt; \n  group_by(origin, time_bin_start, label) |&gt; \n  summarize(avg_temp = mean(temp, na.rm = TRUE), .groups = \"drop\") |&gt; \n  mutate(\n    tooltip_text = str_c(\n      label, \"\\n\",\n      \"Avg Temp: \", round(avg_temp, 1), \"°F\"\n    )\n  )\n\n\n# Create a ggplot line chart with interactive tooltips using plotly\np &lt;- ggplot(weather_az_binned, aes(x = time_bin_start, y = avg_temp, \n                                   text = tooltip_text, group = origin)) +\n  geom_line(aes(color = origin)) +\n  geom_point(color = \"black\") +\n  labs(\n    title = \"Average Temperature in Phoenix and Flagstaff (6-Hour Intervals) for July 2024\",\n    x = \"July 6-hour Time Bins\",\n    y = \"Avg Temperature (F)\"\n  ) +\n  scale_color_manual(values = c(\"PHX\" = \"red\", \"FLG\" = \"blue\"))\n\n# Render the plot as an interactive Plotly chart with custom tooltips\nplotly::ggplotly(p, tooltip = \"text\")\n\n\n\n\n\n\nWe filter weather data for PHX and FLG airports during July 2024 and group it into 6-hour time bins for clearer trend analysis.\n\nfloor_date() and mutate() help create readable time interval labels, making the timeline easier to interpret.\n\nWe calculate average temperature per airport and time bin using group_by() and summarize().\n\nTooltips are customized using str_c() to show detailed labels when hovering over data points.\n\ngeom_line() creates a line for each airport, and geom_point() adds black markers to highlight individual values.\n\nggplotly() transforms the static plot into an interactive chart, allowing dynamic exploration of temporal weather trends.\n\n\n\n\n\n# Load survey data on weather app preferences from the fivethirtyeight package\ndata(\"weather_check\", package = \"fivethirtyeight\")\n\n# Prepare the data by filtering out missing values\n# Lump less common weather sources into \"Other\"\n# Reorder regions based on frequency of responses\ngrouped_responses &lt;- weather_check |&gt;\n  filter(!is.na(weather_source), !is.na(region)) |&gt;\n  mutate(\n    weather_source = fct_lump(weather_source, n = 4),\n    region = fct_infreq(region)\n  ) |&gt;\n  count(region, weather_source) |&gt;\n  arrange(region, desc(n))\n\n\n# Create a side-by-side bar plot showing weather source preferences by region\nggplot(grouped_responses, aes(x = region, y = n, fill = weather_source)) +\n  geom_col(position = \"dodge\") +\n  coord_flip() +\n  labs(\n    title = \"Weather App Preferences by Region\",\n    x = \"Weather Source\",\n    y = \"Count\"\n  ) +\n  theme_minimal()\n\n\n\n\n\nWe load and clean the weather_check dataset by filtering out missing values for weather_source and region.\n\nfct_lump() groups less common weather apps into an “Other” category to simplify the plot.\n\nfct_infreq() reorders regions by how frequently they appear in the data, improving readability.\n\nWe use count() to tally the number of responses for each combination of region and weather source.\n\nA side-by-side bar plot (geom_col(position = \"dodge\")) compares weather app preferences across regions.\n\ncoord_flip() rotates the chart, making long region names easier to read and the overall plot more user-friendly.\n\n\n\n\n\n(3.1) Why does the regex pattern \"\\\\(.*?\\\\)\" used in str_remove_all() work better than \"\\\\(.*\\\\)\" when cleaning track names?\nA. The .*? forces R to skip anything in parentheses rather than match it.\nB. .*? is a greedy matcher that ensures the longest match possible is removed.\nC. \"\\\\(.*?\\\\)\" only works when the parentheses are numeric, like (1) or (2). D. .*? makes the match non-greedy, stopping at the first closing parenthesis.\n\n(3.2) What does this code return?\nspotify |&gt;\n  separate_rows(artists, sep = \";\") |&gt;\n  distinct(artists, track_genre) |&gt;\n  group_by(artists) |&gt;\n  filter(n_distinct(track_genre) &gt; 1)\nA. It returns artists who appear in more than one track.\nB. It returns tracks that are associated with more than one genre.\nC. It returns genres that feature more than one artist.\nD. It returns artists that appear in more than one genre.\n\n(3.3) What will the following code produce?\nspotify |&gt;\n  mutate(track_name_clean = str_remove_all(track_name, \"\\\\(.*?\\\\)\")) |&gt;\n  select(track_name, track_name_clean)\nA. A data frame with only tracks that contain parentheses in their names\nB. A new column with all track names replaced by text inside parentheses\nC. A new column where all content inside parentheses has been removed from track names\nD. A subset of songs where all punctuation has been stripped from the track name\n\n(3.4) Which of the following best explains the use of fct_lump(track_genre, n = 3)?\nA. It removes the three most frequent levels in the track_genre factor.\nB. It converts the track_genre variable into numeric rank based on popularity.\nC. It keeps only the top three most common genres and lumps the rest into “Other”.\nD. It randomly selects three genres to collapse into one category.\n\n(3.5) What does this ggplot() show?\nspotify |&gt;\n  mutate(track_genre = fct_reorder(track_genre, popularity, .fun = max)) |&gt;\n  ggplot(aes(x = track_genre, y = popularity)) +\n  geom_violin()\nA. A violin plot sorted alphabetically by genre name\nB. A violin plot of genre popularity, with genres ordered by max popularity\nC. A violin plot of max track length across genres\nD. A histogram showing popularity grouped by genre\n\n\n\n\n(3.1) Why does the regex pattern \"\\\\(.*?\\\\)\" used in str_remove_all() work better than \"\\\\(.*\\\\)\" when cleaning track names?\nCorrect Answer:\nD. .*? makes the match non-greedy, stopping at the first closing parenthesis.\nExplanation:\nThe .*? part tells the regex engine to match as little as possible. This avoids removing everything between the first opening and the last closing parenthesis, which .* (greedy) would do.\n\n(3.2) What does this code return?\nCorrect Answer:\nD. It returns artists that appear in more than one genre.\nExplanation:\nThe code first separates artists into rows, then finds unique artist–genre pairs, and filters for those where an artist is associated with more than one genre.\n\n(3.3) What will the following code produce?\nCorrect Answer:\nC. A new column where all content inside parentheses has been removed from track names\nExplanation:\nThe regex removes text (and parentheses themselves) like (Remix) or (feat. Someone) using a non-greedy match. The cleaned result is stored in a new column.\n\n(3.4) Which of the following best explains the use of fct_lump(track_genre, n = 3)?\nCorrect Answer:\nC. It keeps only the top three most common genres and lumps the rest into “Other”.\nExplanation:\nfct_lump() simplifies a categorical variable by collapsing less frequent levels into one “Other” category, keeping only the top n most common.\n\n(3.5) What does this ggplot() show?\nspotify |&gt;\n  mutate(track_genre = fct_reorder(track_genre, popularity, .fun = max)) |&gt;\n  ggplot(aes(x = track_genre, y = popularity)) +\n  geom_violin()\nCorrect Answer:\nB. A violin plot of genre popularity, with genres ordered by max popularity\nExplanation:\nfct_reorder() reorders the factor levels by maximum popularity. The violin plot then visualizes the distribution of popularity for each genre in this new order."
  },
  {
    "objectID": "answers/day1_walkthrough_answers.html#session-1-foundations-of-eda-in-r-with-the-tidyverse",
    "href": "answers/day1_walkthrough_answers.html#session-1-foundations-of-eda-in-r-with-the-tidyverse",
    "title": "Exploratory Data Analysis in R with the tidyverse",
    "section": "",
    "text": "# Create a vector of package names needed for this course\npackages &lt;- c(\n  \"moderndive\",          # For tidyverse-based data analysis tools and datasets\n  \"fivethirtyeight\",     # Contains curated datasets from FiveThirtyEight.com\n  \"knitr\",               # For formatting outputs and rendering R Markdown documents\n  \"janitor\",             # For cleaning data and column names easily\n  \"plotly\",              # For creating interactive visualizations\n  \"dplyr\",               # For data wrangling: filter(), mutate(), summarize(), etc.\n  \"ggplot2\",             # For static data visualizations using the grammar of graphics\n  \"tidyr\",               # For tidying and reshaping data\n  \"stringr\",             # For working with strings using consistent functions\n  \"forcats\",             # For working with factors (especially useful with categorical variables)\n  \"lubridate\",           # For working with date and time data\n  \"purrr\")               # For functional programming tools to iterate and map over data\n\n# Install all the packages listed above from CRAN using a reliable mirror\ninstall.packages(packages, repos = \"https://cran.rstudio.com\")\n\n# Alternative: You could install a bundled version of these packages using the tidyverse meta-package\n# packages_revised &lt;- c(\n#   \"moderndive\", \"fivethirtyeight\", \"knitr\", \"janitor\", \"plotly\", \n#   \"tidyverse\")  # This includes ggplot2, dplyr, tidyr, stringr, forcats, purrr, etc.\n\n# install.packages(packages_revised, repos = \"https://cran.rstudio.com\")\n\n# Install the azflights24 package from GitHub (not available on CRAN)\ninstall.packages(\"remotes\")  # Make sure the remotes package is available\nremotes::install_github(\"moderndive/azflights24\")  # Install from GitHub directly\n\n\nWe start by setting up our tools—installing packages that support different parts of data analysis.\n\nPackages like dplyr, tidyr, ggplot2, and plotly help us explore, clean, and visualize data.\n\nstringr and lubridate are for handling text and dates, which are common in real-world datasets.\n\njanitor is great for quickly cleaning messy column names and summarizing categorical data.\n\nmoderndive and fivethirtyeight offer built-in datasets and helper functions for EDA practice.\n\nknitr helps us format and output our work, especially when using R Markdown.\n\nWe also install azflights24 from GitHub to explore real-world flight data later in the course.\n\n\n\n\n\n# Load packages we will need\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(ggplot2)\nlibrary(moderndive)\n\n# I'll try to be explicit with using :: as we get started though so\n# you know which package includes the function used.\n\n# Load the spotify_by_genre dataset from the moderndive package\ndata(\"spotify_by_genre\", package = \"moderndive\")\n\n\nWe load core data analysis tools like dplyr for wrangling and ggplot2 for plotting, which are part of the tidyverse.\n\nThe spotify_by_genre dataset from the moderndive package gives us a real-world music dataset with numeric, categorical, and text features to explore.\n\n\n\nThis dataset contains information on 6,000 Spotify tracks, each categorized into one of six genres: country, deep-house, dubstep, hip-hop, metal, and rock. It combines audio feature metrics, track metadata, and a popularity indicator, offering a rich foundation for analyzing music trends, exploring genre-specific characteristics, and building predictive models for track popularity.\n\n\n\n\n21 variables including:\nMetadata: track_id, artists, album_name, track_name, track_genre\nPopularity: popularity (0–100) and a binary label popular_or_not (≥50 considered “popular”)\nAudio Features: danceability, energy, acousticness, valence, etc. (scaled 0–1)\nMusical Structure: tempo, key, mode, time_signature\nTrack Attributes: explicit (logical), duration_ms, loudness, speechiness\n\n\n\n\nData was collected using the Spotify Web API, which provides access to comprehensive track-level metadata and audio analysis.\n\n\n\n\n\n# View the structure of the dataset including variable types and example values\ndplyr::glimpse(spotify_by_genre)\n\nRows: 6,000\nColumns: 21\n$ track_id         &lt;chr&gt; \"2wrJq5XKLnmhRXHIAf9xBa\", \"6AHJTA1BN7ePfChCwqph3z\", \"5eUtyONoPyfZYGrFHmZzlc\", \"1e3QZ42GsP8cTy…\n$ artists          &lt;chr&gt; \"Dan + Shay;Justin Bieber\", \"Luke Bryan\", \"Thomas Rhett\", \"Zach Bryan\", \"Zach Bryan\", \"Zach B…\n$ album_name       &lt;chr&gt; \"10,000 Hours (with Justin Bieber)\", \"Country USA\", \"Mientras hago aromaterapia\", \"New Countr…\n$ track_name       &lt;chr&gt; \"10,000 Hours (with Justin Bieber)\", \"Country On\", \"Die A Happy Man\", \"Something in the Orang…\n$ popularity       &lt;dbl&gt; 78, 0, 1, 3, 4, 4, 2, 2, 1, 2, 1, 0, 8, 0, 0, 2, 3, 1, 5, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 1, 2,…\n$ duration_ms      &lt;dbl&gt; 167693, 236455, 228320, 228013, 228013, 228013, 228013, 228013, 228013, 225560, 228013, 22801…\n$ explicit         &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FA…\n$ danceability     &lt;dbl&gt; 0.654, 0.520, 0.590, 0.369, 0.369, 0.369, 0.369, 0.369, 0.369, 0.644, 0.369, 0.369, 0.464, 0.…\n$ energy           &lt;dbl&gt; 0.630, 0.751, 0.389, 0.192, 0.192, 0.192, 0.192, 0.192, 0.192, 0.904, 0.192, 0.192, 0.755, 0.…\n$ key              &lt;dbl&gt; 10, 5, 2, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 1, 8, 4, 8, 0, 3, 4, 11, 4, 8, 8, 4, 4, 4, 8, 9…\n$ loudness         &lt;dbl&gt; -4.644, -5.064, -9.245, -12.151, -12.151, -12.151, -12.151, -12.151, -12.151, -4.532, -12.151…\n$ mode             &lt;dbl&gt; 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, …\n$ speechiness      &lt;dbl&gt; 0.0259, 0.0551, 0.0387, 0.0400, 0.0400, 0.0400, 0.0400, 0.0400, 0.0400, 0.0464, 0.0400, 0.040…\n$ acousticness     &lt;dbl&gt; 0.15300, 0.17100, 0.41100, 0.55500, 0.55500, 0.55500, 0.55500, 0.55500, 0.55500, 0.02950, 0.5…\n$ instrumentalness &lt;dbl&gt; 0.00e+00, 7.40e-06, 1.48e-06, 8.35e-06, 8.35e-06, 8.35e-06, 8.35e-06, 8.35e-06, 8.35e-06, 0.0…\n$ liveness         &lt;dbl&gt; 0.1110, 0.0624, 0.1170, 0.0954, 0.0954, 0.0954, 0.0954, 0.0954, 0.0954, 0.0834, 0.0954, 0.095…\n$ valence          &lt;dbl&gt; 0.430, 0.519, 0.389, 0.148, 0.148, 0.148, 0.148, 0.148, 0.148, 0.672, 0.148, 0.148, 0.449, 0.…\n$ tempo            &lt;dbl&gt; 89.991, 156.044, 166.055, 175.212, 175.212, 175.212, 175.212, 175.212, 175.212, 105.969, 175.…\n$ time_signature   &lt;dbl&gt; 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 3, 3, 4, 3, 3, 4, 4, 3, 4, 4, 4, 3, 3, 3, 4, 4, 3, 4, 3, 4, 4, …\n$ track_genre      &lt;chr&gt; \"country\", \"country\", \"country\", \"country\", \"country\", \"country\", \"country\", \"country\", \"coun…\n$ popular_or_not   &lt;chr&gt; \"popular\", \"not popular\", \"not popular\", \"not popular\", \"not popular\", \"not popular\", \"not po…\n\n\n\n# Open the dataset in a spreadsheet-style viewer (interactive, only works in RStudio)\nView(spotify_by_genre)\n\n\nglimpse() gives a quick overview of the dataset’s structure, helping us see column types and example values at a glance.\n\nUsing View() in RStudio opens the dataset in a scrollable spreadsheet format, making it easier to explore variable names and spot early patterns.\n\nKey variables for analysis include popularity, track_genre, and features like danceability, energy, and explicit, which offer a mix of numeric and categorical data.\n\n\n\n\n\n# Remove duplicate songs based on the track_name column\n# .keep_all = TRUE keeps the first full row for each unique track_name\nspotify &lt;- spotify_by_genre |&gt;\n  dplyr::distinct(track_name, .keep_all = TRUE)\n\n# View the resulting cleaned dataset\nspotify\n\n# A tibble: 4,311 × 21\n   track_id       artists album_name track_name popularity duration_ms explicit danceability energy   key loudness  mode\n   &lt;chr&gt;          &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;       &lt;dbl&gt; &lt;lgl&gt;           &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1 2wrJq5XKLnmhR… Dan + … 10,000 Ho… 10,000 Ho…         78      167693 FALSE           0.654  0.63     10    -4.64     1\n 2 6AHJTA1BN7ePf… Luke B… Country U… Country On          0      236455 FALSE           0.52   0.751     5    -5.06     1\n 3 5eUtyONoPyfZY… Thomas… Mientras … Die A Hap…          1      228320 FALSE           0.59   0.389     2    -9.24     1\n 4 1e3QZ42GsP8cT… Zach B… New Count… Something…          3      228013 FALSE           0.369  0.192     4   -12.2      0\n 5 43WFp6WBAvNgc… Luke B… Tailgate … Country G…          2      225560 FALSE           0.644  0.904     2    -4.53     1\n 6 16LAkUOZbmqdH… Thomas… Sad Count… Slow Down…          8      216764 FALSE           0.464  0.755     4    -5.71     1\n 7 6rfDtM5aHbsaL… Florid… Sad Count… Stay                2      200426 FALSE           0.493  0.931     1    -2.99     1\n 8 24NRxtqD6oySj… Zach B… Country C… Oklahoma …          3      211739 FALSE           0.544  0.573     8    -5.69     1\n 9 3opqy7HYeNHQa… Thomas… Tailgate … Put It On…          0      184800 FALSE           0.554  0.757     0    -4.30     1\n10 66ERrn57fmkbO… Zach B… rainy day… November …          2      243709 FALSE           0.429  0.197     3    -9.80     1\n# ℹ 4,301 more rows\n# ℹ 9 more variables: speechiness &lt;dbl&gt;, acousticness &lt;dbl&gt;, instrumentalness &lt;dbl&gt;, liveness &lt;dbl&gt;, valence &lt;dbl&gt;,\n#   tempo &lt;dbl&gt;, time_signature &lt;dbl&gt;, track_genre &lt;chr&gt;, popular_or_not &lt;chr&gt;\n\n\n\nWe use distinct() to remove duplicate songs based on track_name, keeping only the first full row for each unique title.\nThis step helps prevent repeated entries from biasing our analysis and ensures each song is counted only once.\n\n\n\n\n\n# Set a random seed so results are reproducible\nset.seed(2025)\n\n# Take a random sample of 10 rows from the full dataset\nspotify |&gt;\n  dplyr::slice_sample(n = 10)\n\n# A tibble: 10 × 21\n   track_id       artists album_name track_name popularity duration_ms explicit danceability energy   key loudness  mode\n   &lt;chr&gt;          &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;       &lt;dbl&gt; &lt;lgl&gt;           &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1 0HJ7K7uauPS05… CALVO;… Let Me Lo… Let Me Lo…         57      160748 FALSE           0.406  0.88      5    -5.56     1\n 2 1G09oEhz0Tye3… KDrew;… Prism      Prism              48      165882 FALSE           0.561  0.847     3    -5.03     0\n 3 0DRMigVA7KEsu… Hunter… Chillin' … You Shoul…          0      176552 FALSE           0.609  0.66      6    -5.66     1\n 4 2qZBjaOuBM8M8… ILLENI… Top of th… Story of …          0      240608 FALSE           0.537  0.884     0    -4.09     0\n 5 0HGpVO2aqh9Da… Faith … Finest Co… Like We N…          0      257693 FALSE           0.494  0.467     2    -8.18     1\n 6 61bUwAYTGluUH… Embody  I Miss You I Miss You         48      176000 FALSE           0.702  0.828     0    -3.07     1\n 7 71BwuaJ5VjGx9… The Ki… Home For … Don't Sho…          0      245106 FALSE           0.588  0.847     8    -4.16     1\n 8 2VTtxoSgxXQS7… WE ARE… DUALITY    Sad Story          41      183111 FALSE           0.499  0.587     7    -5.91     0\n 9 0apCPw4wHWMtW… Whales… High       High               47      184258 FALSE           0.616  0.643     6    -5.86     0\n10 20hTmPgYgVWwt… Tyler … Bottles a… Silence            42      125413 FALSE           0.502  0.301     7   -12.5      1\n# ℹ 9 more variables: speechiness &lt;dbl&gt;, acousticness &lt;dbl&gt;, instrumentalness &lt;dbl&gt;, liveness &lt;dbl&gt;, valence &lt;dbl&gt;,\n#   tempo &lt;dbl&gt;, time_signature &lt;dbl&gt;, track_genre &lt;chr&gt;, popular_or_not &lt;chr&gt;\n\n\n\n# Take a random sample of 10 rows but focus only on selected columns\nspotify |&gt;\n  dplyr::select(track_name, artists, track_genre, popularity) |&gt;\n  dplyr::slice_sample(n = 10)\n\n# A tibble: 10 × 4\n   track_name                               artists                                            track_genre popularity\n   &lt;chr&gt;                                    &lt;chr&gt;                                              &lt;chr&gt;            &lt;dbl&gt;\n 1 \"Take on Me\"                             a-ha                                               rock                85\n 2 \"Dawood\"                                 Sidhu Moose Wala                                   hip-hop             63\n 3 \"Tere Naal Nachna (From \\\"Nawabzaade\\\")\" Badshah;Sunanda Sharma                             hip-hop             60\n 4 \"Paper Thin - Headhunterz Remix\"         ILLENIUM;Tom DeLonge;Angels & Airwaves;Headhunterz dubstep             57\n 5 \"More\"                                   Jan Blomqvist;Elena Pitoulis                       deep-house          62\n 6 \"The Fight Song\"                         Marilyn Manson                                     metal                1\n 7 \"Summertime Sadness\"                     Y.V.E. 48                                          deep-house           0\n 8 \"Dracula\"                                King                                               hip-hop             56\n 9 \"THATS WHAT I WANT\"                      Lil Nas X                                          hip-hop             87\n10 \"No More Sorrow\"                         Linkin Park                                        metal               48\n\n\n\nWe use slice_sample() to view a random subset of songs, which helps us get a quick feel for the dataset’s content.\n\nSetting a seed ensures the sample is reproducible, which is helpful for teaching or collaboration.\n\nUsing select() lets us narrow down to key columns like song name, artist, genre, and popularity for a more focused look.\n\n\n\n\n\n# Count the number of tracks in each genre and sort from most to least\nspotify |&gt;\n  dplyr::count(track_genre, sort = TRUE)\n\n# A tibble: 6 × 2\n  track_genre     n\n  &lt;chr&gt;       &lt;int&gt;\n1 deep-house    903\n2 dubstep       871\n3 metal         775\n4 hip-hop       714\n5 country       595\n6 rock          453\n\n\n\nWe count how many tracks belong to each genre, which reveals how the dataset is distributed across categories.\n\nSorting by count highlights which genres are most and least represented, helping us spot potential imbalances early in our analysis.\n\n\n\n\n\n# For each column, count how many missing (NA) values there are\nspotify |&gt;\n  dplyr::summarize(across(everything(), ~sum(is.na(.)))) |&gt; \n  dplyr::glimpse()\n\nRows: 1\nColumns: 21\n$ track_id         &lt;int&gt; 0\n$ artists          &lt;int&gt; 0\n$ album_name       &lt;int&gt; 0\n$ track_name       &lt;int&gt; 0\n$ popularity       &lt;int&gt; 0\n$ duration_ms      &lt;int&gt; 0\n$ explicit         &lt;int&gt; 0\n$ danceability     &lt;int&gt; 0\n$ energy           &lt;int&gt; 0\n$ key              &lt;int&gt; 0\n$ loudness         &lt;int&gt; 0\n$ mode             &lt;int&gt; 0\n$ speechiness      &lt;int&gt; 0\n$ acousticness     &lt;int&gt; 0\n$ instrumentalness &lt;int&gt; 0\n$ liveness         &lt;int&gt; 0\n$ valence          &lt;int&gt; 0\n$ tempo            &lt;int&gt; 0\n$ time_signature   &lt;int&gt; 0\n$ track_genre      &lt;int&gt; 0\n$ popular_or_not   &lt;int&gt; 0\n\n\n\nWe check each column for missing values using summarize() and across(), which helps us spot potential issues before analysis.\n\nIdentifying missing data early is essential since it can interfere with visualizations, summaries, or modeling steps later on.\n\n\n\n\n\n# Check the class of the entire dataset (it's a tibble/data frame)\nclass(spotify)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n# Check the class of a specific column: track_genre (should be character or factor)\nclass(spotify$track_genre)\n\n[1] \"character\"\n\n# Check the class of a numeric column: popularity (should be numeric or integer)\nclass(spotify$popularity)\n\n[1] \"numeric\"\n\n# Use purrr::map_dfr() to apply class() to every column and return results as a data frame\npurrr::map_dfr(spotify, class) \n\n# A tibble: 1 × 21\n  track_id  artists   album_name track_name popularity duration_ms explicit danceability energy  key     loudness mode  \n  &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;        &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;    &lt;chr&gt; \n1 character character character  character  numeric    numeric     logical  numeric      numeric numeric numeric  numer…\n# ℹ 9 more variables: speechiness &lt;chr&gt;, acousticness &lt;chr&gt;, instrumentalness &lt;chr&gt;, liveness &lt;chr&gt;, valence &lt;chr&gt;,\n#   tempo &lt;chr&gt;, time_signature &lt;chr&gt;, track_genre &lt;chr&gt;, popular_or_not &lt;chr&gt;\n\n# Glimpse the result for a readable, wide-format view of column types\npurrr::map_dfr(spotify, class) |&gt; \n  dplyr::glimpse()\n\nRows: 1\nColumns: 21\n$ track_id         &lt;chr&gt; \"character\"\n$ artists          &lt;chr&gt; \"character\"\n$ album_name       &lt;chr&gt; \"character\"\n$ track_name       &lt;chr&gt; \"character\"\n$ popularity       &lt;chr&gt; \"numeric\"\n$ duration_ms      &lt;chr&gt; \"numeric\"\n$ explicit         &lt;chr&gt; \"logical\"\n$ danceability     &lt;chr&gt; \"numeric\"\n$ energy           &lt;chr&gt; \"numeric\"\n$ key              &lt;chr&gt; \"numeric\"\n$ loudness         &lt;chr&gt; \"numeric\"\n$ mode             &lt;chr&gt; \"numeric\"\n$ speechiness      &lt;chr&gt; \"numeric\"\n$ acousticness     &lt;chr&gt; \"numeric\"\n$ instrumentalness &lt;chr&gt; \"numeric\"\n$ liveness         &lt;chr&gt; \"numeric\"\n$ valence          &lt;chr&gt; \"numeric\"\n$ tempo            &lt;chr&gt; \"numeric\"\n$ time_signature   &lt;chr&gt; \"numeric\"\n$ track_genre      &lt;chr&gt; \"character\"\n$ popular_or_not   &lt;chr&gt; \"character\"\n\n\n\nWe use class() to identify the type of the dataset and specific columns, such as track_genre and popularity.\n\nThis helps us confirm whether a column is numeric, character, factor, or another type.\n\nclass(spotify) tells us that the dataset is stored as a tibble/data frame.\n\nChecking individual columns like track_genre and popularity helps us know how R will treat them in summaries and plots.\n\npurrr::map_dfr() applies class() to every column and returns the results in a tidy format.\n\nUnderstanding variable types is critical because it guides how we clean, summarize, visualize, and model the data. (Here’s a mind map to help you get started with basic types if needed.)\n\n\n\n\n\n# Use dplyr to compute common summary statistics for the popularity column\nspotify |&gt;\n  dplyr::summarize(\n    avg_popularity = mean(popularity),         # Mean (average) popularity\n    median_popularity = median(popularity),    # Median popularity\n    sd_popularity = sd(popularity)             # Standard deviation of popularity\n  )\n\n# A tibble: 1 × 3\n  avg_popularity median_popularity sd_popularity\n           &lt;dbl&gt;             &lt;dbl&gt;         &lt;dbl&gt;\n1           41.7                48          26.3\n\n# Use moderndive's tidy_summary() to get a full summary of one or more columns\nspotify |&gt; \n  moderndive::tidy_summary(columns = popularity)\n\n# A tibble: 1 × 11\n  column         n group type      min    Q1  mean median    Q3   max    sd\n  &lt;chr&gt;      &lt;int&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 popularity  4311 &lt;NA&gt;  numeric     0    22  41.7     48    61    99  26.3\n\n\n\nWe calculate summary statistics like mean, median, and standard deviation to understand the center and spread of the popularity variable.\n\nThe mean gives the average popularity, while the median shows the midpoint, and the standard deviation tells us how much scores vary.\n\nsummarize() is a flexible way to compute custom statistics for any variable.\n\ntidy_summary() from the moderndive package provides a full summary in one step, including min, max, and quartiles.\n\nUsing both methods together gives a quick yet detailed picture of a variable’s distribution.\n\nThese summaries help us assess whether the data is skewed, spread out, or centered around a typical value.\n\n\n\n\n\n# Create a histogram to visualize the distribution of track popularity scores\nggplot(data = spotify, aes(x = popularity)) +\n  geom_histogram(binwidth = 5, fill = \"steelblue\", color = \"black\") +\n  labs(title = \"Distribution of Track Popularity\", \n       x = \"Popularity Score\", \n       y = \"Count\")\n\n\n\n\n\nWe use a histogram to explore how the popularity scores are distributed across all tracks.\n\nbinwidth = 5 groups scores into intervals of 5, making it easier to see patterns and trends.\n\nMost bars show how many songs fall within each popularity range, helping us spot common and rare values.\n\nThe visualization helps us check for skew—whether most songs are clustered toward high or low popularity.\n\nIt also makes it easier to spot outliers or unusual peaks in the data.\n\nThis plot gives us a solid starting point for understanding overall patterns before diving into comparisons or models.\n\n\n\n\n\n(1.1) Why is Exploratory Data Analysis (EDA) considered a crucial first step in any data science project?\nA. It allows you to train models more quickly.\nB. It helps reveal patterns, identify data issues, and guide analysis decisions.\nC. It replaces the need for data cleaning by automating it.\nD. It transforms all variables into numeric format for modeling.\n\n(1.2) What is the role of the distinct() function in preparing your data?\nA. It filters out rows with missing values.\nB. It removes duplicate rows based on selected columns.\nC. It transforms all character variables into factors.\nD. It visualizes the distribution of numeric variables.\n\n(1.3) What does the spotify_by_genre dataset contain?\nA. Only audio features from 6,000 classical music tracks\nB. Survey results about Spotify users’ listening habits\nC. Metadata and audio features of 6,000 songs across six genres\nD. Real-time streaming counts of trending tracks globally\n\n(1.4) Which function is best used to take a random subset of rows from a dataset?\nA. sample_n()\nB. slice_sample()\nC. randomize()\nD. filter()\n\n(1.5) What is the purpose of using purrr::map_dfr() in this session?\nA. To count the number of missing values in a column\nB. To classify songs into popular and non-popular categories\nC. To apply a function across all columns and return the results in a single data frame\nD. To create visualizations for each genre using ggplot2\n\n\n\n\n(1.1) Why is Exploratory Data Analysis (EDA) considered a crucial first step in any data science project?\nCorrect Answer:\nB. It helps reveal patterns, identify data issues, and guide analysis decisions.\nExplanation:\nEDA helps uncover structure, detect errors, and build intuition about the dataset before modeling or advanced analysis.\n\n(1.2) What is the role of the distinct() function in preparing your data?\nCorrect Answer:\nB. It removes duplicate rows based on selected columns.\nExplanation:\nUsing distinct() ensures you’re not analyzing repeated entries, which could bias your results.\n\n(1.3) What does the spotify_by_genre dataset contain?\nCorrect Answer:\nC. Metadata and audio features of 6,000 songs across six genres\nExplanation:\nThis dataset combines categorical and numeric variables useful for EDA, such as genre, popularity, danceability, and more.\n\n(1.4) Which function is best used to take a random subset of rows from a dataset?\nCorrect Answer:\nB. slice_sample()\nExplanation:\nslice_sample() provides a random selection of rows, which is useful for quick spot-checks or previews of the data.\n\n(1.5) What is the purpose of using purrr::map_dfr() in this session?\nCorrect Answer:\nC. To apply a function across all columns and return the results in a single data frame\nExplanation:\nThis function was used to inspect the class of each column by mapping class() over the dataset and combining the results row-wise."
  },
  {
    "objectID": "answers/day1_walkthrough_answers.html#session-2-data-cleaning-fundamentals-with-dplyr-tidyr-and-janitor",
    "href": "answers/day1_walkthrough_answers.html#session-2-data-cleaning-fundamentals-with-dplyr-tidyr-and-janitor",
    "title": "Exploratory Data Analysis in R with the tidyverse",
    "section": "",
    "text": "# Select a subset of columns and rename track_genre to genre\n# Then take a random sample of 20 rows to explore\nspotify |&gt;\n  select(track_name, artists, genre = track_genre, popularity, energy, \n         danceability) |&gt; \n  slice_sample(n = 20)\n\n# A tibble: 20 × 6\n   track_name                                                               artists genre popularity energy danceability\n   &lt;chr&gt;                                                                    &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;        &lt;dbl&gt;\n 1 Somewhere That I Belong                                                  Fairla… dubs…          0  0.911        0.532\n 2 Don't Worry My Love                                                      Kaivon  dubs…         55  0.804        0.511\n 3 Falling to Pieces                                                        Faith … metal         41  0.919        0.545\n 4 In Your Eyes (feat. Alida) - LUM!X Remix                                 Robin … deep…         54  0.777        0.692\n 5 Baanina Haniyu                                                           Raghu … rock          47  0.384        0.484\n 6 Bella Luna                                                               Jason … rock           1  0.454        0.755\n 7 If the World Was Ending                                                  Hannah… coun…         49  0.399        0.492\n 8 Hanji Hanji                                                              Amrit … hip-…         63  0.553        0.871\n 9 Wolf Totem                                                               The HU  metal         61  0.718        0.557\n10 An Old Fashioned Love Song - Single Version                              Three … coun…          0  0.555        0.456\n11 Walk Away (feat. Kaptan)                                                 LVNDSC… deep…         45  0.778        0.677\n12 Music Sounds Better with You                                             Alle F… deep…         60  0.912        0.724\n13 Spider                                                                   Said T… dubs…         40  0.619        0.55 \n14 Most Really Pretty Girls Have Pretty Ugly Feet                           HNNY    deep…         57  0.449        0.929\n15 Elevator (Lift Me Up) - Jerry Ropero Tech Boom Mix                       Todd T… deep…          0  0.698        0.798\n16 Message In A Bottle - Remastered 2003                                    The Po… rock           3  0.808        0.568\n17 Forgotten                                                                Linkin… metal         61  0.947        0.615\n18 Good Things Fall Apart vs. Sad Songs (With Said The Sky feat. Annika We… ILLENI… dubs…         59  0.555        0.563\n19 Figure.09                                                                Linkin… metal         60  0.951        0.518\n20 Count On Me                                                              Hoglan… deep…         49  0.852        0.396\n\n\n\n# Filter for only songs with popularity greater than 80\n# Select only key identifying columns, randomly sample 20, then arrange by popularity (descending)\nspotify |&gt;\n  filter(popularity &gt; 80) |&gt;\n  select(track_name, artists, popularity) |&gt; \n  slice_sample(n = 20) |&gt; \n  arrange(desc(popularity))\n\n# A tibble: 20 × 3\n   track_name                                             artists                     popularity\n   &lt;chr&gt;                                                  &lt;chr&gt;                            &lt;dbl&gt;\n 1 I Ain't Worried                                        OneRepublic                         96\n 2 Hold Me Closer                                         Elton John;Britney Spears           89\n 3 STAY (with Justin Bieber)                              The Kid LAROI;Justin Bieber         89\n 4 Bones                                                  Imagine Dragons                     89\n 5 No Role Modelz                                         J. Cole                             88\n 6 Without Me                                             Eminem                              88\n 7 You Proof                                              Morgan Wallen                       86\n 8 Running Up That Hill (A Deal With God) - 2018 Remaster Kate Bush                           85\n 9 Counting Stars                                         OneRepublic                         83\n10 Safe And Sound                                         Capital Cities                      83\n11 Fuck Love (feat. Trippie Redd)                         XXXTENTACION;Trippie Redd           83\n12 MONTERO (Call Me By Your Name)                         Lil Nas X                           83\n13 Unforgettable                                          French Montana;Swae Lee             82\n14 All I Want                                             Kodaline                            82\n15 Prom Queen                                             Beach Bunny                         82\n16 Not Afraid                                             Eminem                              81\n17 Tu Aake Dekhle                                         King                                81\n18 Whiskey Glasses                                        Morgan Wallen                       81\n19 Tennessee Whiskey                                      Chris Stapleton                     81\n20 Heathens                                               Twenty One Pilots                   81\n\n\n\nWe use select() to focus on specific columns, helping us reduce clutter and explore only what’s relevant.\n\nRenaming track_genre to genre makes the column name shorter and easier to work with.\n\nslice_sample() lets us inspect a small, random subset of rows, which is useful for getting a feel for the data.\n\nfilter(popularity &gt; 80) narrows the data to only include high-popularity songs, helping us analyze standout tracks.\n\narrange(desc(popularity)) sorts songs from most to least popular, making top-performing tracks easy to spot.\n\nThese wrangling steps are key in EDA for zooming in on trends, patterns, or interesting subsets of your data.\n\n\n\n\n\n# Create a new logical column to flag songs with both high energy and high danceability\nspotify |&gt;\n  mutate(high_energy_dance = energy &gt; 0.7 & danceability &gt; 0.7) |&gt;\n  count(high_energy_dance)\n\n# A tibble: 2 × 2\n  high_energy_dance     n\n  &lt;lgl&gt;             &lt;int&gt;\n1 FALSE              3666\n2 TRUE                645\n\n\n\n# Create a new categorical column for popularity levels using case_when\n# Then count how many songs fall into each category\nspotify |&gt;\n  mutate(popularity_group = case_when(\n    popularity &gt;= 75 ~ \"high\",\n    popularity &gt;= 40 ~ \"medium\",\n    TRUE ~ \"low\"\n  )) |&gt;\n  count(popularity_group)\n\n# A tibble: 3 × 2\n  popularity_group     n\n  &lt;chr&gt;            &lt;int&gt;\n1 high               295\n2 low               1407\n3 medium            2609\n\n\n\nWe use mutate() to create new columns based on conditions, helping us flag or group rows for deeper analysis.\n\nThe high_energy_dance column identifies songs that are both energetic and danceable by checking if both values exceed 0.7.\n\nCounting TRUE and FALSE values helps us see how common that combination is in the dataset.\n\ncase_when() allows us to group numeric values (like popularity) into meaningful categories such as “low,” “medium,” and “high.”\n\nCreating categorical groupings from continuous variables simplifies comparisons and improves visualizations.\n\nThese custom columns make it easier to answer specific questions and communicate insights clearly.\n\n\n\n\n\n# Create a new column that calculates the ratio of energy to danceability\nspotify |&gt;\n  mutate(energy_dance_ratio = energy / danceability) |&gt;\n  select(track_name, artists, track_genre, energy, \n         danceability, energy_dance_ratio) |&gt; \n  slice_sample(n = 20)\n\n# A tibble: 20 × 6\n   track_name                                    artists              track_genre energy danceability energy_dance_ratio\n   &lt;chr&gt;                                         &lt;chr&gt;                &lt;chr&gt;        &lt;dbl&gt;        &lt;dbl&gt;              &lt;dbl&gt;\n 1 \"Ele Se Foi\"                                  Oficina G3           metal        0.595        0.551              1.08 \n 2 \"Freewheelin'\"                                Jack Wins;Caitlyn S… deep-house   0.822        0.598              1.37 \n 3 \"In Pieces\"                                   Linkin Park          metal        0.886        0.508              1.74 \n 4 \"Sete\"                                        BLOND:ISH;Francis M… deep-house   0.827        0.736              1.12 \n 5 \"Meus Passos\"                                 Oficina G3           metal        0.941        0.521              1.81 \n 6 \"Kudi Nu Nachne De (From \\\"Angrezi Medium\\\")\" Vishal Dadlani;Sach… hip-hop      0.688        0.834              0.825\n 7 \"Senjitaley\"                                  Anirudh Ravichander  hip-hop      0.941        0.655              1.44 \n 8 \"Welcome to the Family\"                       Avenged Sevenfold    metal        0.946        0.567              1.67 \n 9 \"Didn't I\"                                    OneRepublic          rock         0.61         0.611              0.998\n10 \"Laal Bindi\"                                  Akull                hip-hop      0.599        0.746              0.803\n11 \"It’s All on U\"                               ILLENIUM;Liam O'Don… dubstep      0.82         0.498              1.65 \n12 \"Man! I Feel Like A Woman!\"                   Shania Twain         country      0.889        0.654              1.36 \n13 \"Never Loved You At All\"                      Parker McCollum      country      0.891        0.552              1.61 \n14 \"Uchiyaan Dewaraan\"                           Bilal Saeed;Momina … hip-hop      0.577        0.428              1.35 \n15 \"Can't Stop Lovin' You\"                       Van Halen            metal        0.898        0.592              1.52 \n16 \"Hope For The Future\"                         Bastille             rock         0.411        0.449              0.915\n17 \"Call on Me (Ryan Riback Remix)\"              Starley;Ryan Riback  deep-house   0.839        0.67               1.25 \n18 \"Sidhu Son\"                                   Sidhu Moose Wala     hip-hop      0.732        0.571              1.28 \n19 \"Wasted Years - 2015 Remaster\"                Iron Maiden          metal        0.959        0.314              3.05 \n20 \"B2B\"                                         James Hype;Tita Lau  deep-house   0.956        0.799              1.20 \n\n\n\n# Add a logical column that flags songs with tempo greater than 140 as high tempo\n# Then count how many songs fall into each category\nspotify |&gt;\n  mutate(high_tempo = tempo &gt; 140) |&gt;\n  count(high_tempo)\n\n# A tibble: 2 × 2\n  high_tempo     n\n  &lt;lgl&gt;      &lt;int&gt;\n1 FALSE       3079\n2 TRUE        1232\n\n\n\nWe use mutate() to create new variables that help us explore relationships between existing features.\n\nThe energy_dance_ratio compares energy and danceability, offering a new way to assess the feel of a track.\n\nViewing a sample of songs with this new ratio lets us explore how it varies across genres and artists.\n\nCreating a high_tempo flag helps us classify songs based on a threshold (tempo &gt; 140 BPM).\n\nLogical columns like high_tempo are useful for quick counts, filtering, or subgroup analysis.\n\nAdding derived variables allows us to go beyond surface-level data and uncover more meaningful patterns.\n\n\n\n\n\n# Group the data by genre and calculate the average energy for each group\nspotify |&gt;\n  group_by(track_genre) |&gt;\n  summarize(mean_energy = mean(energy, na.rm = TRUE))\n\n# A tibble: 6 × 2\n  track_genre mean_energy\n  &lt;chr&gt;             &lt;dbl&gt;\n1 country           0.628\n2 deep-house        0.742\n3 dubstep           0.763\n4 hip-hop           0.691\n5 metal             0.839\n6 rock              0.661\n\n\n\n# Count how many songs are popular or not within each genre\nspotify |&gt;\n  count(track_genre, popular_or_not)\n\n# A tibble: 12 × 3\n   track_genre popular_or_not     n\n   &lt;chr&gt;       &lt;chr&gt;          &lt;int&gt;\n 1 country     not popular      462\n 2 country     popular          133\n 3 deep-house  not popular      412\n 4 deep-house  popular          491\n 5 dubstep     not popular      691\n 6 dubstep     popular          180\n 7 hip-hop     not popular      170\n 8 hip-hop     popular          544\n 9 metal       not popular      302\n10 metal       popular          473\n11 rock        not popular      288\n12 rock        popular          165\n\n\n\nWe use group_by() and summarize() to calculate the average energy level within each music genre.\n\nThis helps us compare genres to see which ones tend to have more energetic tracks.\n\nThe na.rm = TRUE argument ensures missing values don’t interfere with our summary statistics.\n\nCounting by both track_genre and popular_or_not gives us a two-way frequency table.\n\nThis count reveals how popularity is distributed across different genres.\n\nGrouped summaries are essential for spotting trends, differences, and relationships across categories.\n\n\n\n\n\n# Reshape selected audio features from wide format to long format\n# This creates a 'feature' column for the variable name and a 'value' column for its value\nspotify |&gt;\n  select(track_name, energy, danceability, acousticness) |&gt;\n  tidyr::pivot_longer(cols = c(energy, danceability, acousticness),\n                      names_to = \"feature\",\n                      values_to = \"value\")\n\n# A tibble: 12,933 × 3\n   track_name                        feature      value\n   &lt;chr&gt;                             &lt;chr&gt;        &lt;dbl&gt;\n 1 10,000 Hours (with Justin Bieber) energy       0.63 \n 2 10,000 Hours (with Justin Bieber) danceability 0.654\n 3 10,000 Hours (with Justin Bieber) acousticness 0.153\n 4 Country On                        energy       0.751\n 5 Country On                        danceability 0.52 \n 6 Country On                        acousticness 0.171\n 7 Die A Happy Man                   energy       0.389\n 8 Die A Happy Man                   danceability 0.59 \n 9 Die A Happy Man                   acousticness 0.411\n10 Something in the Orange           energy       0.192\n# ℹ 12,923 more rows\n\n\n\nWe use pivot_longer() to reshape the dataset from wide format to long format.\n\nThree audio features—energy, danceability, and acousticness—are transformed into a single feature column.\n\nTheir corresponding values are placed into a new value column, making the data more compact and tidy.\n\nThis format is ideal for creating faceted plots or grouped summaries across multiple features.\n\nIt allows us to treat multiple columns as levels of a single variable, which simplifies plotting and analysis.\n\nReshaping data like this is a powerful technique for scaling EDA workflows.\n\n\n\n\n\n# Count the number of songs in each genre by popularity category\n# Then reshape the data to have separate columns for 'popular' and 'not popular'\nspotify |&gt;\n  count(track_genre, popular_or_not) |&gt;\n  tidyr::pivot_wider(names_from = popular_or_not, values_from = n)\n\n# A tibble: 6 × 3\n  track_genre `not popular` popular\n  &lt;chr&gt;               &lt;int&gt;   &lt;int&gt;\n1 country               462     133\n2 deep-house            412     491\n3 dubstep               691     180\n4 hip-hop               170     544\n5 metal                 302     473\n6 rock                  288     165\n\n\n\nWe start by counting how many songs are labeled as popular or not popular within each genre.\n\nThis gives us a tall (long) format table showing counts for each genre-popularity combination.\n\nUsing pivot_wider(), we reshape the data to create separate columns for “popular” and “not popular”.\n\nEach genre becomes a row with its respective counts shown side by side.\n\nThis wide format makes it easier to compare popularity across genres at a glance.\n\nIt’s useful for tables, reports, or bar plots that benefit from side-by-side values.\n\n\n\n\n\n# Find the maximum number of artists in any single song by counting semicolons\n# Add 1 since semicolons separate the names (n artists = n semicolons + 1)\nmax_artists &lt;- spotify |&gt;\n  filter(stringr::str_detect(artists, \";\")) |&gt;\n  mutate(n_artists = stringr::str_count(artists, \";\") + 1) |&gt;\n  pull(n_artists) |&gt;\n  max(na.rm = TRUE)\n\n\n# Identify the song that has the most artists\nspotify |&gt;\n  mutate(n_artists = stringr::str_count(artists, \";\") + 1) |&gt;\n  arrange(desc(n_artists)) |&gt;\n  slice(1) |&gt;\n  select(track_name, artists, n_artists)\n\n# A tibble: 1 × 3\n  track_name     artists                                                                                       n_artists\n  &lt;chr&gt;          &lt;chr&gt;                                                                                             &lt;dbl&gt;\n1 Punjabi Mashup Arjun;Badshah;Bohemia;Diljit Dosanjh;Fateh;Gippy Grewal;Girik Aman;Gupz Sehra;Guru Randhawa;…        31\n\n\n\n# Create a vector of new column names based on the maximum number of artists found\nartist_cols &lt;- paste0(\"artist_\", seq_len(max_artists))\n\n\n# Use separate() to split the 'artists' column into multiple artist columns\n# Use fill = \"right\" to handle cases with fewer than max_artists\n# Keep the original 'artists' column for reference\nsplit_by_artists &lt;- spotify |&gt;\n  filter(stringr::str_detect(artists, \";\")) |&gt;\n  tidyr::separate(artists, into = artist_cols, sep = \";\", fill = \"right\", remove = FALSE) |&gt;\n  select(track_name, artists, track_genre, all_of(artist_cols))\nsplit_by_artists\n\n# A tibble: 1,704 × 34\n   track_name       artists track_genre artist_1 artist_2 artist_3 artist_4 artist_5 artist_6 artist_7 artist_8 artist_9\n   &lt;chr&gt;            &lt;chr&gt;   &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   \n 1 10,000 Hours (w… Dan + … country     Dan + S… Justin … &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n 2 Put It On Ice    Thomas… country     Thomas … HARDY    &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n 3 Playing With Fi… Thomas… country     Thomas … Daniell… &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n 4 10,000 Hours     Dan + … country     Dan + S… Justin … &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n 5 Buy Dirt         Jordan… country     Jordan … Luke Br… &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n 6 Tequila - Mushr… Dan + … country     Dan + S… Mushroo… &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n 7 Silent Night     Cody J… country     Cody Jo… Clara J… Brandi … Cori Jo… &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n 8 Little Drummer … Carrie… country     Carrie … Isaiah … &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n 9 Hallelujah       Carrie… country     Carrie … John Le… &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n10 Happy Anywhere   Blake … country     Blake S… Gwen St… &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n# ℹ 1,694 more rows\n# ℹ 22 more variables: artist_10 &lt;chr&gt;, artist_11 &lt;chr&gt;, artist_12 &lt;chr&gt;, artist_13 &lt;chr&gt;, artist_14 &lt;chr&gt;,\n#   artist_15 &lt;chr&gt;, artist_16 &lt;chr&gt;, artist_17 &lt;chr&gt;, artist_18 &lt;chr&gt;, artist_19 &lt;chr&gt;, artist_20 &lt;chr&gt;,\n#   artist_21 &lt;chr&gt;, artist_22 &lt;chr&gt;, artist_23 &lt;chr&gt;, artist_24 &lt;chr&gt;, artist_25 &lt;chr&gt;, artist_26 &lt;chr&gt;,\n#   artist_27 &lt;chr&gt;, artist_28 &lt;chr&gt;, artist_29 &lt;chr&gt;, artist_30 &lt;chr&gt;, artist_31 &lt;chr&gt;\n\n\n\n# Summarize how many multi-artist songs exist by genre\nsplit_by_artists |&gt;\n  group_by(track_genre) |&gt;\n  summarize(n_artists = sum(!is.na(artist_1))) |&gt;\n  arrange(desc(n_artists))\n\n# A tibble: 6 × 2\n  track_genre n_artists\n  &lt;chr&gt;           &lt;int&gt;\n1 dubstep           616\n2 deep-house        562\n3 hip-hop           364\n4 country            74\n5 rock               59\n6 metal              29\n\n\n\nWe detect songs with multiple artists by counting semicolons in the artists column, then find the maximum number of artists in any song.\n\nslice(1) after sorting lets us identify the specific track with the most artists listed.\n\nWe use paste0() to dynamically generate new column names like artist_1, artist_2, etc., based on the max number found.\n\nThe separate() function splits the artists column into multiple new columns for easier analysis of individual contributors.\n\nfill = \"right\" ensures shorter artist lists don’t break the structure—missing entries are filled with NA.\n\nWe summarize how many multi-artist songs exist per genre to examine which genres tend to have more collaborations.\n\n\n\n\n\n# Combine the track_name and artists columns into a single column called track_artist\n# Use \" by \" as the separator between the song title and the artist(s)\nspotify |&gt;\n  tidyr::unite(\"track_artist\", track_name, artists, sep = \" by \") |&gt;\n  select(track_artist, popularity) |&gt;\n  slice_sample(n = 20) |&gt; \n  arrange(desc(popularity))\n\n# A tibble: 20 × 2\n   track_artist                                                 popularity\n   &lt;chr&gt;                                                             &lt;dbl&gt;\n 1 Do I Wanna Know? by Arctic Monkeys                                   88\n 2 Hurt by Johnny Cash                                                  74\n 3 Born To Be Wild by Steppenwolf                                       73\n 4 Nightmare by Avenged Sevenfold                                       72\n 5 Hurricane by I Prevail                                               68\n 6 House Of The Rising Sun by Nora Van Elken                            61\n 7 Sidhu Son by Sidhu Moose Wala                                        59\n 8 Baitikochi Chuste by Anirudh Ravichander                             56\n 9 Promises by NERO                                                     56\n10 Beautiful by Deepend;Griff Clawson                                   56\n11 Empty Floor by Jan Blomqvist                                         53\n12 Empty Love by Lulleaux;Kid Princess                                  51\n13 Promises - Skrillex & Nero Remix by NERO                             44\n14 Stomach It by Crywolf;EDEN                                           44\n15 Forgive Me Now by BH                                                 42\n16 Ammunition by Krewella                                               38\n17 Xelela Abazali by Deep Sen;KingTalkzin;KnightSA;Russell Zuma         29\n18 Like a Movie feat. Haexxa by Alfred Heinrichs;Haexxa                 26\n19 O Holy Night by Lauren Alaina                                         0\n20 Christmas Makes Me Cry by Kacey Musgraves                             0\n\n\n\nWe use unite() to merge track_name and artists into a single column called track_artist for clearer labeling.\n\nThe separator \" by \" makes the new string easy to read and interpret, like a song title in a playlist.\n\nSelecting just track_artist and popularity keeps the focus on key information.\n\nRandomly sampling 20 rows gives us a manageable view of the data.\n\nSorting by descending popularity helps us quickly identify top-performing tracks.\n\nThis technique is useful for creating labels in plots or tables that clearly identify each observation.\n\n\n\n\n\n# Simulate messy column names by renaming clean ones to include emojis, symbols, and inconsistent formatting\nspotify_unruly &lt;- spotify |&gt;\n  rename(\n    `Track Name 🎵` = track_name,\n    `ARTISTS (main + featured)` = artists,\n    `Album-Name___v2` = album_name,\n    `DURATION (ms)` = duration_ms,\n    `Popularity SCORE (%)` = popularity,\n    `track genre!` = track_genre,\n    `Explicit?` = explicit,\n    `IS_IT_POPULAR????` = popular_or_not\n  ) |&gt; \n  mutate(valence = NA_real_)  # Add an entirely empty column to test janitor functions\n\n# Check the column names and dimensions before cleaning\nnames(spotify_unruly)\n\n [1] \"track_id\"                  \"ARTISTS (main + featured)\" \"Album-Name___v2\"           \"Track Name 🎵\"            \n [5] \"Popularity SCORE (%)\"      \"DURATION (ms)\"             \"Explicit?\"                 \"danceability\"             \n [9] \"energy\"                    \"key\"                       \"loudness\"                  \"mode\"                     \n[13] \"speechiness\"               \"acousticness\"              \"instrumentalness\"          \"liveness\"                 \n[17] \"valence\"                   \"tempo\"                     \"time_signature\"            \"track genre!\"             \n[21] \"IS_IT_POPULAR????\"        \n\ndim(spotify_unruly)\n\n[1] 4311   21\n\n\n\n# Clean the messy column names: make them lowercase, snake_case, and remove special characters\n# Remove any completely empty columns\nspotify_cleaned_some &lt;- spotify_unruly |&gt;\n  janitor::clean_names() |&gt;\n  janitor::remove_empty(which = \"cols\")\n\n# Check the new cleaned column names and dimensions\nnames(spotify_cleaned_some)\n\n [1] \"track_id\"                 \"artists_main_featured\"    \"album_name_v2\"            \"track_name\"              \n [5] \"popularity_score_percent\" \"duration_ms\"              \"explicit\"                 \"danceability\"            \n [9] \"energy\"                   \"key\"                      \"loudness\"                 \"mode\"                    \n[13] \"speechiness\"              \"acousticness\"             \"instrumentalness\"         \"liveness\"                \n[17] \"tempo\"                    \"time_signature\"           \"track_genre\"              \"is_it_popular\"           \n\ndim(spotify_cleaned_some)\n\n[1] 4311   20\n\n\n\nWe simulate messy data by renaming columns with emojis, inconsistent formatting, and symbols to reflect real-world issues.\n\nclean_names() from the janitor package standardizes column names to lowercase snake_case, making them easier to reference in code.\n\nThis function also removes special characters and spaces, which can cause problems in analysis scripts.\n\nWe add a fully missing column to test how remove_empty() eliminates columns with only NA values.\n\nAfter cleaning, column names become consistent and safe for programming, reducing the chance of errors.\n\nThese cleaning steps are essential when preparing raw or imported data for analysis.\n\n\n\n\n\n# Move the track_genre column to appear right before track_id\n# Recode popular_or_not into a new column popular_recoded using case_match\n# Place the new column directly after track_genre\nspotify |&gt;\n  relocate(track_genre, .before = track_id) |&gt;\n  mutate(popular_recoded = case_match(popular_or_not, \n                                      \"popular\" ~ \"yes\", \n                                      \"not popular\" ~ \"no\"),\n         .after = track_genre) |&gt; \n  select(1:6) |&gt; \n  slice_head(n = 10)\n\n# A tibble: 10 × 6\n   track_genre popular_recoded track_id               artists                  album_name                     track_name\n   &lt;chr&gt;       &lt;chr&gt;           &lt;chr&gt;                  &lt;chr&gt;                    &lt;chr&gt;                          &lt;chr&gt;     \n 1 country     yes             2wrJq5XKLnmhRXHIAf9xBa Dan + Shay;Justin Bieber 10,000 Hours (with Justin Bie… 10,000 Ho…\n 2 country     no              6AHJTA1BN7ePfChCwqph3z Luke Bryan               Country USA                    Country On\n 3 country     no              5eUtyONoPyfZYGrFHmZzlc Thomas Rhett             Mientras hago aromaterapia     Die A Hap…\n 4 country     no              1e3QZ42GsP8cTy5uQ0G7J3 Zach Bryan               New Country                    Something…\n 5 country     no              43WFp6WBAvNgc7iaFFEUJp Luke Bryan               Tailgate Country               Country G…\n 6 country     no              16LAkUOZbmqdHgicUsHY1S Thomas Rhett             Sad Country Songs              Slow Down…\n 7 country     no              6rfDtM5aHbsaLGAUxfIgpN Florida Georgia Line     Sad Country Songs              Stay      \n 8 country     no              24NRxtqD6oySjRnAZxa4Hf Zach Bryan               Country Car Hits               Oklahoma …\n 9 country     no              3opqy7HYeNHQaUwYVS7cLo Thomas Rhett;HARDY       Tailgate Country               Put It On…\n10 country     no              66ERrn57fmkbOq9zhELGPv Zach Bryan               rainy day indie                November …\n\n\n\nWe use relocate() to reposition track_genre before track_id, improving the layout for easier scanning.\n\nmutate() with case_match() creates a new column that recodes popular_or_not into simpler “yes” or “no” values.\n\nThe .after = track_genre argument places the new popular_recoded column right after track_genre for better grouping.\n\nUsing select(1:6) limits our view to the first six columns, which helps keep previews focused and readable.\n\nslice_head(n = 10) displays the first 10 rows of the updated dataset for a quick check.\n\nThese layout and recoding steps make the dataset more intuitive and better organized for analysis or reporting.\n\n\n\n\n\n(2.1) What is the purpose of using filter() in data wrangling with dplyr?\nA. To remove missing values from all columns.\nB. To select specific columns by name.\nC. To remove duplicate rows from a dataset.\nD. To return only rows that meet a certain condition.\n\n(2.2) What is the result of using the mutate() function in a dplyr pipeline?\nA. It permanently deletes rows that contain NA values.\nB. It creates new columns or modifies existing ones.\nC. It filters the dataset by logical conditions.\nD. It combines multiple columns into one.\n\n(2.3) What does the following code do in the context of the spotify_by_genre dataset?\nspotify |&gt;\n  mutate(high_acoustic_mellow = acousticness &gt; 0.8 & valence &lt; 0.4)\nA. It filters the dataset to only include mellow and acoustic songs.\nB. It creates a new variable indicating whether a song is both highly acoustic and low in valence.\nC. It summarizes acousticness and valence for mellow songs.\nD. It creates a histogram of acousticness for songs with low valence.\n\n(2.4) What is the effect of pivot_longer() on a dataset?\nA. It removes NA values from multiple columns.\nB. It splits a character column into multiple columns.\nC. It summarizes grouped values into wider format tables.\nD. It transforms columns into key-value pairs, increasing the number of rows.\n\n(2.5) Why is janitor::clean_names() helpful in the data cleaning process?\nA. It changes all character variables to numeric format.\nB. It fills in missing values in your dataset.\nC. It converts messy column names to consistent, lowercase, snake_case format.\nD. It rearranges the rows of the dataset based on alphabetical order.\n\n\n\n\n(2.1) What is the purpose of using filter() in data wrangling with dplyr?\nCorrect Answer:\nD. To return only rows that meet a certain condition.\nExplanation:\nfilter() keeps rows based on a logical condition, helping narrow your dataset to just what you’re interested in analyzing.\n\n(2.2) What is the result of using the mutate() function in a dplyr pipeline?\nCorrect Answer:\nB. It creates new columns or modifies existing ones.\nExplanation:\nmutate() allows you to add or alter columns using logic, math, or transformations, making it essential for feature engineering.\n\n(2.3) What does the following code do in the context of the spotify_by_genre dataset?\nspotify |&gt;\n  mutate(high_acoustic_mellow = acousticness &gt; 0.8 & valence &lt; 0.4)\nCorrect Answer:\nB. It creates a new variable indicating whether a song is both highly acoustic and low in valence.\nExplanation:\nThis code adds a new logical column called high_acoustic_mellow, which is TRUE if the song’s acousticness is greater than 0.8 and its valence is less than 0.4—capturing songs that are both acoustic and emotionally mellow.\n\n(2.4) What is the effect of pivot_longer() on a dataset?\nCorrect Answer:\nD. It transforms columns into key-value pairs, increasing the number of rows.\nExplanation:\npivot_longer() reshapes wide data into long format, useful for tidy plotting and modeling.\n\n(2.5) Why is janitor::clean_names() helpful in the data cleaning process?\nCorrect Answer:\nC. It converts messy column names to consistent, lowercase, snake_case format.\nExplanation:\nThis function simplifies variable names by removing special characters and spaces, making them easier to reference in code."
  },
  {
    "objectID": "answers/day1_walkthrough_answers.html#session-3-managing-dates-strings-and-categories",
    "href": "answers/day1_walkthrough_answers.html#session-3-managing-dates-strings-and-categories",
    "title": "Exploratory Data Analysis in R with the tidyverse",
    "section": "",
    "text": "library(stringr)\n\n# Create a new column that counts the number of characters in each track name\n# Then display the track names sorted by length in descending order\nspotify |&gt;\n  mutate(name_length = str_length(track_name)) |&gt;\n  select(track_name, name_length) |&gt;\n  arrange(desc(name_length)) \n\n# A tibble: 4,311 × 2\n   track_name                                                                                  name_length\n   &lt;chr&gt;                                                                                             &lt;int&gt;\n 1 \"A Thousand Years (feat. Steve Kazee) - Pt. 2; The Twilight Saga: Breaking Dawn Soundtrack\"          89\n 2 \"Where Are You Christmas - From \\\"Dr. Seuss' How The Grinch Stole Christmas\\\" Soundtrack\"            85\n 3 \"I Put A Spell On You (Fifty Shades of Grey) - From \\\"Fifty Shades Of Grey\\\" Soundtrack\"             84\n 4 \"Last One Standing (feat. Polo G, Mozzy & Eminem) - From Venom: Let There Be Carnage\"                83\n 5 \"Double Talkin' Jive - Live In Las Vegas, Thomas & Mack Center - January 25, 1992\"                   80\n 6 \"Rockin' Around The Christmas Tree - From The Kacey Musgraves Christmas Show\"                        75\n 7 \"Good Things Fall Apart vs. Sad Songs (With Said The Sky feat. Annika Wells)\"                        75\n 8 \"I'll Be Home For Christmas - From The Kacey Musgraves Christmas Show\"                               68\n 9 \"Good Things Fall Apart (with Jon Bellion) [Tiësto's Big Room Remix]\"                                67\n10 \"Sympathy For The Devil - 50th Anniversary Edition / Remastered 2018\"                                67\n# ℹ 4,301 more rows\n\n\n\n# Detect songs where the title includes the word \"love\" (case-insensitive)\n# Use str_to_lower to ensure consistent matching\n(\n  love_songs &lt;- spotify |&gt;\n    filter(str_detect(str_to_lower(track_name), \"love\")) |&gt;\n    select(track_genre, track_name)\n)\n\n# A tibble: 147 × 2\n   track_genre track_name                       \n   &lt;chr&gt;       &lt;chr&gt;                            \n 1 country     I Love My Country                \n 2 country     Fall in Love                     \n 3 country     Never Been in Love               \n 4 country     Don't Fall In Love With A Dreamer\n 5 country     Like We Never Loved at All       \n 6 country     Let's Make Love                  \n 7 country     Drunk on Your Love               \n 8 country     I Love You, I Love You           \n 9 country     You Should Be Loved              \n10 country     Love Will Keep Us Alive          \n# ℹ 137 more rows\n\n\n\n# Count how many \"love\" songs appear in each genre\n# Calculate the percentage of total songs that mention \"love\" for each genre\nlove_songs |&gt;\n  mutate(love = 1) |&gt;\n  group_by(track_genre) |&gt;\n  summarize(n_love = sum(love)) |&gt;\n  ungroup() |&gt;\n  mutate(pct_love = n_love / nrow(spotify) * 100) |&gt;\n  arrange(desc(pct_love))\n\n# A tibble: 6 × 3\n  track_genre n_love pct_love\n  &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;\n1 deep-house      55    1.28 \n2 dubstep         31    0.719\n3 hip-hop         21    0.487\n4 country         20    0.464\n5 metal           11    0.255\n6 rock             9    0.209\n\n\n\nWe use str_length() to measure the number of characters in each song title, helping us identify especially long or short track names.\n\nSorting by name_length reveals songs with the most elaborate titles.\n\nstr_detect() finds tracks that contain the word “love” in the title, using str_to_lower() to ensure case-insensitive matching.\n\nThis lets us explore themes in the data—like how often love appears in song titles.\n\nWe add a flag (love = 1) to count and summarize how many love-themed songs exist in each genre.\n\nCalculating percentages gives insight into which genres most frequently use “love” in their track titles relative to the full dataset.\n\n\n\n\n\n# Remove all parentheses from track names\nspotify |&gt;\n  mutate(track_name_clean = str_remove_all(track_name, \"\\\\(.*?\\\\)\")) |&gt;\n  select(track_name, track_name_clean)\n\n# A tibble: 4,311 × 2\n   track_name                        track_name_clean         \n   &lt;chr&gt;                             &lt;chr&gt;                    \n 1 10,000 Hours (with Justin Bieber) \"10,000 Hours \"          \n 2 Country On                        \"Country On\"             \n 3 Die A Happy Man                   \"Die A Happy Man\"        \n 4 Something in the Orange           \"Something in the Orange\"\n 5 Country Girl (Shake It For Me)    \"Country Girl \"          \n 6 Slow Down Summer                  \"Slow Down Summer\"       \n 7 Stay                              \"Stay\"                   \n 8 Oklahoma Smokeshow                \"Oklahoma Smokeshow\"     \n 9 Put It On Ice                     \"Put It On Ice\"          \n10 November Air                      \"November Air\"           \n# ℹ 4,301 more rows\n\n\n\n# Extract featured artist from parentheses\nspotify |&gt;\n  mutate(featuring = str_extract(\n    track_name, \n    \"(?i)(?&lt;=\\\\()(with|feat\\\\.)[^)]*(?=\\\\))\")) |&gt;\n  select(track_name, featuring) |&gt;\n  mutate(featuring = str_replace_all(featuring, \"with |feat. \", \"\")) |&gt; \n  filter(!is.na(featuring))\n\n# A tibble: 261 × 2\n   track_name                                                  featuring            \n   &lt;chr&gt;                                                       &lt;chr&gt;                \n 1 10,000 Hours (with Justin Bieber)                           Justin Bieber        \n 2 Whiskey Lullaby (feat. Alison Krauss)                       Alison Krauss        \n 3 10,000 Hours (with Justin Bieber) - Piano                   Justin Bieber        \n 4 I Hope (feat. Charlie Puth)                                 Charlie Puth         \n 5 Dance with the Devil (feat. Katie Noel & Chucky V)          Katie Noel & Chucky V\n 6 On Me (feat. Ava Max)                                       Ava Max              \n 7 Take Me Home (with Kane Brown)                              Kane Brown           \n 8 What Ifs (feat. Lauren Alaina)                              Lauren Alaina        \n 9 Trying to Reason With Hurricane Season (with Jimmy Buffett) Jimmy Buffett        \n10 Sugar (feat. Francesco Yates)                               Francesco Yates      \n# ℹ 251 more rows\n\n\n\nWe use str_remove_all() with a non-greedy regex to remove any text in parentheses from song titles, creating a cleaner version of track_name.\n\nThe regex \"\\\\(.*?\\\\)\" ensures only the text inside the first set of parentheses is removed, not everything between the first ( and the last ).\n\nThis cleaning step is useful for removing remix labels or featured artist notes for clearer display or grouping.\n\nIn the second block, we use str_extract() to pull out featured artist names from parentheses that include “with” or “feat.”\n\nThe use of lookarounds (?&lt;=\\\\() and (?=\\\\)) ensures we extract the content inside the parentheses without including the parentheses themselves.\n\nAfter extracting, we strip out “with” or “feat.” using str_replace_all() to leave just the artist names, which can be helpful for analyzing collaborations.\n\n\n\n\n\n# Use separate_rows() to split multiple artists into individual rows\n# This turns collaborations into separate entries for each artist\n(\n  artists_long &lt;- spotify |&gt;\n    tidyr::separate_rows(artists, sep = \";\")\n)\n\n# A tibble: 6,642 × 21\n   track_id       artists album_name track_name popularity duration_ms explicit danceability energy   key loudness  mode\n   &lt;chr&gt;          &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;       &lt;dbl&gt; &lt;lgl&gt;           &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1 2wrJq5XKLnmhR… Dan + … 10,000 Ho… 10,000 Ho…         78      167693 FALSE           0.654  0.63     10    -4.64     1\n 2 2wrJq5XKLnmhR… Justin… 10,000 Ho… 10,000 Ho…         78      167693 FALSE           0.654  0.63     10    -4.64     1\n 3 6AHJTA1BN7ePf… Luke B… Country U… Country On          0      236455 FALSE           0.52   0.751     5    -5.06     1\n 4 5eUtyONoPyfZY… Thomas… Mientras … Die A Hap…          1      228320 FALSE           0.59   0.389     2    -9.24     1\n 5 1e3QZ42GsP8cT… Zach B… New Count… Something…          3      228013 FALSE           0.369  0.192     4   -12.2      0\n 6 43WFp6WBAvNgc… Luke B… Tailgate … Country G…          2      225560 FALSE           0.644  0.904     2    -4.53     1\n 7 16LAkUOZbmqdH… Thomas… Sad Count… Slow Down…          8      216764 FALSE           0.464  0.755     4    -5.71     1\n 8 6rfDtM5aHbsaL… Florid… Sad Count… Stay                2      200426 FALSE           0.493  0.931     1    -2.99     1\n 9 24NRxtqD6oySj… Zach B… Country C… Oklahoma …          3      211739 FALSE           0.544  0.573     8    -5.69     1\n10 3opqy7HYeNHQa… Thomas… Tailgate … Put It On…          0      184800 FALSE           0.554  0.757     0    -4.30     1\n# ℹ 6,632 more rows\n# ℹ 9 more variables: speechiness &lt;dbl&gt;, acousticness &lt;dbl&gt;, instrumentalness &lt;dbl&gt;, liveness &lt;dbl&gt;, valence &lt;dbl&gt;,\n#   tempo &lt;dbl&gt;, time_signature &lt;dbl&gt;, track_genre &lt;chr&gt;, popular_or_not &lt;chr&gt;\n\n\n\n# Count how many times each artist appears across all tracks\n# Artists involved in collaborations will be counted multiple times\nartists_long |&gt; \n  count(artists, sort = TRUE)\n\n# A tibble: 2,688 × 2\n   artists                   n\n   &lt;chr&gt;                 &lt;int&gt;\n 1 ILLENIUM                 91\n 2 Anirudh Ravichander      79\n 3 Sidhu Moose Wala         63\n 4 Linkin Park              59\n 5 SLANDER                  35\n 6 Seven Lions              34\n 7 Tritonal                 29\n 8 AP Dhillon               28\n 9 Red Hot Chili Peppers    28\n10 Porter Robinson          27\n# ℹ 2,678 more rows\n\n\n\nWe use separate_rows() to split the artists column into multiple rows whenever songs have more than one artist listed.\n\nThis transformation puts the data in long format, allowing each artist to be analyzed individually—even in collaborations.\n\nAll other columns (e.g., track name, genre) are repeated for each artist, preserving context.\n\nUsing count() on the artists column gives us a ranked list of how frequently each artist appears.\n\nThis method captures both solo tracks and group efforts, giving a more complete view of artist participation.\n\nIt’s especially useful for identifying the most active or featured artists in the dataset.\n\n\n\n\n\n# Use fct_lump() to group all but the top 3 most common genres into \"Other\"\nspotify |&gt;\n  mutate(track_genre = forcats::fct_lump(track_genre, n = 3)) |&gt;\n  count(track_genre)\n\n# A tibble: 4 × 2\n  track_genre     n\n  &lt;fct&gt;       &lt;int&gt;\n1 deep-house    903\n2 dubstep       871\n3 metal         775\n4 Other        1762\n\n\n\n# View the current counts for popular_or_not to check the ordering and distribution\nspotify |&gt; \n  count(popular_or_not)\n\n# A tibble: 2 × 2\n  popular_or_not     n\n  &lt;chr&gt;          &lt;int&gt;\n1 not popular     2325\n2 popular         1986\n\n\n\n# Reorder factor levels for popular_or_not so that \"popular\" appears first\nspotify |&gt;\n  mutate(popular_or_not = forcats::fct_relevel(popular_or_not, \"popular\")) |&gt;\n  count(popular_or_not)\n\n# A tibble: 2 × 2\n  popular_or_not     n\n  &lt;fct&gt;          &lt;int&gt;\n1 popular         1986\n2 not popular     2325\n\n\n\nWe use fct_lump() to combine less common genres into an “Other” category, keeping the focus on the top 3 most frequent ones.\n\nThis simplifies plots and summaries by reducing clutter from too many categories.\n\ncount(popular_or_not) helps us inspect the current distribution and order of that categorical variable.\n\nWe use fct_relevel() to move \"popular\" to the first position, which can influence plotting order and improve clarity.\n\nReordering factor levels helps ensure categories appear in a meaningful or intuitive order in visualizations.\n\nThese factor tools from the forcats package are essential for making categorical variables more analysis- and presentation-friendly.\n\n\n\n\n\nlibrary(forcats)\n\n# Create a new column that counts the number of words in each track name\nspotify |&gt;\n  mutate(\n    word_count = str_count(track_name, \"\\\\w+\")\n  ) |&gt;\n  \n  # Group by genre and calculate the average word count per genre\n  group_by(track_genre) |&gt;\n  summarize(\n    avg_words = mean(word_count, na.rm = TRUE),\n    .groups = \"drop\"\n  ) |&gt;\n  \n  # Reorder genres based on average word count for clearer plotting\n  mutate(track_genre = fct_reorder(track_genre, avg_words)) |&gt;\n  \n  # Create a horizontal bar chart of average word counts by genre\n  ggplot(aes(x = track_genre, y = avg_words)) +\n  geom_col(fill = \"steelblue\") +\n  \n  # Add the rounded average word count at the end of each bar\n  geom_text(aes(label = round(avg_words, 1)), hjust = -0.1, size = 3.5) +\n  \n  # Flip coordinates so genres appear on the y-axis\n  coord_flip() +\n  \n  # Add labels and title\n  labs(\n    title = \"Average Number of Words in Track Names by Genre\",\n    x = \"Track Genre\",\n    y = \"Average Word Count\"\n  ) +\n  \n  # Apply a clean minimal theme\n  theme_minimal()\n\n\n\n\n\nWe use str_count() with the \\\\w+ pattern to count the number of words in each track title.\n\nGrouping by track_genre and calculating the mean gives us the average word count per genre.\n\nfct_reorder() reorders genres based on average word count, improving the readability of the plot.\n\nA horizontal bar chart (geom_col() with coord_flip()) displays genre comparisons clearly.\n\ngeom_text() adds numeric labels to each bar, making the values easy to interpret at a glance.\n\nThis combines text processing and visualization to uncover stylistic patterns in how songs are titled across genres.\n\n\n\n\n\nlibrary(tidyr)\n\n# Split artists so each appears in their own row (for collaborations)\nspotify |&gt;\n  separate_rows(artists, sep = \";\") |&gt;\n  \n  # Keep only distinct artist–genre pairs\n  distinct(artists, track_genre) |&gt;\n  \n  # Group by artist and filter for those appearing in more than one genre\n  group_by(artists) |&gt;\n  filter(n_distinct(track_genre) &gt; 1) |&gt;\n  \n  # Sort alphabetically and display artist–genre combinations\n  arrange(artists) |&gt;\n  select(artists, track_genre)\n\n# A tibble: 115 × 2\n# Groups:   artists [57]\n   artists           track_genre\n   &lt;chr&gt;             &lt;chr&gt;      \n 1 Alok              dubstep    \n 2 Alok              rock       \n 3 Asking Alexandria dubstep    \n 4 Asking Alexandria metal      \n 5 Atreyu            dubstep    \n 6 Atreyu            metal      \n 7 BANNERS           dubstep    \n 8 BANNERS           rock       \n 9 Billy Ray Cyrus   country    \n10 Billy Ray Cyrus   hip-hop    \n# ℹ 105 more rows\n\n\n\nWe use separate_rows() to split collaborations so each artist appears on their own row.\n\ndistinct() ensures we only keep unique artist–genre pairs, removing duplicates.\n\nGrouping by artist allows us to analyze their genre diversity across tracks.\n\nfilter(n_distinct(track_genre) &gt; 1) identifies artists who appear in more than one genre.\n\nSorting and selecting just artists and track_genre gives a clean view of cross-genre activity.\n\nThis technique highlights artist versatility and reveals patterns of collaboration across genres.\n\n\n\n\n\n# Load the azflights24 and lubridate packages for flight data and date manipulation\nlibrary(azflights24)\nlibrary(lubridate)\n\n\nAttaching package: 'lubridate'\n\n\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n\n# Preview a random sample of flight records\nflights |&gt; \n  slice_sample(n = 30)\n\n# A tibble: 30 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier flight tailnum origin\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt; &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;   &lt;chr&gt; \n 1  2024     5     7     1544           1552        -8     2140           2217       -37 AA         644 N954NN  PHX   \n 2  2024    11    20      732            735        -3      836            840        -4 WN         141 N8759Q  PHX   \n 3  2024    10     7     1330           1335        -5     1649           1651        -2 OO        1316 N732SK  PHX   \n 4  2024     2     8     1710           1712        -2     2331           2359       -28 AA         119 N443AA  PHX   \n 5  2024     5     3     1731           1725         6     1849           1855        -6 WN         878 N436WN  PHX   \n 6  2024    11    27      859            900        -1     1006           1000         6 WN         347 N930WN  PHX   \n 7  2024    11    30     2255           2300        -5     2353           2353         0 OO        1754 N774SK  PHX   \n 8  2024     8    30     1719           1715         4     2122           2120         2 WN         725 N258WN  PHX   \n 9  2024     3     7      953            959        -6     1051           1106       -15 OO        1046 N724EV  PHX   \n10  2024     7    10      839            843        -4     1105           1120       -15 OO        1085 N521SY  PHX   \n# ℹ 20 more rows\n# ℹ 6 more variables: dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n# Create a proper date column by combining year, month, and day\n(\n  flights_fixed &lt;- flights |&gt;\n    mutate(flight_date = make_date(year, month, day)) |&gt;\n    select(flight, origin, dest, carrier, year, month, day, flight_date)\n)\n\n# A tibble: 221,144 × 8\n   flight origin dest  carrier  year month   day flight_date\n    &lt;int&gt; &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;date&gt;     \n 1   1024 PHX    CLT   AA       2024     1     1 2024-01-01 \n 2    643 PHX    EWR   UA       2024     1     1 2024-01-01 \n 3    126 PHX    DCA   AA       2024     1     1 2024-01-01 \n 4   1155 PHX    DFW   F9       2024     1     1 2024-01-01 \n 5   1260 PHX    EWR   NK       2024     1     1 2024-01-01 \n 6    376 PHX    MCO   F9       2024     1     1 2024-01-01 \n 7    152 PHX    ORD   UA       2024     1     1 2024-01-01 \n 8   1379 PHX    ATL   F9       2024     1     1 2024-01-01 \n 9     99 PHX    DEN   WN       2024     1     1 2024-01-01 \n10    410 PHX    SAT   WN       2024     1     1 2024-01-01 \n# ℹ 221,134 more rows\n\n\n\n# Extract the month name (abbreviated) from the flight_date column for PHX-origin flights\nflights |&gt;\n  filter(origin == \"PHX\") |&gt; \n  mutate(\n    flight_date = make_date(year, month, day),\n    month_name = month(flight_date, label = TRUE)\n  ) |&gt;\n  count(month_name)\n\n# A tibble: 12 × 2\n   month_name     n\n   &lt;ord&gt;      &lt;int&gt;\n 1 Jan        15378\n 2 Feb        14823\n 3 Mar        17375\n 4 Apr        16531\n 5 May        16741\n 6 Jun        15326\n 7 Jul        15733\n 8 Aug        15416\n 9 Sep        15081\n10 Oct        16978\n11 Nov        16827\n12 Dec        17342\n\n\n\nWe use make_date() from lubridate to combine year, month, and day into a proper Date column, simplifying date operations.\n\nCreating a flight_date column makes it easier to filter, sort, or extract time-based features.\n\nUsing month(flight_date, label = TRUE) lets us extract readable, abbreviated month names.\n\nFiltering for flights from Phoenix (PHX) helps narrow the focus to a specific origin airport.\n\ncount(month_name) shows the number of flights from PHX by month, revealing potential seasonal trends.\n\nThis workflow highlights how lubridate integrates smoothly with tidyverse tools for effective date manipulation and analysis.\n\n\n\n\n\n\n\n# Filter for flights that originated in PHX\n# Count how many flights went to each destination\n# Reorder destinations so the bars display in order of frequency\nflights |&gt;\n  filter(origin == \"PHX\") |&gt;\n  count(dest) |&gt;\n  mutate(dest = forcats::fct_reorder(dest, n)) |&gt;\n  ggplot(aes(x = dest, y = n)) +\n  geom_col() +\n  coord_flip() +\n  labs(title = \"Number of Flights from PHX to Each Destination\",\n       x = \"Destination\", y = \"Number of Flights\")\n\n\n\n\n\n# Filter for flights from PHX again\n# Group rare destinations with fewer than 1000 flights into an \"Other\" category\n# Reorder factor levels by count and visualize as a bar chart\nflights |&gt;\n  filter(origin == \"PHX\") |&gt;\n  mutate(dest_lumped = forcats::fct_lump_min(\n    dest, min = 1000, other_level = \"Other\")\n  ) |&gt;\n  count(dest_lumped, name = \"n\") |&gt;\n  mutate(dest_lumped = fct_reorder(dest_lumped, n)) |&gt;\n  ggplot(aes(x = dest_lumped, y = n)) +\n  geom_col() +\n  coord_flip() +\n  labs(\n    title = \"Number of Flights from PHX to Each Destination\",\n    x = \"Destination\",\n    y = \"Number of Flights\"\n  )\n\n\n\n\n\n\n\n\n# Reorder track genres by the median popularity of their songs\n# Create a violin plot with quantile lines to show distribution\nspotify |&gt;\n  mutate(track_genre = fct_reorder(track_genre, popularity, .fun = median)) |&gt;\n  ggplot(aes(x = track_genre, y = popularity)) +\n  geom_violin(draw_quantiles = c(0.25, 0.5, 0.75)) +\n  coord_flip()\n\n\n\n\n\nWe use fct_reorder() to sort bars in descending order of flight count, making plots easier to read and interpret.\n\ncoord_flip() rotates the bar chart so destinations appear on the y-axis—ideal for longer text labels.\n\nfct_lump_min() groups destinations with fewer than 1000 flights into an “Other” category, reducing clutter.\n\nThese techniques highlight the most traveled routes from Phoenix while simplifying less important details.\n\nIn the second example, we reorder genres by the median popularity of songs to make genre comparisons more meaningful.\n\nViolin plots with quantile lines reveal the distribution and spread of song popularity within each genre, not just the average.\n\n\n\n\n\n\n# Prepare weather data for PHX and FLG airports during July 2024\n# Bin timestamps into 6-hour intervals, create human-readable labels\nweather_az_binned &lt;- azflights24::weather |&gt; \n  filter(origin %in% c(\"PHX\", \"FLG\")) |&gt; \n  filter(between(time_hour, ymd(\"2024-07-01\"), ymd(\"2024-07-31\"))) |&gt; \n  mutate(\n    time_bin_start = floor_date(time_hour, unit = \"6 hours\"),\n    time_bin_end = time_bin_start + hours(6),\n    label = str_c(\n      wday(time_bin_start, label = TRUE), \", \",\n      month(time_bin_start, label = TRUE), \" \",\n      day(time_bin_start), \" @ \",\n      strftime(time_bin_start, \"%I:%M %p\"), \"–\",\n      strftime(time_bin_end, \"%I:%M %p\")\n    )\n  ) |&gt; \n  group_by(origin, time_bin_start, label) |&gt; \n  summarize(avg_temp = mean(temp, na.rm = TRUE), .groups = \"drop\") |&gt; \n  mutate(\n    tooltip_text = str_c(\n      label, \"\\n\",\n      \"Avg Temp: \", round(avg_temp, 1), \"°F\"\n    )\n  )\n\n\n# Create a ggplot line chart with interactive tooltips using plotly\np &lt;- ggplot(weather_az_binned, aes(x = time_bin_start, y = avg_temp, \n                                   text = tooltip_text, group = origin)) +\n  geom_line(aes(color = origin)) +\n  geom_point(color = \"black\") +\n  labs(\n    title = \"Average Temperature in Phoenix and Flagstaff (6-Hour Intervals) for July 2024\",\n    x = \"July 6-hour Time Bins\",\n    y = \"Avg Temperature (F)\"\n  ) +\n  scale_color_manual(values = c(\"PHX\" = \"red\", \"FLG\" = \"blue\"))\n\n# Render the plot as an interactive Plotly chart with custom tooltips\nplotly::ggplotly(p, tooltip = \"text\")\n\n\n\n\n\n\nWe filter weather data for PHX and FLG airports during July 2024 and group it into 6-hour time bins for clearer trend analysis.\n\nfloor_date() and mutate() help create readable time interval labels, making the timeline easier to interpret.\n\nWe calculate average temperature per airport and time bin using group_by() and summarize().\n\nTooltips are customized using str_c() to show detailed labels when hovering over data points.\n\ngeom_line() creates a line for each airport, and geom_point() adds black markers to highlight individual values.\n\nggplotly() transforms the static plot into an interactive chart, allowing dynamic exploration of temporal weather trends.\n\n\n\n\n\n# Load survey data on weather app preferences from the fivethirtyeight package\ndata(\"weather_check\", package = \"fivethirtyeight\")\n\n# Prepare the data by filtering out missing values\n# Lump less common weather sources into \"Other\"\n# Reorder regions based on frequency of responses\ngrouped_responses &lt;- weather_check |&gt;\n  filter(!is.na(weather_source), !is.na(region)) |&gt;\n  mutate(\n    weather_source = fct_lump(weather_source, n = 4),\n    region = fct_infreq(region)\n  ) |&gt;\n  count(region, weather_source) |&gt;\n  arrange(region, desc(n))\n\n\n# Create a side-by-side bar plot showing weather source preferences by region\nggplot(grouped_responses, aes(x = region, y = n, fill = weather_source)) +\n  geom_col(position = \"dodge\") +\n  coord_flip() +\n  labs(\n    title = \"Weather App Preferences by Region\",\n    x = \"Weather Source\",\n    y = \"Count\"\n  ) +\n  theme_minimal()\n\n\n\n\n\nWe load and clean the weather_check dataset by filtering out missing values for weather_source and region.\n\nfct_lump() groups less common weather apps into an “Other” category to simplify the plot.\n\nfct_infreq() reorders regions by how frequently they appear in the data, improving readability.\n\nWe use count() to tally the number of responses for each combination of region and weather source.\n\nA side-by-side bar plot (geom_col(position = \"dodge\")) compares weather app preferences across regions.\n\ncoord_flip() rotates the chart, making long region names easier to read and the overall plot more user-friendly.\n\n\n\n\n\n(3.1) Why does the regex pattern \"\\\\(.*?\\\\)\" used in str_remove_all() work better than \"\\\\(.*\\\\)\" when cleaning track names?\nA. The .*? forces R to skip anything in parentheses rather than match it.\nB. .*? is a greedy matcher that ensures the longest match possible is removed.\nC. \"\\\\(.*?\\\\)\" only works when the parentheses are numeric, like (1) or (2). D. .*? makes the match non-greedy, stopping at the first closing parenthesis.\n\n(3.2) What does this code return?\nspotify |&gt;\n  separate_rows(artists, sep = \";\") |&gt;\n  distinct(artists, track_genre) |&gt;\n  group_by(artists) |&gt;\n  filter(n_distinct(track_genre) &gt; 1)\nA. It returns artists who appear in more than one track.\nB. It returns tracks that are associated with more than one genre.\nC. It returns genres that feature more than one artist.\nD. It returns artists that appear in more than one genre.\n\n(3.3) What will the following code produce?\nspotify |&gt;\n  mutate(track_name_clean = str_remove_all(track_name, \"\\\\(.*?\\\\)\")) |&gt;\n  select(track_name, track_name_clean)\nA. A data frame with only tracks that contain parentheses in their names\nB. A new column with all track names replaced by text inside parentheses\nC. A new column where all content inside parentheses has been removed from track names\nD. A subset of songs where all punctuation has been stripped from the track name\n\n(3.4) Which of the following best explains the use of fct_lump(track_genre, n = 3)?\nA. It removes the three most frequent levels in the track_genre factor.\nB. It converts the track_genre variable into numeric rank based on popularity.\nC. It keeps only the top three most common genres and lumps the rest into “Other”.\nD. It randomly selects three genres to collapse into one category.\n\n(3.5) What does this ggplot() show?\nspotify |&gt;\n  mutate(track_genre = fct_reorder(track_genre, popularity, .fun = max)) |&gt;\n  ggplot(aes(x = track_genre, y = popularity)) +\n  geom_violin()\nA. A violin plot sorted alphabetically by genre name\nB. A violin plot of genre popularity, with genres ordered by max popularity\nC. A violin plot of max track length across genres\nD. A histogram showing popularity grouped by genre\n\n\n\n\n(3.1) Why does the regex pattern \"\\\\(.*?\\\\)\" used in str_remove_all() work better than \"\\\\(.*\\\\)\" when cleaning track names?\nCorrect Answer:\nD. .*? makes the match non-greedy, stopping at the first closing parenthesis.\nExplanation:\nThe .*? part tells the regex engine to match as little as possible. This avoids removing everything between the first opening and the last closing parenthesis, which .* (greedy) would do.\n\n(3.2) What does this code return?\nCorrect Answer:\nD. It returns artists that appear in more than one genre.\nExplanation:\nThe code first separates artists into rows, then finds unique artist–genre pairs, and filters for those where an artist is associated with more than one genre.\n\n(3.3) What will the following code produce?\nCorrect Answer:\nC. A new column where all content inside parentheses has been removed from track names\nExplanation:\nThe regex removes text (and parentheses themselves) like (Remix) or (feat. Someone) using a non-greedy match. The cleaned result is stored in a new column.\n\n(3.4) Which of the following best explains the use of fct_lump(track_genre, n = 3)?\nCorrect Answer:\nC. It keeps only the top three most common genres and lumps the rest into “Other”.\nExplanation:\nfct_lump() simplifies a categorical variable by collapsing less frequent levels into one “Other” category, keeping only the top n most common.\n\n(3.5) What does this ggplot() show?\nspotify |&gt;\n  mutate(track_genre = fct_reorder(track_genre, popularity, .fun = max)) |&gt;\n  ggplot(aes(x = track_genre, y = popularity)) +\n  geom_violin()\nCorrect Answer:\nB. A violin plot of genre popularity, with genres ordered by max popularity\nExplanation:\nfct_reorder() reorders the factor levels by maximum popularity. The violin plot then visualizes the distribution of popularity for each genre in this new order."
  }
]